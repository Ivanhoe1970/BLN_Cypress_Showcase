<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enhanced Blackline Live - Alert Management</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #f8f9fa;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
      }

      .header {
        background: linear-gradient(135deg, #e3f2fd, #bbdefb);
        color: #1565c0;
        padding: 20px;
        margin-bottom: 20px;
        border-radius: 8px;
        border: 1px solid #90caf9;
        display: none;
      }

      .header.active {
        display: block;
      }

      .alert-title {
        margin: 0;
        font-size: 1.5em;
        font-weight: bold;
        margin-bottom: 15px;
      }

      .alert-details {
        background: white;
        border: 1px solid #90caf9;
        border-radius: 6px;
        padding: 15px;
        color: #333;
      }

      .alert-info {
        display: block;
        font-size: 0.9em;
      }
      .info-item {
        padding: 3px 0;
      }
      .info-item strong {
        color: #1565c0;
        font-weight: 600;
      }

      .container {
        display: grid;
        grid-template-columns: 1fr 200px 1fr 300px;
        gap: 15px;
        max-width: 1600px;
        margin: 0 auto;
        padding: 20px;
      }

      .right-column {
        display: flex;
        flex-direction: column;
        gap: 15px;
        grid-column: 4;
      }

      .protocol-log {
        background: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 20px;
      }

      .protocol-log h3 {
        margin-top: 0;
        color: #333;
        font-size: 1.1em;
      }

      .log-container {
        height: calc(100vh - 350px);
        min-height: 400px;
        overflow-y: auto;
        background: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        border: 1px solid #e9ecef;
        margin-bottom: 20px;
      }

      .log-entry {
        margin: 8px 0;
        padding: 12px;
        background: white;
        border-left: 4px solid #28a745;
        border-radius: 6px;
        font-size: 0.9em;
        line-height: 1.4;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .log-entry.step {
        border-left-color: #007bff;
      }
      .log-entry.timer {
        border-left-color: #ffc107;
      }
      .log-entry.resolution {
        border-left-color: #dc3545;
      }
      .log-entry.gas {
        border-left-color: #fd7e14;
      }
      .log-entry.system {
        border-left-color: #6c757d;
      }

      .log-placeholder {
        color: #6c757d;
        text-align: center;
        margin-top: 120px;
        font-style: normal;
        font-size: 0.9em;
        font-family: inherit;
      }

      .global-timer {
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
        border-radius: 8px;
        padding: 15px;
        text-align: center;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        position: sticky;
        top: 20px;
        height: fit-content;
        font-size: 0.9em;
      }

      .timer-controls {
        margin-top: 12px;
        display: flex;
        justify-content: center;
        padding: 0 10px; /* Breathing room from timer edges */
      }

      .timer-meta {
        margin-top: 8px;
        font-size: 0.7em;
        opacity: 0.8;
        line-height: 1.2;
        display: flex;
        justify-content: space-between;
      }

      .cancel-btn {
        background: #dc3545;
        color: white !important;
        border: none;
        padding: 8px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        font-size: 0.75em;
        transition: background 0.2s;
        width: calc(100% - 20px);
        margin: 0 10px;
        display: block;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        opacity: 1 !important;
      }

      .cancel-btn:hover:not(:disabled) {
        background: #c82333;
      }

      .cancel-btn:disabled,
      #cancelTimerBtn.cancel-btn:disabled {
        opacity: 1 !important;
        cursor: not-allowed;
        color: white !important;
        background: #dc3545 !important;
      }

      .steps-section {
        background: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 20px;
      }

      .steps-section h3 {
        margin-top: 0;
        color: #333;
        font-size: 1.1em;
      }

      .gas-readings-card {
        background: white;
        border: 2px solid #28a745;
        border-radius: 8px;
        padding: 20px;
        position: sticky;
        top: 20px;
        height: fit-content;
      }

      .gas-readings-card h3 {
        margin-top: 0;
        color: #333;
        font-size: 1.1em;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .gas-reading {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid #e9ecef;
        font-size: 0.9em;
      }

      .gas-reading:last-child {
        border-bottom: none;
      }
      .gas-value {
        font-weight: bold;
      }

      .gas-status {
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.8em;
        font-weight: bold;
      }

      .gas-status.high {
        background: #f8d7da;
        color: #721c24;
      }

      .gas-status.normal {
        background: #d4edda;
        color: #155724;
      }

      .triggered-by {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 4px;
        padding: 8px;
        margin-bottom: 15px;
        font-size: 0.85em;
        font-weight: bold;
        color: #856404;
      }

      .last-updated {
        font-size: 0.8em;
        color: #6c757d;
        text-align: center;
        margin-top: 10px;
        font-style: italic;
      }

      .connectivity-panel {
        background: white;
        border: 2px solid #6c757d;
        border-radius: 8px;
        padding: 20px;
        height: fit-content;
      }

      .connectivity-panel h3 {
        margin-top: 0;
        color: #333;
        font-size: 1em;
        margin-bottom: 15px;
      }

      .device-status,
      .last-comm {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        font-size: 0.9em;
      }

      .status-pill {
        padding: 4px 10px;
        border-radius: 20px;
        font-weight: bold;
        font-size: 0.85em;
      }

      .status-pill.online {
        background: #d4edda;
        color: #155724;
      }

      .status-pill.offline {
        background: #f8d7da;
        color: #721c24;
      }

      .status-pill.loading {
        background: #fff3cd;
        color: #856404;
      }

      .step {
        background: white;
        border: 2px solid #bbdefb; /* Blue border - lighter than protocol */
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
        position: relative;
      }

      .sub-step {
        background: #f8f9fa;
        border: 1px solid #e3f2fd; /* Even lighter blue for sub-steps */
        border-radius: 6px;
        padding: 12px;
        margin: 10px 0;
        margin-left: 15px;
      }

      .step.completed {
        background: #d4edda;
        border-color: #c3e6cb;
      }

      .step.active {
        animation: pulse-border 1.5s infinite;
      }

      @keyframes pulse-border {
        0% {
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(0, 123, 255, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0);
        }
      }

      .step-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .step-title {
        font-weight: bold;
        color: #333;
        margin: 0;
        font-size: 0.95em;
      }

      .status-badge {
        background: #ffc107;
        color: #000;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.75em;
        font-weight: bold;
      }

      .status-badge.completed {
        background: #28a745;
        color: white;
      }

      .contact-info {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 4px;
        padding: 8px;
        margin: 8px 0;
        font-size: 0.85em;
      }

      .btn {
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
        font-size: 0.85em;
        transition: all 0.2s;
      }

      .btn-primary {
        background: #007bff;
        color: white;
      }

      .btn-primary:hover:not(:disabled) {
        background: #0056b3;
      }

      .btn-success {
        background: #28a745;
        color: white;
      }

      .btn-success:hover:not(:disabled) {
        background: #1e7e34;
      }

      .btn-secondary {
        background: #6c757d;
        color: white;
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .timer-inactive {
        opacity: 0.6;
        background: linear-gradient(135deg, #6c757d, #495057);
      }

      .manual-notes {
        width: 100%;
        height: 100px;
        border-radius: 5px;
        border: 1px solid #ddd;
        padding: 10px;
        box-sizing: border-box;
        resize: vertical;
        font-family: inherit;
        font-size: 0.9em;
      }

      .step-outcome {
        margin: 10px 0;
      }

      .step-outcome select {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.9em;
      }

      .step.skipped {
        background-color: #f8f9fa !important;
        opacity: 0.6;
        pointer-events: none;
      }

      .step.skipped .status-badge {
        background-color: #6c757d !important;
        color: white !important;
      }

      .step.skipped button {
        background-color: #6c757d !important;
        color: #dee2e6 !important;
        border-color: #6c757d !important;
      }

      .step-outcome textarea {
        width: 100%;
        height: 80px;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.9em;
        margin-top: 8px;
        box-sizing: border-box;
        resize: vertical;
      }

      .resolution-section {
        background: #fff;
        border: 2px solid #dc3545;
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
      }

      .resolution-section h3 {
        margin-top: 0;
        color: #dc3545;
      }

      .resolution-section select {
        width: 100%;
        padding: 10px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      .resolution-buttons {
        display: flex;
        gap: 10px;
        margin-top: 15px;
      }

      .btn-danger {
        background: #dc3545;
        color: white;
      }

      .btn-danger:hover:not(:disabled) {
        background: #c82333;
      }

      /* Production View Toggle */
      .production-toggle {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 0.8em;
        cursor: pointer;
        z-index: 2000;
        transition: all 0.3s;
      }

      .production-toggle:hover {
        background: rgba(0, 0, 0, 0.9);
      }

      .production-mode .demo-gear,
      .production-mode .demo-panel {
        display: none !important;
      }

      .production-mode .header {
        margin-top: 10px;
      }

      /* Demo Controls */
      .demo-gear {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
        background: #6c757d;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 1000;
        transition: all 0.3s;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      }

      .demo-gear:hover {
        background: #5a6268;
        transform: rotate(90deg);
      }

      .demo-gear::before {
        content: "⚙️";
        font-size: 20px;
      }

      .demo-panel {
        position: fixed;
        bottom: 70px;
        right: 20px;
        background: rgba(255, 255, 255, 0.98);
        border-radius: 8px;
        padding: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        border: 1px solid #e9ecef;
        z-index: 999;
        max-width: 280px;
        max-height: 70vh;
        overflow-y: auto;
        display: none;
      }

      .demo-panel.show {
        display: block;
        animation: slideUp 0.3s ease-out;
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .demo-panel h4 {
        margin: 8px 0 6px 0;
        color: #333;
        font-size: 0.85em;
        border-bottom: 1px solid #e9ecef;
        padding-bottom: 4px;
        font-weight: 600;
      }

      .demo-panel h4:first-child {
        margin-top: 0;
      }

      .demo-button-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 4px;
        margin-bottom: 8px;
      }

      .demo-button-single {
        display: grid;
        grid-template-columns: 1fr;
        gap: 4px;
        margin-bottom: 8px;
      }

      .demo-panel button {
        font-size: 0.7em;
        padding: 6px 8px;
        margin: 0;
        border-radius: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1.2;
        height: auto;
        min-height: 28px;
      }

      .demo-panel .btn-secondary {
        grid-column: 1 / -1;
        margin-top: 8px;
        font-weight: 600;
      }

      .demo-section {
        margin-bottom: 10px;
      }

      .demo-section:last-child {
        margin-bottom: 0;
      }

      /* Collapsible sections */
      .demo-section-header {
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        user-select: none;
      }

      .demo-section-header::after {
        content: "▼";
        font-size: 0.7em;
        color: #666;
        transition: transform 0.2s;
      }

      .demo-section.collapsed .demo-section-header::after {
        transform: rotate(-90deg);
      }

      .demo-section.collapsed .demo-section-content {
        display: none;
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .empty-state {
        text-align: center;
        color: #6c757d;
        padding: 100px 20px;
        font-size: 1.1em;
      }

      .empty-state h2 {
        color: #1565c0;
        margin-bottom: 15px;
      }

      .protocol-placeholder {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 300px;
        padding: 20px;
      }

      .protocol-frame {
        border: 2px solid #e9ecef;
        border-radius: 8px;
        padding: 40px 30px;
        text-align: center;
        background: #f8f9fa;
        width: 100%;
        max-width: 400px;
      }

      .placeholder-text {
        font-size: 1.1em;
        font-weight: 600;
        color: #6c757d;
        margin-bottom: 10px;
      }

      .placeholder-subtitle {
        font-size: 0.9em;
        color: #8d9499;
        line-height: 1.4;
      }

      .timer-active {
        opacity: 1;
        background: linear-gradient(135deg, #007bff, #0056b3);
      }

      .timer-alert {
        animation: flashRed 1s infinite;
      }

      @keyframes flashRed {
        0%,
        50% {
          background: linear-gradient(135deg, #dc3545, #c82333);
        }
        51%,
        100% {
          background: linear-gradient(135deg, #007bff, #0056b3);
        }
      }

      .container {
        display: grid;
        grid-template-columns: 1fr 200px 1fr 300px;
        gap: 15px;
        align-items: start; /* Ensures top alignment */
      }

      .panel-box {
        background: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 20px;
      }

      .messaging-section textarea.message-input {
        width: 100%;
        resize: none;
        padding: 8px;
        font-size: 14px;
        font-family: "Rubik", sans-serif;
        line-height: 1.4;
        border-radius: 6px;
        border: 1px solid #90caf9;
        background-color: #fff;
        box-sizing: border-box;
        height: 48px; /* 2 lines of text */
        outline: none;
      }

      .messaging-section textarea.message-input:focus {
        border-color: #1565c0;
        box-shadow: 0 0 0 2px rgba(21, 101, 192, 0.2);
      }

      .char-counter {
        font-size: 12px;
        color: #666;
        margin-top: 4px;
        margin-bottom: 8px;
        font-family: "Rubik", sans-serif;
      }

      .message-history {
        margin-top: 20px;
      }

      .message-history h4 {
        font-size: 16px;
        color: #1565c0;
        margin-bottom: 10px;
        font-family: "Rubik", sans-serif;
      }

      .message-list {
        list-style: none;
        padding-left: 0;
        max-height: 160px;
        overflow-y: auto;
        border: 1px solid #90caf9;
        border-radius: 6px;
        padding: 8px;
        background: #f9f9f9;
      }

      .message-list li {
        font-size: 14px;
        margin-bottom: 8px;
        line-height: 1.3;
        white-space: pre-line;
        font-family: "Rubik", sans-serif;
      }

      .message-list li.unread {
        font-weight: bold;
      }

      /* 🔒 Style for fully disabled protocol steps after resolution */
      .disabled-step {
        opacity: 0.5;
        pointer-events: none;
        background-color: #f1f1f1;
      }

      .disabled-step button,
      .disabled-step textarea,
      .disabled-step select {
        cursor: not-allowed;
      }

      #globalTimer {
        opacity: 1 !important;
        background: linear-gradient(135deg, #007bff, #0056b3) !important;
        color: white; /* Ensures text inside shows up */
      }

      #timerDisplay {
        color: white;
        font-size: 2em;
        display: block;
        visibility: visible;
        font-family: "Courier New", monospace;
        font-weight: bold;
        margin: 8px 0;
      }

      #timerInfo {
        color: white;
        font-size: 0.8em;
        line-height: 1.3;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 8px;
        margin: 8px 0;
        display: block;
        visibility: visible;
      }

      .middle-column-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        height: calc(100vh - 120px);
        overflow-y: auto;
        padding: 10px 0;
      }

      .global-timer {
        position: static !important;
        flex-shrink: 0;
      }

      .messaging-section {
        flex: 1;
        min-height: 200px;
      }

      .log-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        padding-bottom: 4px;
        border-bottom: 1px solid #e9ecef;
      }

      .log-timestamp {
        font-weight: bold;
        color: #495057;
        font-family: "Courier New", monospace;
      }

      .log-operator {
        font-size: 0.8em;
        color: #6c757d;
        font-weight: 500;
      }

      .log-source {
        color: #1565c0;
        font-size: 0.85em;
      }

      .log-date {
        font-size: 0.8em;
        color: #6c757d;
        font-family: "Courier New", monospace;
      }

      .log-content {
        color: #333;
        line-height: 1.5;
      }

      /* Specialized Log Content Styles */
      .dispatch-summary {
        font-weight: bold;
        color: #dc3545;
        margin-bottom: 8px;
        padding: 4px 0;
      }

      .location-info,
      .coordinates,
      .device-status,
      .device-stats,
      .dispatch-detail {
        margin: 4px 0;
        padding: 2px 0;
        font-size: 0.85em;
      }

      .gas-reading-detail {
        background: #f8f9fa;
        padding: 4px 8px;
        border-radius: 3px;
        margin-top: 4px;
        font-family: "Courier New", monospace;
        font-size: 0.8em;
      }

      .timer-action {
        color: #fd7e14;
        font-weight: 500;
      }

      .step-action {
        color: #007bff;
      }

      /* Log Type Colors - Update existing ones */
      .log-entry.step {
        border-left-color: #007bff;
      }
      .log-entry.timer {
        border-left-color: #ffc107;
      }
      .log-entry.resolution {
        border-left-color: #dc3545;
      }
      .log-entry.gas {
        border-left-color: #fd7e14;
      }
      .log-entry.system {
        border-left-color: #6c757d;
      }

      /* Override Modal Styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        z-index: 2000;
      }

      .override-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border: 3px solid #dc3545;
        border-radius: 10px;
        padding: 30px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        z-index: 2001;
        max-width: 500px;
        display: none;
      }

      .override-modal h3 {
        color: #dc3545;
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.2em;
      }

      .override-modal .gas-reading-display {
        background: #f8d7da;
        border: 1px solid #f5c6cb;
        border-radius: 4px;
        padding: 12px;
        margin: 15px 0;
        color: #721c24;
        font-weight: bold;
        text-align: center;
      }

      .override-modal select {
        width: 100%;
        padding: 10px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.9em;
      }

      .override-modal .modal-buttons {
        display: flex;
        gap: 10px;
        margin-top: 20px;
        justify-content: flex-end;
      }

      .override-modal .btn {
        padding: 10px 20px;
        font-size: 0.9em;
      }

      .status-badge.active {
        background: #007bff;
        color: white;
        animation: pulse 1.5s infinite;
      }

      .status-badge.waiting {
        background: #ffc107;
        color: #000;
      }

      .status-badge.skipped {
        background: #6c757d;
        color: white;
      }

      /* Pulsing animation for active state */
      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.4);
        }
        70% {
          box-shadow: 0 0 0 6px rgba(0, 123, 255, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0);
        }
      }

      .step.dispatch-step {
        opacity: 1 !important;
      }

      #protocolLog .log-entry {
        white-space: pre-line;
      }

      /* Keep label + value together on the left; pill on the right */
      .gas-reading {
        display: flex;
        align-items: center;
        justify-content: flex-start; /* was space-between */
      }

      .gas-reading .gas-status {
        margin-left: auto; /* pushes pill to the right edge */
      }

      /* Consistent small gap after the colon; align digits neatly */
      .gas-reading .gas-value {
        display: inline-block;
        margin-left: 0.25rem;
        font-variant-numeric: tabular-nums;
        /* OPTIONAL: uncomment these two lines if you want numbers to line up vertically */
        min-width: 7ch;
        text-align: right;
      }
    </style>
  </head>
  <body>
    <!-- Demo Controls -->
    <div class="demo-gear" id="demo-gear" onclick="toggleDemoPanel()"></div>
    <div class="demo-panel" id="demo-panel">
      <div class="demo-section" id="gas-section">
        <h4
          class="demo-section-header"
          onclick="toggleDemoSection('gas-section')"
        >
          Gas Alert Tests
        </h4>
        <div class="demo-section-content">
          <div class="demo-button-grid">
            <button
              class="btn btn-primary"
              onclick="loadAlert('h2s-response')"
              title="H₂S High - User confirms OK despite gas"
            >
              H₂S Override Test
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('co-spontaneous')"
              title="CO High - Gas normalizes after message"
            >
              CO Gas Normalization
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('gas-high-threshold')"
              title="H₂S High - Standard flow"
            >
              H₂S Standard Flow
            </button>
          </div>
        </div>
      </div>

      <div class="demo-section" id="nongas-section">
        <h4
          class="demo-section-header"
          onclick="toggleDemoSection('nongas-section')"
        >
          Non-Gas Tests
        </h4>
        <div class="demo-section-content">
          <div class="demo-button-grid">
            <button
              class="btn btn-primary"
              onclick="loadAlert('sos-immediate')"
              title="SOS Alert - Perfect dispatch YES flow"
            >
              SOS - Dispatch YES
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('no-motion')"
              title="Device Message - Manual texting test"
            >
              Message - Device Comms
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('fall-spontaneous')"
              title="Fall Detection - Protocol cycle test"
            >
              Fall - Protocol Cycle
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('no-motion')"
              title="No Motion - Standard test"
            >
              No Motion - Standard
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('missed-check-in')"
              title="Missed Check-In Protocol"
            >
              Check-In Test
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('message-test')"
              title="Device messaging and manual texting"
            >
              Message - Device Comms
            </button>
          </div>
        </div>
      </div>

      <div class="demo-button-single">
        <button class="btn btn-secondary" onclick="clearAlert()">
          Clear Alert
        </button>
      </div>
    </div>

    <!-- Alert Information Header -->
    <div class="header" id="alert-header">
      <h1 class="alert-title" id="alert-title">🚨 Alert Management</h1>

      <div class="alert-details">
        <div class="alert-info">
          <div class="info-item">
            <strong>Alert ID:</strong> <span id="alert-id">--</span>
          </div>
          <div class="info-item">
            <strong>Employee:</strong> <span id="employee-details">--</span>
          </div>
          <div class="info-item">
            <strong>Device:</strong> <span id="device-details">--</span>
          </div>
          <div class="info-item">
            <strong>Mobile:</strong> <span id="mobile-number">--</span>
          </div>
          <div class="info-item">
            <strong>Alert Time:</strong> <span id="alert-time">--</span>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <!-- Column 1: Protocol Log + Add Note -->
      <div
        class="left-column"
        style="grid-column: 1; display: flex; flex-direction: column; gap: 15px"
      >
        <!-- Protocol Log -->
        <div class="protocol-log panel-box">
          <h3>📋 Protocol Log</h3>
          <div class="log-container" id="protocolLog">
            <div class="log-placeholder">
              No alert loaded. Use demo controls to load an alert type and begin
              protocol.
            </div>
          </div>
        </div>

        <!-- Add Note -->
        <div class="panel-box">
          <h3>📝 Add Note</h3>
          <textarea
            id="manual-notes"
            class="manual-notes"
            placeholder="Add notes here..."
          ></textarea>
          <button
            class="btn btn-success"
            style="margin-top: 10px"
            onclick="addManualNote()"
          >
            Post Note
          </button>
        </div>
      </div>

      <!-- Column 2: Global Timer + Messaging -->
      <div class="middle-column-container" style="grid-column: 2">
        <!-- Global Timer -->
        <div class="global-timer timer-inactive panel-box" id="globalTimer">
          <h3>⏰ Timer</h3>
          <div class="timer-display" id="timerDisplay">--:--</div>
          <div class="timer-info" id="timerInfo">
            <strong>No active timer</strong>
          </div>
          <div class="timer-controls">
            <button
              class="cancel-btn"
              id="cancelTimerBtn"
              disabled
              onclick="cancelGlobalTimer()"
            >
              🛑 Cancel Timer
            </button>
          </div>
        </div>

        <!-- Messaging UI -->
        <div class="messaging-section panel-box">
          <h3>📨 This device supports messaging</h3>
          <textarea
            id="manual-message-input"
            class="message-input"
            rows="2"
            maxlength="32"
            placeholder="Enter custom message..."
          ></textarea>
          <div class="char-counter" id="charCounter">
            32 characters remaining
          </div>
          <button
            class="btn btn-primary"
            id="sendMessageBtn"
            onclick="sendManualMessage()"
            disabled
          >
            📤 Send
          </button>
          <div class="message-history" id="messageHistory">
            <h4>📬 Messages from Device</h4>
            <ul class="message-list" id="receivedMessages"></ul>
          </div>
        </div>
      </div>

      <!-- Column 3: Emergency Steps -->
      <div class="steps-section panel-box" style="grid-column: 3">
        <h3>🚨 Emergency Response Protocol</h3>
        <div id="protocol-content">
          <div class="protocol-placeholder">
            <div class="protocol-frame">
              <div class="placeholder-text">No protocol loaded</div>
              <div class="placeholder-subtitle">
                Alert type will load the relevant emergency response protocol
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Column 4: Gas Readings -->
      <div
        class="right-column"
        style="grid-column: 4; display: flex; flex-direction: column; gap: 15px"
      >
        <!-- Gas Readings -->
        <div class="panel-box" id="gasReadingsCard">
          <h3>🔎 Gas Readings (Live)</h3>
          <div class="triggered-by" id="triggeredBy" style="display: none">
            Alert Type: <span id="alert-trigger">--</span>
          </div>
          <div class="gas-reading" id="h2s-reading">
            <span
              >🟢 H₂S:
              <span class="gas-value" id="h2s-value">1.20 ppm</span></span
            >
            <span class="gas-status normal" id="h2s-status">NORMAL</span>
          </div>
          <div class="gas-reading" id="co-reading">
            <span
              >🟢 CO:
              <span class="gas-value" id="co-value">2.50 ppm</span></span
            >
            <span class="gas-status normal" id="co-status">NORMAL</span>
          </div>
          <div class="gas-reading" id="o2-reading">
            <span
              >🟢 O₂:
              <span class="gas-value" id="o2-value">20.90 %vol</span></span
            >
            <span class="gas-status normal" id="o2-status">NORMAL</span>
          </div>
          <div class="gas-reading" id="lel-reading">
            <span
              >🟢 LEL:
              <span class="gas-value" id="lel-value">0.50 %LEL</span></span
            >
            <span class="gas-status normal" id="lel-status">NORMAL</span>
          </div>
          <div class="last-updated" id="lastUpdated" style="display: none">
            Last updated: <span id="gas-timestamp">--</span>
          </div>
        </div>

        <!-- Device Connectivity Panel -->
        <div class="connectivity-panel" id="connectivityPanel">
          <h3>📡 Device Connectivity</h3>

          <div class="connectivity-item">
            <span>Status:</span>
            <span class="status-pill online" id="device-online-status"
              >🟢 Online</span
            >
          </div>

          <div class="connectivity-item">
            <span>Last Communication:</span>
            <span class="connectivity-value" id="last-comm-time"
              >Aug 02, 2025 at 17:11 MDT</span
            >
          </div>

          <div class="connectivity-item">
            <span>Battery Level:</span>
            <span class="connectivity-value" id="battery-level">85%</span>
          </div>

          <div class="connectivity-item">
            <span>Signal Strength:</span>
            <span class="connectivity-value" id="signal-strength">70%</span>
          </div>

          <div class="location-section">
            <h4>📍 Last Known Location</h4>

            <div class="connectivity-item">
              <span>Address:</span>
              <span class="connectivity-value" id="device-location"
                >144252 434 Ave E, Aldersyde, AB</span
              >
            </div>

            <div class="connectivity-item">
              <span>Coordinates:</span>
              <span class="connectivity-value" id="device-coordinates"
                >50.66004, -113.7685769</span
              >
            </div>

            <div class="connectivity-item">
              <span>Speed:</span>
              <span class="connectivity-value" id="device-speed">0.0 km/h</span>
            </div>

            <div class="connectivity-item">
              <span>Location Updated:</span>
              <span class="connectivity-value" id="location-timestamp"
                >Aug 02, 2025 at 15:28 MDT</span
              >
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Gas Override Modal -->
    <div class="modal-overlay" id="modalOverlay"></div>
    <div class="override-modal" id="overrideModal">
      <h3>⚠️ Gas levels are still elevated</h3>
      <p>Are you sure you want to resolve this alert?</p>

      <div class="gas-reading-display" id="overrideGasReading">
        Current Gas Reading: H₂S: 17.90 ppm (HIGH)
      </div>

      <label for="override-reason"
        ><strong>Please confirm the reason for override:</strong></label
      >
      <select id="override-reason">
        <option value="">-- Select override reason --</option>
        <option value="sensor-error">Sensor error</option>
        <option value="user-confirmed-safety">
          User confirmed they are okay
        </option>
        <option value="ec-confirmed-safety">
          Emergency contact confirmed user is okay
        </option>
        <option value="bump-test">Bump Test/Calibration in progress</option>
        <option value="other">Other</option>
      </select>

      <div class="modal-buttons">
        <button
          class="btn btn-danger"
          id="confirmOverrideBtn"
          disabled
          onclick="confirmOverride()"
        >
          Resolve Alert
        </button>
        <button class="btn btn-secondary" onclick="cancelOverride()">
          Cancel
        </button>
      </div>
    </div>
    <script>
      // ═══════════════════════════════════════════════════════════════
      // 📊 GLOBAL STATE & DATA
      // ═══════════════════════════════════════════════════════════════

      // ── Centralized timezones ───────────────────────────────
      const TIMEZONES = {
        MOUNTAIN: "America/Denver", // Matches your current logs (MDT)
        EASTERN: "America/Toronto",
      };

      // ── Centralized formatters ──────────────────────────────
      const FORMATTERS = {
        // Full timestamp [YYYY-MM-DD HH:mm:ss MDT]
        timestampMST: (date) => {
          return (
            new Intl.DateTimeFormat("en-US", {
              timeZone: TIMEZONES.MOUNTAIN,
              year: "numeric",
              month: "2-digit",
              day: "2-digit",
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
              hour12: false,
            }).format(date) + " MDT"
          );
        },

        // Time only [HH:mm:ss MDT]
        timeOnlyMST: (date) => {
          return (
            new Intl.DateTimeFormat("en-US", {
              timeZone: TIMEZONES.MOUNTAIN,
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
              hour12: false,
            }).format(date) + " MDT"
          );
        },
      };

      // Global state variables
      let currentAlert = null;
      let currentUser = null;
      let gasUpdateInterval = null;
      let dispatchMade = false;
      let globalTimerInterval = null;
      let activeTimerData = null;
      let globalTimerEndTime = null;
      let tabFlashInterval = null;
      let localTimerInterval = null;
      let beepTimeouts = [];
      let originalTitle = "Enhanced Blackline Live - Alert Management";

      // Protocol state management
      let protocolState = {
        completedSteps: [],
        currentStep: 1,
        dispatchMade: false,
        alertResolved: false,
        deviceMessageReceived: false,
        currentProtocol: null,
      };

      // Gas readings data
      const gasReadingsData = {
        "h2s-high": {
          h2s: { value: 17.9, status: "HIGH" },
          co: { value: 2.5, status: "NORMAL" },
          o2: { value: 20.9, status: "NORMAL" },
          lel: { value: 4.0, status: "NORMAL" },
        },
        "co-high": {
          h2s: { value: 1.2, status: "NORMAL" },
          co: { value: 250.0, status: "HIGH" },
          o2: { value: 20.9, status: "NORMAL" },
          lel: { value: 0.5, status: "NORMAL" },
        },
        "gas-high-threshold": {
          h2s: { value: 17.9, status: "HIGH" },
          co: { value: 2.5, status: "NORMAL" },
          o2: { value: 20.9, status: "NORMAL" },
          lel: { value: 4.0, status: "NORMAL" },
        },
        default: {
          h2s: { value: 1.2, status: "NORMAL" },
          co: { value: 2.5, status: "NORMAL" },
          o2: { value: 20.9, status: "NORMAL" },
          lel: { value: 0.5, status: "NORMAL" },
        },
      };

      let alertsFromJSON = null;

      function isAnyGasDangerousNow() {
        const pills = document.querySelectorAll("[id$='-status']");
        for (const el of pills) {
          const id = (el.id || "").toLowerCase(); // e.g., 'h2s-status'
          const txt = (el.textContent || "").trim().toUpperCase(); // e.g., 'HIGH'
          if (id.startsWith("o2-")) {
            if (/ENRICHMENT|DEPLETION/.test(txt)) return true;
          } else if (/HIGH/.test(txt)) {
            return true; // h2s / co / lel / any future gas with HIGH
          }
        }
        return false; // all normal
      }

      // Load JSON data when page loads
      document.addEventListener("DOMContentLoaded", function () {
        // Load JSON alerts
        fetch("../cypress/fixtures/gas_alerts.json")
          .then((response) => response.json())
          .then((data) => {
            alertsFromJSON = data;
            console.log("Loaded alerts from JSON:", data.length, "alerts");
          })
          .catch((error) => {
            console.error("Failed to load JSON alerts:", error);
          });

        // Your existing initialization
        updateGasReadings("default");
        startGasMonitoring();

        // ADD MANUAL NOTES VALIDATION:
        const manualNotesTextarea = document.getElementById("manual-notes");
        const manualNotesButton = document.querySelector(
          'button[onclick="addManualNote()"]'
        );

        if (manualNotesTextarea && manualNotesButton) {
          // Initially disable button
          manualNotesButton.disabled = true;
          manualNotesButton.classList.add("btn-secondary");
          manualNotesButton.classList.remove("btn-success");

          // Enable/disable based on content
          manualNotesTextarea.addEventListener("input", function () {
            if (this.value.trim().length > 0) {
              manualNotesButton.disabled = false;
              manualNotesButton.classList.remove("btn-secondary");
              manualNotesButton.classList.add("btn-success");
            } else {
              manualNotesButton.disabled = true;
              manualNotesButton.classList.add("btn-secondary");
              manualNotesButton.classList.remove("btn-success");
            }
          });
        }
      });

      // Data Management System
      class AlertDataManager {
        static usersData = {
          "zach-sowell": {
            id: "373595",
            name: "Zach Sowell",
            device: "G7c-3571031421",
            mobile: "+1 470-505-6195",
            company: "WM - Corporate",
            work: "+1 470-505-6195",
            home: "+1 208-995-4975",
            emergencyContacts: [
              {
                name: "Daniel Reyes",
                phone: "+1-587-333-9271",
                role: "Site Supervisor",
              },
              {
                name: "Vanessa Liu",
                phone: "+1-780-452-1189",
                role: "Control Room Operator",
              },
            ],
          },
          "marcus-rodriguez": {
            id: "428756",
            name: "Marcus Rodriguez",
            device: "G7c-2947182653",
            mobile: "+1 403-555-0167",
            company: "Enbridge Pipelines",
            work: "+1 403-555-0167",
            home: "+1 403-555-0168",
            emergencyContacts: [
              {
                name: "Mike Chen",
                phone: "+1-403-555-0123",
                role: "Site Supervisor",
              },
              {
                name: "Sarah Kim",
                phone: "+1-403-555-0124",
                role: "Safety Coordinator",
              },
            ],
          },
        };

        static alertTypesData = {
          "h2s-spontaneous": {
            id: "h2s-spontaneous",
            displayName:
              "High threshold detected (H₂S) - Spontaneous - No Dispatch",
            user: "zach-sowell",
            protocolFile: "gas-emergency-protocol",
            gasType: "h2s-high",
            testType: "spontaneous",
            gasNormalization: { enabled: false },
            deviceConditions: {
              lastComm: 5,
              battery: 85,
              signal: 70,
              locationAge: 4320, // 3 days old (BAD - stale location)
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
          },
          "h2s-response": {
            id: "h2s-response",
            displayName:
              "High threshold detected (H₂S) - Response - No Dispatch",
            user: "zach-sowell",
            protocolFile: "gas-emergency-protocol",
            gasType: "h2s-high",
            testType: "response",
            gasNormalization: { enabled: false },
            deviceConditions: {
              lastComm: 5,
              battery: 85,
              signal: 70,
              locationAge: 2,
              deviceSpeed: 95, // 95 km/h (BAD - moving too fast)
              deviceStatus: "Online",
            },
          },
          "co-spontaneous": {
            id: "co-spontaneous",
            displayName: "High threshold detected (CO) - Dispatch",
            user: "marcus-rodriguez",
            protocolFile: "gas-emergency-protocol",
            gasType: "co-high",
            testType: "spontaneous",
            deviceConditions: {
              lastComm: 3,
              battery: 78,
              signal: 85,
              locationAge: 1,
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
            gasNormalization: {
              enabled: true,
              triggerAfterStep: "step-2", // After messaging device
              targetLevels: {
                co: {
                  value: 2.5,
                  status: "NORMAL",
                },
              },
            },
          },
          "fall-spontaneous": {
            id: "fall-spontaneous",
            displayName: "Fall detection - Spontaneous - No Dispatch",
            user: "marcus-rodriguez",
            protocolFile: "fall-detection-protocol",
            gasType: "default",
            testType: "spontaneous",
            deviceConditions: {
              lastComm: 1, // 1 minute ago (GOOD - online)
              battery: 85, // 85% (GOOD - high battery)
              signal: 70, // 70% (GOOD - strong signal)
              locationAge: 2880, // 2 days old (BAD - stale location)
              deviceSpeed: 0.0, // Stationary (GOOD)
              deviceStatus: "Online",
            },
          },
          "fall-detection": {
            id: "fall-detection",
            displayName: "Fall detection detected - Dispatch",
            user: "marcus-rodriguez",
            protocolFile: "fall-detection-protocol",
            gasType: "default",
            testType: "legacy",
            deviceConditions: {
              lastComm: 1,
              battery: 92,
              signal: 95,
              locationAge: 0.5,
              deviceSpeed: 2.1,
              deviceStatus: "Online",
            },
          },
          "sos-immediate": {
            id: "sos-immediate",
            displayName: "SOS alert - Immediate Help - Dispatch",
            user: "zach-sowell",
            protocolFile: "sos-protocol",
            gasType: "default",
            testType: "immediate-help",
            deviceConditions: {
              lastComm: 2,
              battery: 95,
              signal: 98,
              locationAge: 1,
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
          },
          "no-motion": {
            id: "no-motion",
            displayName: "No motion detected - No Dispatch",
            user: "marcus-rodriguez",
            protocolFile: "no-motion-protocol",
            gasType: "default",
            testType: "legacy",
            deviceConditions: {
              lastComm: 8,
              battery: 25,
              signal: 45,
              locationAge: 180, // 3 hours old (BAD - stale location)
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
          },
          "gas-high-threshold": {
            id: "gas-high-threshold",
            displayName: "High threshold detected (H₂S) - Dispatch",
            user: "zach-sowell",
            protocolFile: "gas-emergency-protocol",
            gasType: "h2s-high",
            testType: "legacy",
            deviceConditions: {
              lastComm: 4,
              battery: 88,
              signal: 82,
              locationAge: 2,
              deviceSpeed: 1.2,
              deviceStatus: "Online",
            },
          },
          "message-test": {
            id: "message-test",
            displayName: "Device Message Test - Dispatch",
            user: "marcus-rodriguez",
            protocolFile: "no-motion-protocol",
            gasType: "default",
            testType: "response",
            deviceConditions: {
              lastComm: 1,
              battery: 75,
              signal: 88,
              locationAge: 3,
              deviceSpeed: 0.5,
              deviceStatus: "Online",
            },
          },
          "missed-check-in": {
            id: "missed-check-in",
            displayName: "Missed check-in - No Dispatch",
            user: "zach-sowell",
            protocolFile: "missed-check-in-protocol",
            gasType: "default",
            testType: "response",
            deviceConditions: {
              lastComm: 12,
              battery: 35,
              signal: 22,
              locationAge: 3,
              deviceSpeed: 95.7, // 95.7 km/h (BAD - moving too fast)
              deviceStatus: "Online",
            },
          },
        };
      }

      // Single source of truth for test alerts
      function resolveAlertById(id) {
        const map = AlertDataManager?.alertTypesData || {};
        const alert = map[id];
        if (!alert) {
          console.warn(`resolveAlertById: unknown alert id "${id}"`);
          return null;
        }
        // return a deep-ish clone so mutations don't affect fixtures
        return JSON.parse(JSON.stringify(alert));
      }

      // Optional: show what we actually have loaded
      console.log(
        `Loaded alert types: ${
          Object.keys(AlertDataManager.alertTypesData || {}).length
        } ids`,
        Object.keys(AlertDataManager.alertTypesData || {})
      );

      // Protocol Factory
      class ProtocolFactory {
        static protocolsData = {
          "gas-emergency-protocol": {
            name: "Gas Emergency Protocol",
            steps: [
              {
                id: "step-1",
                title: "Call Device and Validate Need for Assistance", // ← Removed "STEP 1:"
                action: "call-device", // ← Changed from "Call G7c Device"
              },
              {
                id: "step-2",
                title:
                  "Send message 'Do you need help?' to device and wait 2 minutes",
                action: "message-device",
                timer: 120,
              },
              {
                id: "step-3",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-4",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-5",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "fall-detection-protocol": {
            name: "Fall Detection Protocol",
            steps: [
              {
                id: "step-1",
                title: "Call device and validate need for assistance",
                action: "combined-device-user-call",
                subSteps: [
                  {
                    action: "call-device",
                    title: "Call G7c Device",
                  },
                  {
                    action: "call-user",
                    title: "If no answer, call user phone",
                  },
                ],
              },
              {
                id: "step-2",
                title: "Send message 'Do you need help?' and wait 2 minutes",
                action: "message-device",
                timer: 120,
              },
              {
                id: "step-3",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-4",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "sos-protocol": {
            name: "SOS Emergency Protocol",
            steps: [
              {
                id: "step-1",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-2",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
              {
                id: "step-3",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
            ],
          },
          "no-motion-protocol": {
            name: "No Motion Detection Protocol",
            steps: [
              {
                id: "step-1",
                title: "Send message 'Do you need help?' and wait 5 minutes",
                action: "message-device",
                timer: 300,
              },
              {
                id: "step-2",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-3",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-4",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "missed-check-in-protocol": {
            name: "Missed Check-in Protocol",
            steps: [
              {
                id: "step-1",
                title: "Send message 'Do you need help?' and wait 2 minutes",
                action: "message-device",
                timer: 120,
              },
              {
                id: "step-2",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-3",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
            ],
          },

          "gas-emergency-protocol-high": {
            name: "Gas Emergency Protocol (High Levels)",
            steps: [
              {
                id: "step-1",
                title:
                  "Send message 'Leave the area, understood?' to device and wait 5 minutes",
                action: "message-device",
                timer: 300,
              },
              {
                id: "step-2",
                title: "Call Device and Validate Need for Assistance",
                action: "call-device",
              },
              {
                id: "step-3",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-4",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-5",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "gas-emergency-protocol-normal": {
            name: "Gas Emergency Protocol (Normal Levels)",
            steps: [
              {
                id: "step-1",
                title:
                  "Send message 'Do you need help?' to device and wait 5 minutes",
                action: "message-device",
                timer: 300,
              },
              {
                id: "step-2",
                title: "Call Device and Validate Need for Assistance",
                action: "call-device",
              },
              {
                id: "step-3",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-4",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-5",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
        };

        static getProtocolConfig(alertType) {
          const alertConfig = AlertDataManager.alertTypesData[alertType];
          return this.protocolsData[alertConfig.protocolFile];
        }
      }

      // Device Connectivity System
      class DeviceConnectivity {
        static currentStatus = {
          online: true,
          lastCommunication: new Date(),
          battery: 85,
          signal: 70,
          connectionType: "Cellular",
        };

        static isDeviceOnline() {
          const info = this.currentStatus;
          if (!info) return false;

          const lastComm = new Date(info.lastCommunication);
          const now = new Date();
          const diffMinutes = (now - lastComm) / (1000 * 60);
          if (diffMinutes > 30) return false; // Last communication ≤ 30 minutes ago
          if (info.battery <= 10) return false; // Battery > 10%
          if (info.signal <= 10) return false; // Signal strength > 10%

          return true;
        }

        static updateConnectivityDisplay() {
          const panel = document.getElementById("connectivityPanel");
          const statusElement = document.getElementById("device-online-status");
          const lastCommElement = document.getElementById("last-comm-time");
          const batteryElement = document.getElementById("battery-level");
          const signalElement = document.getElementById("signal-strength");

          if (!this.currentStatus) {
            if (panel) panel.style.display = "none";
            return;
          } else {
            if (panel) panel.style.display = "";
          }

          const isOnline = this.isDeviceOnline();

          // Status badge
          if (statusElement) {
            if (isOnline) {
              statusElement.textContent = "🟢 Online";
              statusElement.className = "status-pill online";
            } else {
              statusElement.textContent = "🔴 Offline";
              statusElement.className = "status-pill offline";
            }
          }

          // Battery with color coding
          if (batteryElement) {
            batteryElement.textContent = this.currentStatus.battery + "%";
            if (this.currentStatus.battery > 50) {
              batteryElement.style.color = "#28a745"; // Green
            } else if (this.currentStatus.battery > 20) {
              batteryElement.style.color = "#ffc107"; // Yellow
            } else {
              batteryElement.style.color = "#dc3545"; // Red
            }
          }

          // Signal strength
          if (signalElement) {
            signalElement.textContent = this.currentStatus.signal + "%";
          }

          // Last communication
          if (lastCommElement) {
            const lastComm = new Date(this.currentStatus.lastCommunication);
            const now = new Date();
            const diffMinutes = Math.floor((now - lastComm) / 60000);

            const timeStr =
              lastComm.toLocaleTimeString("en-US", {
                hour12: false,
                timeZone: "America/Denver",
                hour: "2-digit",
                minute: "2-digit",
              }) + " MDT";

            let timeAgo = "";
            if (diffMinutes === 0) timeAgo = "(just now)";
            else if (diffMinutes === 1) timeAgo = "(1 minute ago)";
            else if (diffMinutes < 60) timeAgo = `(${diffMinutes} minutes ago)`;
            else {
              const hours = Math.floor(diffMinutes / 60);
              const mins = diffMinutes % 60;
              timeAgo = `(${hours}h${mins > 0 ? ` ${mins}m` : ""} ago)`;
            }

            lastCommElement.textContent = `${timeStr} ${timeAgo}`;
            lastCommElement.style.color =
              diffMinutes > 5 || !isOnline ? "#dc3545" : "";
            lastCommElement.style.fontWeight =
              diffMinutes > 5 || !isOnline ? "bold" : "";
          }
        }

        // Test Scenarios for Demo/Testing
        static setDeviceOnlineScenario() {
          this.currentStatus = {
            online: true,
            lastCommunication: new Date(Date.now() - 2 * 60 * 1000), // 2 min ago
            battery: 85,
            signal: 70,
            connectionType: "Cellular",
          };
          this.updateConnectivityDisplay();
        }

        static setDeviceOfflineScenario(reason = "battery") {
          const scenarios = {
            battery: {
              lastCommunication: new Date(Date.now() - 10 * 60 * 1000),
              battery: 0,
              signal: 60,
            },
            signal: {
              lastCommunication: new Date(Date.now() - 15 * 60 * 1000),
              battery: 80,
              signal: 0,
            },
            communication: {
              lastCommunication: new Date(Date.now() - 45 * 60 * 1000),
              battery: 80,
              signal: 60,
            },
          };

          this.currentStatus = {
            online: false,
            connectionType: "Cellular",
            ...scenarios[reason],
          };
          this.updateConnectivityDisplay();
        }
      }

      function getEmergencyContactsStepId() {
        try {
          const cfg = ProtocolFactory.getProtocolConfig(currentAlert?.id);
          if (!cfg || !Array.isArray(cfg.steps)) return "step-3"; // safe fallback

          const ecStep = cfg.steps.find(
            (s) => s.action === "call-emergency-contacts"
          );
          return ecStep ? ecStep.id : "step-3"; // legacy default if not found
        } catch (e) {
          console.warn("getEmergencyContactsStepId fallback:", e);
          return "step-3";
        }
      }

      function confirmOverride() {
        const overrideReasonSelect = document.getElementById("override-reason");
        const overrideReason = overrideReasonSelect.value;

        if (!overrideReason) {
          alert("Please select an override reason");
          return;
        }

        // Get the display text BEFORE clearing anything
        const overrideText =
          overrideReasonSelect.options[overrideReasonSelect.selectedIndex].text;

        const reasonSelect = document.getElementById("resolution-reason");
        let reason = reasonSelect ? reasonSelect.value : "";

        // If no resolution reason was selected, set a default one
        if (!reason) {
          reason = determineResolutionType(currentAlert);
          if (reasonSelect) {
            reasonSelect.value = reason;
          }
        }

        // Close the override modal
        document.getElementById("modalOverlay").style.display = "none";
        document.getElementById("overrideModal").style.display = "none";
        document.getElementById("override-reason").value = ""; // This clears it
        document.getElementById("confirmOverrideBtn").disabled = true;

        lockUIForResolution();

        // Pass the display text, not the value
        completeResolution(reason, overrideText); // Pass the text, not the value
      }

      function startGlobalTimer(
        stepId,
        label,
        contactName = "",
        durationInSeconds = 1800
      ) {
        // Store the ORIGINAL step ID for resolution tracking
        let originalStepId = stepId;

        // If this is an EC callback timer, preserve the original step
        if (stepId === "ec-callback") {
          // Try to get the original step from activeTimerData before overwriting
          originalStepId = activeTimerData?.originalStepId || "step-2";
        }

        // ✅ SET activeTimerData with originalStepId tracking
        activeTimerData = {
          stepId,
          label,
          contactName,
          durationInSeconds,
          originalStepId: originalStepId, // Track which step started this timer chain
        };

        const display = document.getElementById("timerDisplay");
        const info = document.getElementById("timerInfo");
        const globalTimer = document.getElementById("globalTimer");
        const startTime = new Date();

        // Set global end time for state tracking
        globalTimerEndTime = new Date(
          startTime.getTime() + durationInSeconds * 1000
        );

        // Update timer metadata
        const timerStart = document.getElementById("timerStart");
        const timerEnd = document.getElementById("timerEnd");
        if (timerStart)
          timerStart.textContent =
            startTime.toLocaleTimeString("en-US", {
              hour12: false,
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            }) + " hrs.";
        if (timerEnd)
          timerEnd.textContent =
            globalTimerEndTime.toLocaleTimeString("en-US", {
              hour12: false,
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            }) + " hrs.";

        // Update header
        info.innerHTML = contactName
          ? `<strong>${label}</strong><br>${contactName}`
          : `<strong>${label}</strong>`;

        // ✅ Build dropdown with ORIGINAL options only
        const controls = document.querySelector(".timer-controls");
        controls.innerHTML = `
  <select data-cy="global-cancel-dropdown" onchange="handleGlobalTimerCancellation(this.value)"
          class="btn btn-secondary"
          style="padding: 8px 16px; font-size: 0.8em; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: background 0.2s; width: 100%;"
          aria-label="Cancel response timer">
      <option value="">Cancel Timer</option>
      <option value="user-callback">User called in and confirmed they are okay</option>
      <option value="ec-callback">Emergency contact called in and confirmed user is okay</option>
      <option value="ec-callback-30min">Emergency contact called in - Will contact user and call back (30 min timer)</option>
      <option value="device-offline">Device went offline</option>
      <option value="custom">Type reason</option>
  </select>
`;

        // ✅ Start visual state
        globalTimer.classList.remove("timer-inactive");
        globalTimer.classList.add("timer-active");
        globalTimer.style.opacity = "1";
        globalTimer.style.display = "block";

        // Scroll timer into view when started
        globalTimer.scrollIntoView({ behavior: "smooth", block: "center" });

        // Log proper Step 2 message or timer message
        if (stepId === "step-2" && durationInSeconds === 120) {
          // Only for initial 2-minute timer
          addLogEntry(
            'Step 2: Sent "Do you need help?" to device. Waiting 2 minutes for reply.',
            "step"
          );
        }

        function updateDisplay() {
          const now = new Date();
          const remaining = Math.max(
            0,
            Math.floor((globalTimerEndTime - now) / 1000)
          );
          const mins = String(Math.floor(remaining / 60)).padStart(2, "0");
          const secs = String(remaining % 60).padStart(2, "0");
          display.textContent = `${mins}:${secs}`;

          if (remaining <= 0) {
            clearInterval(globalTimerInterval);
            globalTimerInterval = null;
            globalTimerEndTime = null;

            // Reset to inactive state like cancelGlobalTimer
            display.textContent = "--:--";
            info.innerHTML = "<strong>No active timer</strong>";

            const timer = document.getElementById("globalTimer");
            if (timer) {
              timer.classList.remove("timer-active");
              timer.classList.add("timer-inactive");
            }

            // Disable cancel button
            const cancelBtn = document.getElementById("cancelTimerBtn");
            if (cancelBtn) {
              cancelBtn.disabled = true;
            }

            // 🔊 Optional audio
            try {
              const audioCtx = new (window.AudioContext ||
                window.webkitAudioContext)();
              const osc = audioCtx.createOscillator();
              const gain = audioCtx.createGain();
              osc.type = "sine";
              osc.frequency.setValueAtTime(800, audioCtx.currentTime);
              gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
              osc.connect(gain);
              gain.connect(audioCtx.destination);
              osc.start();
              osc.stop(audioCtx.currentTime + 0.5);
            } catch (e) {
              console.warn("🔇 Audio not supported.");
            }

            // 🚨 Visual alert - Tab flashing (if function exists)
            if (typeof startTabFlashing === "function") {
              startTabFlashing("🚨 TIMER EXPIRED");
            }

            // Clear dropdown after expiry
            const timerControls = document.querySelector(".timer-controls");
            if (timerControls) {
              timerControls.innerHTML = "";
            }

            if (activeTimerData && activeTimerData.stepId) {
              // Handle timer expiration based on type
              if (activeTimerData.stepId === "ec-callback") {
                // EC callback timer expired
                addLogEntry(
                  `⏰ Emergency contact callback timer expired. Proceeding to next step.`,
                  "step"
                );
                // Check if this step has dispatch action (dispatch steps don't have next steps)
                const protocolConfig = ProtocolFactory.getProtocolConfig(
                  currentAlert.id
                );
                const stepConfig = protocolConfig.steps.find(
                  (step) => step.id === activeTimerData.originalStepId
                );

                if (stepConfig && stepConfig.action !== "dispatch") {
                  enableNextStep(activeTimerData.originalStepId);
                }
              } else if (activeTimerData.stepId.startsWith("step-")) {
                // Regular step timer expired
                const stepNum = activeTimerData.stepId.replace("step-", "");
                addLogEntry(
                  `Step ${stepNum}: Timer expired. Proceeding to next step.`,
                  "step"
                );
                markStepCompleted(activeTimerData.stepId);

                // Check if this step has dispatch action (dispatch steps don't have next steps)
                const protocolConfig = ProtocolFactory.getProtocolConfig(
                  currentAlert.id
                );
                const stepConfig = protocolConfig.steps.find(
                  (step) => step.id === activeTimerData.stepId
                );

                if (stepConfig && stepConfig.action !== "dispatch") {
                  enableNextStep(activeTimerData.stepId);
                }
              }
            } else if (activeTimerData) {
              // Non-step timers - FIXED: Use description instead of label
              const label =
                activeTimerData.description ||
                activeTimerData.contactName ||
                "Unknown Timer";
              const expiredMessage = `⏰ TIMER EXPIRED: ${label}`;
              addLogEntry(expiredMessage, "timer");
            }

            // Optional: Add gas reading log for gas alerts
            if (currentAlert && isGasAlert(currentAlert)) {
              const gasReading = getCurrentGasReading();
              addLogEntry(
                `Gas level: ${gasReading.status}\nGas Reading: ${gasReading.type}: ${gasReading.value}${gasReading.unit}`,
                "timer"
              );
            }

            // Clear activeTimerData to prevent further issues
            activeTimerData = null;
          }
        }
        updateDisplay(); // Initial display update
        globalTimerInterval = setInterval(updateDisplay, 1000); // Start the timer interval
      }

      function handleGlobalTimerCancellation(reason) {
        if (!reason) return;

        console.log("Timer cancellation selected:", reason);

        // Stop the timer
        if (globalTimerInterval) {
          clearInterval(globalTimerInterval);
          globalTimerInterval = null;
          globalTimerEndTime = null;
        }

        // Get current step info BEFORE clearing activeTimerData
        let currentStepId = activeTimerData?.stepId;
        let originalStepId = activeTimerData?.originalStepId;

        // Handle EC callback special case
        if (currentStepId === "ec-callback") {
          currentStepId = originalStepId || "step-2";
          console.log("Adjusted currentStepId for EC callback:", currentStepId);
        }

        // Handle different cancellation reasons
        if (reason === "user-callback") {
          let logMessage =
            "User called in and confirmed they are okay. Resolving alert.";

          // Add gas info for gas alerts
          if (currentAlert && isGasAlert(currentAlert)) {
            const gasReading = getCurrentGasReading();
            logMessage +=
              "<br><br>" +
              "Gas Type: " +
              gasReading.type +
              "<br>" +
              "Gas Level: " +
              gasReading.status +
              "<br>" +
              "📊 Gas Reading: " +
              gasReading.value +
              gasReading.unit;
          }

          addLogEntry(logMessage, "step");

          // Mark the originating step as completed before triggering resolution
          if (currentStepId && canStepTriggerResolution(currentStepId)) {
            console.log("Marking step as completed:", currentStepId);
            markStepCompleted(currentStepId);

            // Also mark main step as completed if this is a sub-step
            if (
              currentStepId.includes("-") &&
              currentStepId.split("-").length === 3
            ) {
              const mainStepId = currentStepId.substring(
                0,
                currentStepId.lastIndexOf("-")
              );
              console.log(`Also marking main ${mainStepId} as completed`);
              markStepCompleted(mainStepId);
            }

            console.log("Step marked as completed, now triggering resolution");
          }

          // Use unified resolution flow
          console.log(
            "Calling triggerResolutionFlow with stepId:",
            currentStepId
          );
          if (currentStepId) {
            triggerResolutionFlow(currentStepId, "EC confirmed user okay");
          } else {
            console.error("NO STEP ID - Resolution flow failed!");
          }
        } else if (reason === "ec-callback") {
          let logMessage =
            "Emergency contact called in and confirmed user is okay. Resolving alert.";

          // Add gas info for gas alerts
          if (currentAlert && isGasAlert(currentAlert)) {
            const gasReading = getCurrentGasReading();
            logMessage +=
              "<br><br>" +
              "Gas Type: " +
              gasReading.type +
              "<br>" +
              "Gas Level: " +
              gasReading.status +
              "<br>" +
              "📊 Gas Reading: " +
              gasReading.value +
              gasReading.unit;
          }

          addLogEntry(logMessage, "step");

          // Use unified resolution flow
          console.log(
            "Calling triggerResolutionFlow with stepId:",
            currentStepId
          );
          if (currentStepId) {
            triggerResolutionFlow(currentStepId, "EC confirmed user okay");
          } else {
            console.error("NO STEP ID - Resolution flow failed!");
          }
        } else if (reason === "ec-callback-30min") {
          addLogEntry(
            "Emergency contact called in, will check on user and call back within 30 minutes.",
            "step"
          );

          // Only start new timer if no dispatch is active
          if (!dispatchMade || !globalTimerInterval) {
            if (currentStepId) {
              startGlobalTimer(
                "ec-callback",
                "EC Callback",
                "Emergency Contact",
                1800
              );
            }

            // Update timer info display
            const info = document.getElementById("timerInfo");
            if (info) {
              info.innerHTML = "<strong>Waiting for EC callback</strong>";
            }
          }
          // If dispatch is active, do nothing (keep timer running)

          // Don't show "Timer cancelled" - return early
          return;
        } else if (reason === "device-offline") {
          addLogEntry("Device went offline", "step");
          if (currentStepId) {
            markStepCompleted(currentStepId);
            enableNextStep(currentStepId);
          }
        } else if (reason === "custom") {
          const customReason = prompt("Enter cancellation reason:");
          if (customReason) {
            addLogEntry("Timer cancelled: " + customReason, "step");
            if (currentStepId) {
              markStepCompleted(currentStepId);
              enableNextStep(currentStepId);
            }
          }
        }

        // Reset timer display
        const display = document.getElementById("timerDisplay");
        const info = document.getElementById("timerInfo");
        const globalTimer = document.getElementById("globalTimer");

        if (display) display.textContent = "--:--";
        if (info) info.innerHTML = "<strong>Timer cancelled</strong>";
        if (globalTimer) {
          globalTimer.classList.remove("timer-active");
          globalTimer.classList.add("timer-inactive");
        }

        // Reset the dropdown
        const dropdown = document.querySelector(
          '[data-cy="global-cancel-dropdown"]'
        );
        if (dropdown) dropdown.value = "";

        // Clear activeTimerData ONLY if not starting a new timer
        if (reason !== "ec-callback-30min") {
          activeTimerData = null;
        }
      }

      function cancelGlobalTimer() {
        if (!globalTimerInterval) return;

        clearInterval(globalTimerInterval);
        globalTimerInterval = null;
        globalTimerEndTime = null;

        const display = document.getElementById("timerDisplay");
        const info = document.getElementById("timerInfo");
        const timer = document.getElementById("globalTimer");
        const cancelBtn = document.getElementById("cancelTimerBtn");

        display.textContent = "--:--";
        info.innerHTML = "<strong>No active timer</strong>";
        timer.classList.remove("timer-active");
        timer.classList.add("timer-inactive");

        // Disable the cancel button after cancelling
        if (cancelBtn) {
          cancelBtn.disabled = true;
        }

        addLogEntry("Timer cancelled", "timer");

        // ===== ADD THESE LINES TO STOP SOUNDS =====
        // Stop tab flashing
        if (window.tabFlashInterval) {
          clearInterval(window.tabFlashInterval);
          window.tabFlashInterval = null;
          document.title =
            window.originalTitle ||
            "Enhanced Blackline Live - Alert Management";
        }

        // Stop beeping sounds
        if (window.beepTimeouts && Array.isArray(window.beepTimeouts)) {
          window.beepTimeouts.forEach((timeout) => clearTimeout(timeout));
          window.beepTimeouts = [];
        }
        // ===== END SOUND STOPPING =====
      }

      // ═══════════════════════════════════════════════════════════════
      // 🚨 PROTOCOL CONTROL FUNCTIONS
      // ═══════════════════════════════════════════════════════════════

      function initializeAlert(alertConfig, userConfig) {
        protocolState = {
          completedSteps: [],
          currentStep: 1,
          dispatchMade: false,
          alertResolved: false,
          deviceMessageReceived: false,
          currentProtocol: alertConfig.protocolFile,
        };
      }

      function getStepTimer(stepId) {
        if (!currentAlert) return null;

        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const stepConfig = protocolConfig.steps.find(
          (step) => step.id === stepId
        );

        return stepConfig ? stepConfig.timer : null;
      }

      function startStep(stepId) {
        console.log("startStep called with:", stepId);

        // ── Idempotency guard setup ─────────────────────────────────────────
        if (!window.protocolState) window.protocolState = {};
        if (!protocolState.startedSteps) protocolState.startedSteps = new Set();

        // Small helper: (re)enable controls for this step's outcome section
        function enableOutcomeControls(id) {
          // dropdown
          const dropdown = document.getElementById(id + "-select");
          if (dropdown) {
            dropdown.disabled = false;
            dropdown.style.pointerEvents = "auto";
          }
          // textarea
          const note = document.getElementById(id + "-note");
          if (note) {
            note.disabled = false;
            note.style.pointerEvents = "auto";
          }
          // Post Note button (keep your legacy inline onclick selector)
          const postBtn = document.querySelector(
            `#${id} button[onclick*="postNote"]`
          );
          if (postBtn) {
            postBtn.disabled = false;
            postBtn.style.pointerEvents = "auto";
          }
        }

        // Always mark the clicked step/sub-step active (helps CSS show outcome)
        const stepEl = document.getElementById(stepId);
        if (stepEl && !stepEl.classList.contains("active")) {
          stepEl.classList.add("active");
        }

        // Resolve action from config
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const currentStep = protocolConfig.steps.find((s) => s.id === stepId);
        const action = currentStep ? currentStep.action : undefined;
        const isMessageDevice =
          action === "message-device" || (!action && stepId === "step-2"); // back-compat

        // If already started, just ensure outcome UI is shown & enabled (for non message-device)
        if (protocolState.startedSteps.has(stepId)) {
          if (!isMessageDevice) {
            const outcomeSection = document.getElementById(stepId + "-outcome");
            if (outcomeSection && outcomeSection.style.display !== "block") {
              outcomeSection.style.display = "block";
            }
            // 🔧 ensure inputs are usable even on re-entry
            enableOutcomeControls(stepId);
          }
          return;
        }
        protocolState.startedSteps.add(stepId);

        // ── Show/hide outcome section based on action ───────────────────────
        const outcomeSection = document.getElementById(stepId + "-outcome");
        if (isMessageDevice) {
          if (outcomeSection) outcomeSection.style.display = "none";
        } else {
          if (outcomeSection && outcomeSection.style.display !== "block") {
            outcomeSection.style.display = "block";
          }
          // 🔧 first-run: enable controls
          enableOutcomeControls(stepId);
        }

        // ── Start timer for message-device steps ────────────────────────────
        if (isMessageDevice) {
          const timerDuration =
            (typeof getStepTimer === "function" && getStepTimer(stepId)) ||
            (typeof getStepTimer === "function" && getStepTimer("step-2")) ||
            0;

          const alreadyRunningThisTimer =
            typeof window.activeTimerData === "object" &&
            window.activeTimerData &&
            window.activeTimerData.stepId === stepId &&
            window.activeTimerData.isRunning;

          if (timerDuration && !alreadyRunningThisTimer) {
            console.log("Timer duration found:", timerDuration);
            console.log("About to call startGlobalTimer");
            startGlobalTimer(
              stepId,
              "Waiting for device reply",
              "",
              timerDuration
            );
            console.log("startGlobalTimer call completed");

            // Add status badge logic
            const statusBadge = document.getElementById(stepId + "-status");
            if (statusBadge) {
              statusBadge.textContent = "Waiting";
              statusBadge.className = "status-badge waiting";
              console.log("Step status set to Waiting");
            }
          } else {
            if (!timerDuration)
              console.log(`No timer duration found for ${stepId}`);
            if (alreadyRunningThisTimer)
              console.log(
                `Global timer for ${stepId} already running; skipping restart.`
              );
          }
        }
      }

      function validatePostButton(stepId) {
        const stepEl = document.getElementById(stepId);
        if (!stepEl) return;

        // Prefer the actual Post Note button inside this step
        const button =
          stepEl.querySelector('button[onclick*="postNote"]') ||
          stepEl.querySelector(
            'button[class*="btn"]:not([onclick*="startStep"])'
          );
        if (!button) return;

        // Prefer the step-specific note box; fall back to any textarea inside the step
        let note =
          document.getElementById(stepId + "-note") ||
          stepEl.querySelector("textarea");
        const hasText = !!(note && note.value.trim().length > 0);

        let enable = false;

        // Check if this step contains dispatch action (action-based detection)
        const hasDispatchElements =
          stepEl.querySelector("#dispatch-decision") !== null;

        if (hasDispatchElements) {
          const decision = (
            document.getElementById("dispatch-decision")?.value || ""
          ).toLowerCase();
          const skip = (
            document.getElementById("skip-reason")?.value || ""
          ).toLowerCase();

          if (decision === "no") {
            // Enable if a skip reason is selected OR the note has content
            enable = !!skip || hasText;
          } else if (decision === "yes") {
            // Keep simple: allow posting notes when dispatching
            // (tighten here if you later require a selected service)
            enable = true;
          } else {
            // Unknown/blank decision → fall back to text requirement
            enable = hasText;
          }
        } else {
          // Default rule for all other steps: require note text
          enable = hasText;
        }

        // Apply state + visual style (preserve your existing classes)
        button.disabled = !enable;
        if (enable) {
          button.classList.remove("btn-secondary");
          button.classList.add("btn-success");
        } else {
          button.classList.remove("btn-success");
          button.classList.add("btn-secondary");
        }
      }

      // UNIVERSAL HELPER FUNCTIONS (add these at the top of the function)
      function handleCallDeviceOutcome(
        selectedValue,
        currentUser,
        currentAlert
      ) {
        let noteText = "";
        let shouldScrollToResolution = false;

        if (selectedValue === "confirmed-ok") {
          noteText = `Spoke with ${
            currentUser?.name || "user"
          }. Confirmed they are okay. Resolving alert.`;
          shouldScrollToResolution = true;
        } else if (selectedValue === "user-callback") {
          noteText = `User called in. Confirmed they are okay.`;
          shouldScrollToResolution = true;
        } else if (selectedValue === "no-answer") {
          noteText = `Called device. No answer`;
        } else if (selectedValue === "unable-to-call") {
          noteText = `Unable to call, device offline`;
        }

        return { noteText, shouldScrollToResolution };
      }

      function handleCallUserOutcome(selectedValue, currentUser, currentAlert) {
        let noteText = "";
        let shouldScrollToResolution = false;

        if (selectedValue === "confirmed-ok") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }. Confirmed they are okay. Resolving alert.`.trim();
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback") {
          noteText = `Emergency contact called in and confirmed ${
            currentUser?.name || "user"
          } is okay. Resolving alert.`; // ✅ ADDED PERIOD
          shouldScrollToResolution = true;
        } else if (selectedValue === "user-callback") {
          noteText = `User called in. Confirmed they are okay. Resolving alert.`; // ✅ ADDED PERIOD
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback-30min") {
          noteText = `Emergency contact called in, will check on user and call back within 30 minutes`;
        } else if (selectedValue === "no-answer-voicemail") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }, no answer. Left voicemail`.trim();
        } else if (selectedValue === "no-answer-already-left") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }, no answer. Voicemail had already been left`.trim();
        } else if (selectedValue === "no-answer-mailbox-full") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }, no answer. Unable to leave voicemail, mailbox full`.trim();
        } else if (selectedValue === "no-answer-unable-voicemail") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }, no answer. Unable to leave voicemail`.trim();
        } else if (selectedValue === "no-answer-mailbox-not-setup") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }, no answer. Unable to leave voicemail, mailbox not set up yet`.trim();
        } else if (selectedValue === "no-phone-number") {
          noteText = `Unable to call, user has no phone number assigned`;
        } else if (selectedValue === "number-disconnected") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }. Number has been changed, disconnected or no longer in service`.trim();
        } else if (selectedValue === "unable-to-connect") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }. Unable to connect`.trim();
        }

        return { noteText, shouldScrollToResolution };
      }

      function handleCallEmergencyContactsOutcome(
        selectedValue,
        currentUser,
        currentAlert,
        ecIndex = 0
      ) {
        let noteText = "";
        let shouldScrollToResolution = false;

        // Get the specific emergency contact
        const userKey = currentAlert?.user;
        const contact =
          userKey &&
          AlertDataManager.usersData[userKey]?.emergencyContacts?.length >
            ecIndex
            ? AlertDataManager.usersData[userKey].emergencyContacts[ecIndex]
            : null;

        const contactName = contact ? contact.name : "Emergency Contact";
        const contactPhone = contact ? contact.phone : "";

        if (selectedValue === "confirmed-ok") {
          noteText = `Called ${contactName} at ${contactPhone}. Confirmed ${
            currentUser?.name || "user"
          } is okay`;
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback") {
          noteText = "Emergency contact called in and confirmed user is okay";
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback-30min-outbound") {
          noteText = `Called ${contactName} at ${contactPhone}. EC will check on user and call back within 30 minutes`;
          shouldScrollToResolution = false;
        } else if (selectedValue === "no-answer-voicemail") {
          noteText = `Called ${contactName} at ${contactPhone}. No answer, left voicemail`;
        } else if (selectedValue === "no-answer-already-left") {
          noteText = `Called ${contactName} at ${contactPhone}. No answer, voicemail already left`;
        } else if (selectedValue === "no-answer-unable") {
          noteText = `Called ${contactName} at ${contactPhone}. No answer, unable to leave voicemail`;
        } else if (selectedValue === "no-answer-box-full") {
          noteText = `Called ${contactName} at ${contactPhone}. No answer, voicemail box full`;
        } else if (selectedValue === "no-answer-not-set") {
          noteText = `Called ${contactName} at ${contactPhone}. No answer, voicemail not set up`;
        } else if (selectedValue === "wrong-number") {
          noteText = `Called ${contactName} at ${contactPhone}. Wrong number`;
        } else if (selectedValue === "unable-to-connect") {
          noteText = `Called ${contactName} at ${contactPhone}. Unable to connect`;
        } else if (selectedValue === "number-invalid") {
          noteText = `Called ${contactName} at ${contactPhone}. Number invalid, changed, or out of service`;
        }

        return { noteText, shouldScrollToResolution };
      }

      function handleDispatchOutcome(selectedValue, currentUser, currentAlert) {
        let noteText = "";
        let shouldScrollToResolution = false;

        if (selectedValue === "user-callback") {
          noteText = `User called in. Confirmed they are okay. Resolving alert`;
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback") {
          noteText = `Emergency contact called in and confirmed user is okay. Resolving alert`;
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback-cancel-dispatch") {
          noteText = `Emergency contact called in, advised to cancel dispatch. They confirmed user is okay / will check on user. Resolving alert`;
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback-cancel-dispatch-30min") {
          noteText = `Emergency contact called in, advised to cancel dispatch. They will check on user and call back within 30 minutes`;
        } else if (selectedValue === "ec-callback-30min") {
          noteText = `Emergency contact called in, will check on user and call back within 30 minutes`;
        }

        return { noteText, shouldScrollToResolution };
      }

      function autoPopulateFromDropdown(stepId) {
        const select = document.getElementById(stepId + "-select");
        const note = document.getElementById(stepId + "-note");

        // Do not require currentUser just to populate generic notes
        if (!select || !note) return;

        const selectedValue = select.value;
        console.log(
          "DEBUG: selectedValue =",
          selectedValue,
          "for stepId =",
          stepId
        );
        if (!selectedValue) return;

        let noteText = "";
        let shouldScrollToResolution = false;

        // Get current step action for action-based handling
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        if (!protocolConfig) {
          console.warn("No protocol config found for alert:", currentAlert.id);
          return;
        }

        // Handle sub-step IDs (step-1-1, step-1-2, etc.)
        let actualStepId = stepId;
        let subStepAction = null;

        if (stepId.includes("-") && stepId.split("-").length === 3) {
          const parts = stepId.split("-"); // ["step","1","1"]
          const mainStepId = parts[0] + "-" + parts[1]; // "step-1"
          const subStepIndex = parseInt(parts[2], 10) - 1; // 0 for first

          const mainStep = protocolConfig.steps.find(
            (s) => s.id === mainStepId
          );
          if (
            mainStep &&
            Array.isArray(mainStep.subSteps) &&
            mainStep.subSteps[subStepIndex]
          ) {
            subStepAction = mainStep.subSteps[subStepIndex].action;
            actualStepId = mainStepId; // use main step for user data if needed
          }
        }

        const currentStep =
          protocolConfig.steps.find((s) => s.id === stepId) ||
          protocolConfig.steps.find((s) => s.id === actualStepId);
        const stepAction = subStepAction || currentStep?.action;

        console.log("DEBUG: stepId =", stepId, "stepAction =", stepAction);

        // ═══════════════════════════════════════════════════════════
        // ACTION-BASED LOGIC (Primary approach)
        // ═══════════════════════════════════════════════════════════
        if (stepAction === "call-device") {
          const result = handleCallDeviceOutcome(
            selectedValue,
            currentUser,
            currentAlert
          );
          noteText = result.noteText;
          shouldScrollToResolution = result.shouldScrollToResolution;
        } else if (stepAction === "message-device") {
          const result = handleMessageDeviceOutcome(
            selectedValue,
            currentUser,
            currentAlert
          );
          noteText = result.noteText;
          shouldScrollToResolution = result.shouldScrollToResolution;
        } else if (stepAction === "call-user") {
          const result = handleCallUserOutcome(
            selectedValue,
            currentUser,
            currentAlert
          );
          noteText = result.noteText;
          shouldScrollToResolution = result.shouldScrollToResolution;
        } else if (
          stepAction === "call-emergency-contacts" ||
          stepId === getEmergencyContactsStepId() ||
          stepId.startsWith(getEmergencyContactsStepId() + "-")
        ) {
          // Extract EC index from stepId (e.g., "step-4-1" -> ecIndex = 0)
          let ecIndex = 0;
          if (stepId.includes("-")) {
            const parts = stepId.split("-");
            if (parts.length >= 3) {
              ecIndex = parseInt(parts[2]) - 1; // Convert 1-based to 0-based index
            }
          }

          const result = handleCallEmergencyContactsOutcome(
            selectedValue,
            currentUser,
            currentAlert,
            ecIndex
          );
          noteText = result.noteText;
          shouldScrollToResolution = result.shouldScrollToResolution;
        } else if (stepAction === "dispatch") {
          const result = handleDispatchOutcome(
            selectedValue,
            currentUser,
            currentAlert
          );
          noteText = result.noteText;
          shouldScrollToResolution = result.shouldScrollToResolution;
        }

        // ═══════════════════════════════════════════════════════════
        // STEP-BASED FALLBACKS (For protocols without proper actions)
        // ═══════════════════════════════════════════════════════════
        else if (stepId === "step-1" || actualStepId === "step-1") {
          if (selectedValue === "confirmed-ok") {
            noteText = `Spoke with ${
              currentUser?.name || "user"
            }. Confirmed they are okay`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "user-callback") {
            noteText = `User called in. Confirmed they are okay`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "no-answer") {
            noteText = `Called device. No answer`;
          } else if (selectedValue === "unable-to-call") {
            noteText = `Unable to call, device offline`;
          }
        } else if (stepId === "step-2" || actualStepId === "step-2") {
          if (selectedValue === "unable-to-send") {
            noteText = `Unable to send text message, device offline`;
          } else if (selectedValue === "no-response") {
            noteText = `Sent message "Do you need help?" to device. No response received`;
          } else if (selectedValue === "device-no") {
            noteText = `Received message "No" from device. User confirmed okay`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "issue-resolved") {
            noteText = `Received message "Issue resolved" from device. User confirmed okay`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "false-alarm") {
            noteText = `Received message "False alarm" from device. User confirmed okay`;
            shouldScrollToResolution = true;
          }
        } else if (stepId === "step-3" || actualStepId === "step-3") {
          if (selectedValue === "confirmed-ok") {
            noteText = `Called ${currentUser?.name || "user"} at ${
              currentUser?.mobile || ""
            }. Confirmed they are OK`.trim();
            shouldScrollToResolution = true;
          } else if (selectedValue === "ec-callback") {
            noteText = `Emergency contact called in and confirmed ${
              currentUser?.name || "user"
            } is okay`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "user-callback") {
            noteText = `User called in. Confirmed they are okay`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "ec-callback-30min") {
            noteText = `Emergency contact called in, will check on user and call back within 30 minutes`;
          } else if (selectedValue === "no-answer-voicemail") {
            noteText = `Called ${currentUser?.name || "user"} at ${
              currentUser?.mobile || ""
            }, no answer. Left voicemail`.trim();
          } else if (selectedValue === "no-answer-already-left") {
            noteText = `Called ${currentUser?.name || "user"} at ${
              currentUser?.mobile || ""
            }, no answer. Voicemail had already been left`.trim();
          } else if (selectedValue === "no-answer-mailbox-full") {
            noteText = `Called ${currentUser?.name || "user"} at ${
              currentUser?.mobile || ""
            }, no answer. Unable to leave voicemail, mailbox full`.trim();
          } else if (selectedValue === "no-answer-unable-voicemail") {
            noteText = `Called ${currentUser?.name || "user"} at ${
              currentUser?.mobile || ""
            }, no answer. Unable to leave voicemail`.trim();
          } else if (selectedValue === "no-answer-mailbox-not-setup") {
            noteText = `Called ${currentUser?.name || "user"} at ${
              currentUser?.mobile || ""
            }, no answer. Unable to leave voicemail, mailbox not set up yet`.trim();
          } else if (selectedValue === "no-phone-number") {
            noteText = `Unable to call, user has no phone number assigned`;
          } else if (selectedValue === "number-disconnected") {
            noteText = `Number has been changed, disconnected or no longer in service`;
          } else if (selectedValue === "unable-to-connect") {
            noteText = `Unable to connect`;
          }
        }

        // ═══════════════════════════════════════════════════════════
        // FINAL FALLBACK: Use dropdown label if no noteText generated
        // ═══════════════════════════════════════════════════════════
        if (!noteText) {
          const label =
            select.options[select.selectedIndex]?.text || selectedValue;
          noteText = label;
          console.warn(
            "Using fallback noteText for stepId:",
            stepId,
            "action:",
            stepAction,
            "noteText:",
            noteText
          );
        }

        // ═══════════════════════════════════════════════════════════
        // GAS ALERT ENHANCEMENTS (Add gas data for resolving outcomes)
        // ═══════════════════════════════════════════════════════════
        console.log("DEBUG GAS CHECK:");
        console.log("- isGasAlert:", window.isGasAlert?.(currentAlert));
        console.log("- noteText:", noteText);
        console.log(
          "- confirmed regex test:",
          /confirmed.*okay/i.test(noteText) ||
            /confirmed user is okay/i.test(noteText)
        );
        console.log("- Gas Type test:", !/Gas Type:\s/i.test(noteText));

        if (
          window.isGasAlert?.(currentAlert) &&
          (/confirmed.*okay/i.test(noteText) ||
            /confirmed user is okay/i.test(noteText)) &&
          !/Gas Type:\s/i.test(noteText)
        ) {
          console.log("DEBUG GAS: Gas section triggered!");

          const gasBlockRaw =
            typeof getGasSnapshotFromPanel === "function"
              ? getGasSnapshotFromPanel()
              : "";

          console.log("DEBUG GAS: gasBlockRaw =", gasBlockRaw);

          if (gasBlockRaw) {
            const now = new Date();
            const ts =
              typeof FORMATTERS?.timestampMST === "function"
                ? FORMATTERS.timestampMST(now)
                : new Intl.DateTimeFormat("en-US", {
                    timeZone: "America/Denver",
                    year: "numeric",
                    month: "2-digit",
                    day: "2-digit",
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit",
                    hour12: false,
                  }).format(now) + " MDT";

            const gasBlockWithTs = gasBlockRaw.replace(
              /(Gas Reading:\s*[^\n]+)/i,
              `$1 (${ts})`
            );

            // Check actual gas levels instead of hardcoding "back to normal"
            const gasStillHigh =
              typeof isAnyGasDangerousNow === "function"
                ? isAnyGasDangerousNow()
                : !isGasCurrentlyNormalized();

            if (gasStillHigh) {
              // Gas is still HIGH - add warning instead
              const warningText = "⚠️ Gas levels still HIGH.";
              noteText += `\n\n${warningText}\n\n${gasBlockWithTs}`;
            } else {
              // Gas is actually normal - use the original logic
              const alreadyResolving = /confirmed they are okay/i.test(
                noteText
              );
              const preface = alreadyResolving
                ? "Gas readings back to normal."
                : "Gas readings back to normal. Resolving alert.";
              noteText += `\n\n${preface}\n\n${gasBlockWithTs}`;
            }
          } else {
            console.log("DEBUG GAS: No gasBlockRaw data!");
          }
        }

        // ═══════════════════════════════════════════════════════════
        // SET NOTE VALUE AND VALIDATE
        // ═══════════════════════════════════════════════════════════
        note.value = noteText;
        console.log("Setting noteText:", noteText);

        // Re-run validator so the Post Note button enables
        if (typeof validatePostButton === "function") {
          validatePostButton(stepId);
        }

        // Optional: scroll to resolution if we set a resolving outcome
        if (
          shouldScrollToResolution &&
          typeof triggerResolutionFlow === "function"
        ) {
          // leave actual resolution to postNote; this is just UX affordance
        }
      }

      window.isGasAlert =
        window.isGasAlert ||
        function (alert) {
          if (!alert) return false;
          const id = String(alert.id || "");
          const type = String(alert.gasType || "");
          const GAS_KEYS = /(h2s|h₂s|co|o2|o₂|lel)\b/i;

          return (
            /(^gas-|(^|[^a-z])gas([^a-z]|$))/i.test(id) || // ids starting with/containing "gas"
            GAS_KEYS.test(id) ||
            GAS_KEYS.test(type)
          );
        };

      // Keep this as-is unless you introduce a distinct sink or styling for gas logs
      window.addGasLogEntry =
        window.addGasLogEntry ||
        function (msg, stepId) {
          addLogEntry(msg, "step"); // same sink as non-gas for now
        };

      // Standard cycle message used everywhere (no more "until contact made")
      const CYCLE_LINE =
        "🔄 Repeating STEPS 1, 2, 3 & 4 until someone is reached.";

      // Status helpers for gas
      function _gasStatus(id) {
        return (document.getElementById(id)?.textContent || "").toUpperCase();
      }
      function isGasCurrentlyNormalized() {
        const dangerO2 = /ENRICHED|DEPLETED/.test(_gasStatus("o2-status"));
        const dangerOthers =
          /\bHIGH\b/.test(_gasStatus("h2s-status")) ||
          /\bHIGH\b/.test(_gasStatus("co-status")) ||
          /\bHIGH\b/.test(_gasStatus("lel-status"));
        return !(dangerO2 || dangerOthers);
      }
      function buildGasSnapshotWithTs() {
        try {
          let block =
            typeof getGasSnapshotFromPanel === "function"
              ? getGasSnapshotFromPanel()
              : "";
          if (!block) return "";
          const now = new Date();
          const ts =
            typeof FORMATTERS?.timestampMST === "function"
              ? FORMATTERS.timestampMST(now)
              : new Intl.DateTimeFormat("en-US", {
                  timeZone: "America/Denver",
                  year: "numeric",
                  month: "2-digit",
                  day: "2-digit",
                  hour: "2-digit",
                  minute: "2-digit",
                  second: "2-digit",
                  hour12: false,
                }).format(now) + " MDT";
          return block.replace(/(Gas Reading:\s*[^\n]+)/i, `$1 (${ts})`);
        } catch {
          return "";
        }
      }

      function _squashResolveLine(s) {
        // Turn any preceding newline(s) before the canonical resolve text into a single space
        return String(s).replace(
          /\n{1,2}\s*Gas readings back to normal\. Resolving alert\./,
          " Gas readings back to normal. Resolving alert."
        );
      }

      function postNote(stepId) {
        // Ensure protocolState exists
        if (!window.protocolState) window.protocolState = {};
        if (!Array.isArray(protocolState.completedSteps))
          protocolState.completedSteps = [];

        // Element resolution helpers
        const resolveIO = (id) => {
          const tryBases = [id];
          let actionKey = "";

          try {
            const cfg = ProtocolFactory.getProtocolConfig(currentAlert.id);
            if (/^action-/.test(id)) {
              actionKey = id.replace(/^action-/, "");
            } else {
              const baseStepId = id.match(/^(step-\d+)/)?.[1] || id;
              const stepObj =
                cfg?.steps?.find((s) => s.id === id) ||
                cfg?.steps?.find((s) => s.id === baseStepId);
              if (stepObj?.action) actionKey = stepObj.action;
            }
          } catch {}

          if (actionKey) tryBases.unshift(`action-${actionKey}`);

          const m = id.match(/^(step-\d+)-\d+$/);
          if (m) tryBases.push(m[1]);

          let note = null,
            select = null;

          for (const base of tryBases) {
            note = note || document.getElementById(base + "-note");
            select = select || document.getElementById(base + "-select");
          }

          if (!note || !select) {
            const container =
              (actionKey &&
                document.querySelector(`[data-action="${actionKey}"]`)) ||
              document.getElementById(id);
            if (container) {
              const key =
                container.getAttribute?.("data-action") || actionKey || "";
              note =
                note ||
                container.querySelector(
                  `textarea[data-action="${key}"], textarea`
                );
              select =
                select ||
                container.querySelector(`select[data-action="${key}"], select`);
            }
          }

          return { note, select, actionKey };
        };

        let { note, select, actionKey } = resolveIO(stepId);

        // Auto-populate if empty
        if (
          note &&
          !note.value.trim() &&
          typeof autoPopulateFromDropdown === "function"
        ) {
          autoPopulateFromDropdown(stepId);
          ({ note, select, actionKey } = resolveIO(stepId));
        }

        if (!note || !note.value.trim()) {
          alert("Please enter text before posting note");
          return;
        }

        // Helper functions
        const stepLabel = (() => {
          const raw = String(stepId).replace(/^step-/, "");
          const parts = raw.split("-").filter(Boolean);
          return /^step-/.test(stepId) ? "Step " + parts.join(".") : "";
        })();

        const stripLeadingStepPrefix = (text) =>
          String(text)
            .replace(/^Step\s+\d+(?:\.\d+)?:\s*/i, "")
            .trim();

        const selectedOutcome = select ? select.value : "";
        const rawMessage = note.value.trim();
        const actionText = stripLeadingStepPrefix(rawMessage);
        const actionLabel =
          (actionKey &&
            (window.ACTION_LABELS?.[actionKey] ||
              actionKey.replace(/-/g, " "))) ||
          "";

        // Get protocol config
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const currentStep =
          protocolConfig.steps.find((s) => s.id === stepId) ||
          protocolConfig.steps.find(
            (s) => s.id === stepId.split("-").slice(0, 2).join("-")
          ) ||
          protocolConfig.steps.find((s) => s.action === actionKey);

        // Check if gas alert
        const isGas = window.isGasAlert?.(currentAlert) || false;

        // Unified logger (gas data already appended by autoPopulateFromDropdown)
        const logStep = (text) => {
          if (isGas && typeof addGasLogEntry === "function") {
            addGasLogEntry(text, stepId);
          } else {
            addLogEntry(text, "step");
          }
        };

        const CYCLE_TEXT =
          typeof CYCLE_LINE === "string"
            ? CYCLE_LINE
            : "🔄 Repeating STEPS 1, 2, 3 & 4 until someone is reached.";

        // Mark step as completed - HELPER FUNCTION INSIDE postNote (uses closure)
        const markStepCompleted = (targetStepId = stepId) => {
          const stepEl = document.getElementById(targetStepId); // ← Use parameter
          const statusBadge = document.getElementById(targetStepId + "-status"); // ← Use parameter

          if (stepEl) {
            stepEl.classList.remove("active");
            stepEl.classList.add("completed");
            stepEl.style.opacity = "0.8";
            const actionButton = stepEl.querySelector(
              'button:not([onclick*="postNote"])'
            );
            if (actionButton) {
              actionButton.disabled = true;
              actionButton.classList.remove("btn-primary");
              actionButton.classList.add("btn-secondary");
            }
            stepEl
              .querySelectorAll("select")
              .forEach((sel) => (sel.disabled = true));
          }

          if (statusBadge) {
            statusBadge.textContent = "Completed";
            statusBadge.className = "status-badge completed";
          }

          if (typeof stopTabFlashing === "function") stopTabFlashing();
          protocolState.completedSteps.push(targetStepId); // ← Use parameter
        };

        // Reset form inputs - HELPER FUNCTION
        const resetFormInputs = () => {
          note.value = "";
          if (select) select.value = "";
          note.disabled = false;

          // Clear dispatch dropdowns if this was a dispatch step
          const dispatchDropdown = document.getElementById("dispatch-decision");
          if (dispatchDropdown) {
            dispatchDropdown.value = "";
          }

          const serviceDropdown = document.getElementById("service-type");
          if (serviceDropdown) {
            serviceDropdown.value = "";
          }

          // Update dispatch UI visibility
          const serviceContainer = document.getElementById(
            "service-type-container"
          );
          if (serviceContainer) {
            serviceContainer.style.display = "none";
          }

          const skipContainer = document.getElementById(
            "skip-reason-container"
          );
          if (skipContainer) {
            skipContainer.style.display = "block";
          }

          if (typeof validatePostButton === "function")
            validatePostButton(stepId);
        };

        // DISPATCH HANDLING
        if (currentStep && currentStep.action === "dispatch") {
          const decisionEl = document.getElementById("dispatch-decision");
          const dispatchDecision = decisionEl ? decisionEl.value : "";

          if (dispatchDecision === "no") {
            const skipReasonEl = document.getElementById("skip-reason");
            const reasonText = skipReasonEl
              ? (
                  skipReasonEl.options[skipReasonEl.selectedIndex]?.text ||
                  "conditions not met"
                ).trim()
              : "conditions not met";
            const svcEl = document.getElementById("dispatch");
            const selectedService = svcEl ? (svcEl.value || "").trim() : "";

            let msg;
            try {
              if (typeof generateDispatchProtocolLog === "function") {
                msg = generateDispatchProtocolLog(
                  "no",
                  reasonText,
                  selectedService,
                  stepId
                );
              } else {
                throw new Error("generateDispatchProtocolLog not available");
              }
            } catch (e) {
              const lastTxt =
                document.getElementById("last-comm-time")?.textContent || "";
              const battTxt =
                document.getElementById("battery-level")?.textContent || "";
              const sigTxt =
                document.getElementById("signal-strength")?.textContent || "";

              const parts = [];
              const parseMins = (t) => {
                const s = String(t).toLowerCase();
                const m = s.match(/(\d+)\s*min/);
                if (m) return +m[1];
                const h = s.match(/(\d+)\s*hour/);
                if (h) return +h[1] * 60;
                const a = s.match(/(\d+).*ago/);
                return a ? +a[1] : NaN;
              };
              const num = (s) => {
                const m = String(s).match(/-?\d+(\.\d+)?/);
                return m ? Number(m[0]) : NaN;
              };

              const mins = parseMins(lastTxt);
              const b = num(battTxt);
              const sg = num(sigTxt);

              if (!Number.isNaN(mins)) parts.push(`last comm ${mins} min ago`);
              if (!Number.isNaN(b)) parts.push(`battery ${b}%`);
              if (!Number.isNaN(sg)) parts.push(`signal ${sg}%`);

              const finalReason =
                /offline/i.test(reasonText) && parts.length
                  ? `device offline (${parts.join(", ")})`
                  : reasonText;
              msg = `${stepLabel}${
                actionLabel ? ` (${actionLabel})` : ""
              }: Unable to dispatch - ${finalReason}.`;
            }

            if (!msg.endsWith(".")) msg += ".";

            // Gas normalized check for dispatch skip
            if (isGas) {
              const skipReasonVal = (
                document.getElementById("skip-reason")?.value || ""
              ).toLowerCase();
              const looksGasNormalized =
                skipReasonVal === "gas-normalized" ||
                /gas level(s)?\s*(have\s*)?(returned|back)\s*to\s*normal|gas .*normal/i.test(
                  reasonText
                );

              if (looksGasNormalized && !/Gas Type:\s/i.test(msg)) {
                let block = "";
                try {
                  block =
                    typeof getGasSnapshotFromPanel === "function"
                      ? getGasSnapshotFromPanel()
                      : "";
                  if (block) {
                    const now = new Date();
                    const ts =
                      typeof FORMATTERS?.timestampMST === "function"
                        ? FORMATTERS.timestampMST(now)
                        : new Intl.DateTimeFormat("en-US", {
                            timeZone: "America/Denver",
                            year: "numeric",
                            month: "2-digit",
                            day: "2-digit",
                            hour: "2-digit",
                            minute: "2-digit",
                            second: "2-digit",
                            hour12: false,
                          }).format(now) + " MDT";
                    block = block.replace(
                      /(Gas Reading:\s*[^\n]+)/i,
                      `$1 (${ts})`
                    );
                    msg += `\n\n${block}`;
                  }
                } catch {}
              }
            }

            msg += `\n\n${CYCLE_TEXT}`;
            logStep(msg);

            markStepCompleted(); // Uses closure - no parameter
            resetFormInputs();

            if (typeof silentlyUpdateDispatchConditions === "function") {
              silentlyUpdateDispatchConditions();
              requestAnimationFrame(silentlyUpdateDispatchConditions);
            }

            setTimeout(() => restartProtocolCycle(), 1000);
            return;
          }

          // ===== ADD 30-MINUTE TIMER FOR DISPATCH "YES" =====
          if (dispatchDecision === "yes") {
            const serviceDropdown = document.getElementById("service-type");
            const serviceName = serviceDropdown
              ? serviceDropdown.options[serviceDropdown.selectedIndex]?.text ||
                "Emergency Services"
              : "Emergency Services";

            // Start 30-minute dispatch follow-up timer
            if (typeof startGlobalTimer === "function") {
              startGlobalTimer(stepId, "Dispatch Follow-up", serviceName, 1800);
              addLogEntry(
                `⏰ Started 30-minute dispatch follow-up timer for ${serviceName}`,
                "timer"
              );

              // Disable only the Post Note button
              const postBtn = document.getElementById(stepId + "-post-btn");
              if (postBtn) {
                postBtn.disabled = true;
                postBtn.classList.remove("btn-success");
                postBtn.classList.add("btn-secondary");
              }

              // Set step status to "Waiting" after other processing completes
              setTimeout(() => {
                const statusBadge = document.getElementById(stepId + "-status");
                if (statusBadge) {
                  statusBadge.textContent = "Waiting";
                  statusBadge.className = "status-badge waiting";
                  statusBadge.style.background = "#ffc107";
                  statusBadge.style.color = "#000";
                }
              }, 200); // Small delay to ensure it runs after other status updates

              // Scroll to timer
              setTimeout(() => {
                const timerElement = document.getElementById("globalTimer");
                if (timerElement) {
                  timerElement.scrollIntoView({
                    behavior: "smooth",
                    block: "center",
                  });
                }
              }, 100);

              // Ensure callback section stays active
              const callbackDropdown = document.querySelector(
                'select[data-cy="global-cancel-dropdown"]'
              );
              if (callbackDropdown) {
                callbackDropdown.disabled = false;
              }
            }
          }

          // Ensure callback section stays fully active
          setTimeout(() => {
            // Enable the callback dropdown
            const callbackDropdown = document.querySelector(
              'select[data-cy="global-cancel-dropdown"]'
            );
            if (callbackDropdown) {
              callbackDropdown.disabled = false;
              callbackDropdown.style.opacity = "1";
              callbackDropdown.style.pointerEvents = "auto";
            }

            // Also try alternative selectors in case the dropdown has a different structure
            const allSelects = document.querySelectorAll(
              "#" + stepId + " select"
            );
            allSelects.forEach((select) => {
              // Only enable selects that are NOT the dispatch decision or service type
              if (
                !select.id.includes("dispatch-decision") &&
                !select.id.includes("service-type")
              ) {
                select.disabled = false;
                select.style.opacity = "1";
                select.style.pointerEvents = "auto";
              }
            });
          }, 300); // Longer delay to ensure it runs after all other processing

          // Clear dispatch form fields AFTER timer starts
          setTimeout(() => {
            // Clear "Dispatch conditions met?" dropdown
            const dispatchDecision =
              document.getElementById("dispatch-decision");
            if (dispatchDecision) {
              dispatchDecision.value = "";
              dispatchDecision.disabled = true;
            }

            // Clear "Dispatch Service Type:" dropdown
            const serviceDropdown = document.getElementById("service-type");
            if (serviceDropdown) {
              serviceDropdown.value = "";
            }

            // Update UI visibility
            const serviceContainer = document.getElementById(
              "service-type-container"
            );
            if (serviceContainer) {
              serviceContainer.style.display = "none";
            }

            const skipContainer = document.getElementById(
              "skip-reason-container"
            );
            if (skipContainer) {
              skipContainer.style.display = "block";
            }
          }, 400); // After all other processing completes
        }

        // Legacy unable-to-dispatch outcome
        if (
          (currentStep && currentStep.action === "dispatch") ||
          (["step-4", "step-5"].includes(stepId) &&
            selectedOutcome === "unable-to-dispatch")
        ) {
          if (selectedOutcome === "unable-to-dispatch") {
            let msg;
            try {
              msg = generateDispatchProtocolLog("no", actionText, "", stepId);
            } catch (e) {
              msg = `${stepLabel}${
                actionLabel ? ` (${actionLabel})` : ""
              }: ${actionText}.`;
            }
            if (!msg.endsWith(".")) msg += ".";
            msg += `\n\n${CYCLE_TEXT}`;
            logStep(msg);

            markStepCompleted(); // Uses closure - no parameter
            resetFormInputs();

            if (typeof silentlyUpdateDispatchConditions === "function") {
              silentlyUpdateDispatchConditions();
              requestAnimationFrame(silentlyUpdateDispatchConditions);
            }

            setTimeout(() => restartProtocolCycle(), 1000);
            return;
          }
        }

        // NORMAL PROCESSING
        let body = (actionText || "").trim();

        // Special cases for "Unable to call" patterns
        if (/^unable to call\b/i.test(body)) {
          if (currentStep?.action === "call-device") {
            body = `Attempted to call device. ${body.replace(
              /^unable to call\s*[:,]?\s*/i,
              "Unable to call, "
            )}`;
          } else if (currentStep?.action === "call-user") {
            body = `Attempted to call user. ${body.replace(
              /^unable to call\s*[:,]?\s*/i,
              "Unable to call, "
            )}`;
          }
        }

        // Handle inbound callbacks
        const inboundCb =
          /^\s*(user called in|ec called in|emergency contact called in|callback received)\b/i.test(
            body
          );

        if (
          currentStep?.action === "call-device" &&
          !/^called device\b/i.test(body) &&
          !/^attempted to call device\b/i.test(body) &&
          !inboundCb
        ) {
          body = `Called device. ${body.charAt(0).toUpperCase()}${body.slice(
            1
          )}`;
        }

        // Emergency contact ordinal injection
        if (currentStep?.action === "call-emergency-contacts") {
          console.log("DEBUG EC TRANSFORM: Original body =", body);

          const ecOrdinal = (() => {
            if (Number.isInteger(currentStep?.meta?.ecIndex))
              return currentStep.meta.ecIndex;
            const el = document.getElementById(stepId);
            if (el && el.parentElement) {
              const cfg = ProtocolFactory.getProtocolConfig(currentAlert.id);
              const siblings = Array.from(
                el.parentElement.querySelectorAll('[id^="step-"]')
              ).filter(
                (n) =>
                  (cfg?.steps || []).find((xx) => xx.id === n.id)?.action ===
                  "call-emergency-contacts"
              );
              const idx = siblings.indexOf(el);
              if (idx >= 0) return idx + 1;
            }
            const m = String(stepId).match(/step-\d+-(\d+)/i);
            return m ? parseInt(m[1], 10) : 1;
          })();

          // Get emergency contact details
          const getECDetails = (index) => {
            if (
              currentUser?.emergencyContacts &&
              currentUser.emergencyContacts[index - 1]
            ) {
              const contact = currentUser.emergencyContacts[index - 1];
              return { name: contact.name, phone: contact.phone };
            }
            return { name: "emergency contact", phone: "" };
          };

          const ecDetails = getECDetails(ecOrdinal);
          console.log("DEBUG EC TRANSFORM: ecOrdinal =", ecOrdinal);
          console.log("DEBUG EC TRANSFORM: ecDetails =", ecDetails);

          // Check for inbound calls first - remove prefix and handle skipping
          if (/called in/i.test(body)) {
            // Remove "Emergency Contact X:" prefix for inbound calls
            body = body.replace(/^emergency contact \d+:\s*/i, "");

            // Handle resolution and skipping for confirmed okay inbound calls
            if (
              /emergency contact called in and confirmed.*is okay/i.test(body)
            ) {
              const mainStepId = stepId.split("-").slice(0, 2).join("-"); // "step-4"
              const currentSubStep = parseInt(stepId.split("-")[2], 10); // 1

              // Skip remaining sub-steps
              for (let i = currentSubStep + 1; i <= 10; i++) {
                const nextSubStepId = `${mainStepId}-${i}`;
                const nextSubStep = document.getElementById(nextSubStepId);
                if (nextSubStep) {
                  nextSubStep.style.opacity = "0.5";
                  nextSubStep.style.pointerEvents = "none";
                  const statusBadge = document.getElementById(
                    nextSubStepId + "-status"
                  );
                  if (statusBadge) {
                    statusBadge.textContent = "Skipped";
                    statusBadge.className = "status-badge skipped";
                    statusBadge.style.background = "#6c757d";
                    statusBadge.style.color = "white";
                  }
                }
              }

              // Complete main step
              const mainStep = document.getElementById(mainStepId);
              if (mainStep) {
                const mainStatusBadge = document.getElementById(
                  mainStepId + "-status"
                );
                if (mainStatusBadge) {
                  mainStatusBadge.textContent = "Completed";
                  mainStatusBadge.className = "status-badge completed";
                }
              }

              // Skip subsequent main steps
              const currentMainStepNum = parseInt(mainStepId.split("-")[1], 10); // 4
              for (let i = currentMainStepNum + 1; i <= 10; i++) {
                const nextMainStepId = `step-${i}`;
                const nextMainStep = document.getElementById(nextMainStepId);
                if (nextMainStep) {
                  nextMainStep.style.opacity = "0.5";
                  nextMainStep.style.pointerEvents = "none";
                  const statusBadge = document.getElementById(
                    nextMainStepId + "-status"
                  );
                  if (statusBadge) {
                    statusBadge.textContent = "Skipped";
                    statusBadge.className = "status-badge skipped";
                    statusBadge.style.background = "#6c757d";
                    statusBadge.style.color = "white";
                  }
                }
              }
            }
          } else if (
            (/^called\s+emergency contact/i.test(body) ||
              /^emergency contact \d+:/i.test(body) ||
              /^called\s+[A-Za-z\s]+\s+at\s+\+/i.test(body)) && // NEW: Match "Called Name at +phone"
            !/^called\s+EC\d+\b/i.test(body) &&
            !/called in/i.test(body)
          ) {
            // Handle outbound calls - add EC details
            if (/^emergency contact \d+:/i.test(body)) {
              // Remove the prefix and any existing "Called [name] at [phone]" part
              body = body.replace(/^emergency contact \d+:\s*/i, "");
              body = body.replace(/^called\s+[^.]+at\s+\+[^.]+\.\s*/i, "");
              body = `Called EC${ecOrdinal} ${ecDetails.name} at ${ecDetails.phone}. ${body}`;
            } else if (/^called\s+[A-Za-z\s]+\s+at\s+\+/i.test(body)) {
              // NEW: Handle "Called Name at +phone" format
              body = body.replace(/^called\s+/i, `Called EC${ecOrdinal} `);
            } else {
              body = body.replace(
                /^called\s+/i,
                `Called EC${ecOrdinal} ${ecDetails.name} at ${ecDetails.phone}. `
              );
            }
            // Clean up any redundant text
            body = body.replace(/\s*emergency contact[.,]?\s*/gi, ". ");
            body = body.replace(/\.\s*\./g, ".");
          }
        }

        if (!/[.!?]$/.test(body)) body += ".";

        // Add gas data for emergency contact resolving outcomes
        if (
          window.isGasAlert?.(currentAlert) &&
          currentStep?.action === "call-emergency-contacts" &&
          (/confirmed.*okay/i.test(body) ||
            /confirmed user is okay/i.test(body)) &&
          !/Gas Type:\s/i.test(body)
        ) {
          const gasBlockRaw =
            typeof getGasSnapshotFromPanel === "function"
              ? getGasSnapshotFromPanel()
              : "";

          if (gasBlockRaw) {
            const now = new Date();
            const ts =
              typeof FORMATTERS?.timestampMST === "function"
                ? FORMATTERS.timestampMST(now)
                : new Intl.DateTimeFormat("en-US", {
                    timeZone: "America/Denver",
                    year: "numeric",
                    month: "2-digit",
                    day: "2-digit",
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit",
                    hour12: false,
                  }).format(now) + " MDT";

            const gasBlockWithTs = gasBlockRaw.replace(
              /(Gas Reading:\s*[^\n]+)/i,
              `$1 (${ts})`
            );

            const gasStillHigh =
              typeof isAnyGasDangerousNow === "function"
                ? isAnyGasDangerousNow()
                : !isGasCurrentlyNormalized();

            if (gasStillHigh) {
              const warningText = "⚠️ Gas levels still HIGH.";
              body += `\n\n${warningText}\n\n${gasBlockWithTs}`;
            } else {
              const preface = "Gas readings back to normal.";
              body += `\n\n${preface}\n\n${gasBlockWithTs}`;
            }
          }
        }

        // Don't add step label for inbound calls
        let msg = /called in/i.test(body) ? body : `${stepLabel}: ${body}`;

        // Resolving outcome handling
        const RESOLVING_OUTCOMES = new Set([
          "confirmed-ok",
          "user-callback",
          "ec-callback",
          "device-no",
          "issue-resolved",
          "false-alarm",
        ]);
        const isResolvingOutcome =
          RESOLVING_OUTCOMES.has(selectedOutcome) ||
          /emergency contact called in and confirmed.*is okay/i.test(body) ||
          /user called in.*confirmed they are okay/i.test(body);
        let suppressResolutionFlow = false;

        if (isResolvingOutcome) {
          if (isGas) {
            const U = (id) =>
              (document.getElementById(id)?.textContent || "").toUpperCase();
            const dangerO2 = /ENRICHED|DEPLETED/.test(U("o2-status"));
            const dangerOthers =
              /\bHIGH\b/.test(U("h2s-status")) ||
              /\bHIGH\b/.test(U("co-status")) ||
              /\bHIGH\b/.test(U("lel-status"));
            const normalized = !(dangerO2 || dangerOthers);

            if (normalized) {
              if (!/[.?!]$/.test(msg)) msg += ".";
              let block = "";
              try {
                block =
                  typeof getGasSnapshotFromPanel === "function"
                    ? getGasSnapshotFromPanel()
                    : "";
                if (block) {
                  const now = new Date();
                  const ts =
                    typeof FORMATTERS?.timestampMST === "function"
                      ? FORMATTERS.timestampMST(now)
                      : new Intl.DateTimeFormat("en-US", {
                          timeZone: "America/Denver",
                          year: "numeric",
                          month: "2-digit",
                          day: "2-digit",
                          hour: "2-digit",
                          minute: "2-digit",
                          second: "2-digit",
                          hour12: false,
                        }).format(now) + " MDT";
                  block = block.replace(
                    /(Gas Reading:\s*[^\n]+)/i,
                    `$1 (${ts})`
                  );
                }
              } catch {}
              msg +=
                `\n\nGas readings back to normal. Resolving alert.` +
                (block ? `\n\n${block}` : "");
            } else {
              if (!/[.?!]$/.test(msg)) msg += ".";
              suppressResolutionFlow = true;

              const resSection =
                document.querySelector(".resolution-section") ||
                document.getElementById("resolution-section") ||
                document.querySelector('[data-cy="resolution-section"]');
              resSection?.scrollIntoView({
                behavior: "smooth",
                block: "start",
              });

              const resolutionSelect =
                document.getElementById("resolution-reason");
              if (resolutionSelect && !resolutionSelect.value) {
                resolutionSelect.value = "incident-without-dispatch";
              }

              const resolveBtn =
                document.getElementById("resolve-alert-btn") ||
                document.querySelector('[data-cy="resolve-alert-btn"]');
              if (resolveBtn) {
                resolveBtn.disabled = false;
                resolveBtn.focus();
              }

              if (
                currentAlert?.gasNormalization?.enabled &&
                currentAlert.gasNormalization.triggerAfterStep === stepId &&
                !currentAlert._norm
              ) {
                currentAlert._norm = 1;
                setTimeout(() => triggerGasNormalization(currentAlert), 3000);
              }

              msg = msg.replace(/\s*Resolving alert\.?/gi, "");
              if (typeof _squashResolveLine === "function")
                msg = _squashResolveLine(msg);

              logStep(msg);
              markStepCompleted(); // Uses closure - no parameter
              resetFormInputs();
              return;
            }
          } else {
            if (!/resolving alert/i.test(msg)) {
              if (!/[.?!]$/.test(msg)) msg += ".";
              msg += " Resolving alert.";
            }
          }
        }

        if (typeof _squashResolveLine === "function")
          msg = _squashResolveLine(msg);
        logStep(msg);

        // Timer logic for EC callback
        if (
          selectedOutcome === "ec-callback-30min" ||
          selectedOutcome === "ec-callback-30min-outbound"
        ) {
          if (typeof startGlobalTimer === "function") {
            startGlobalTimer(stepId, "EC Callback", "Emergency Contact", 1800);

            const statusBadge = document.getElementById(stepId + "-status");
            if (statusBadge) {
              statusBadge.textContent = "Waiting";
              statusBadge.className = "status-badge waiting";
            }

            resetFormInputs();
            return; // Exit early - don't mark completed
          }
        }

        markStepCompleted(); // Uses closure - no parameter
        resetFormInputs();

        const isConfirmedOK = isResolvingOutcome;
        if (isConfirmedOK && !suppressResolutionFlow) {
          triggerResolutionFlow(stepId, "User confirmed okay");
          if (typeof silentlyUpdateDispatchConditions === "function") {
            silentlyUpdateDispatchConditions();
            requestAnimationFrame(silentlyUpdateDispatchConditions);
          }
          return;
        }

        // Sub-step progression
        if (stepId.includes("-") && stepId.split("-").length === 3) {
          const parts = stepId.split("-");
          const mainStepId = `${parts[0]}-${parts[1]}`;
          const subStepNum = parseInt(parts[2], 10);

          const mainStep = protocolConfig.steps.find(
            (s) => s.id === mainStepId
          );
          if (mainStep && mainStep.action === "combined-device-user-call") {
            console.log("Combined step logic triggered");
            console.log("stepId:", stepId);
            console.log("mainStepId:", mainStepId);
            console.log("selectedOutcome:", selectedOutcome);

            if (
              selectedOutcome === "no-answer" ||
              selectedOutcome === "unable-to-call"
            ) {
              const nextSubStepId = `${mainStepId}-${subStepNum + 1}`;
              const nextSubStep = document.getElementById(nextSubStepId);
              console.log("nextSubStepId:", nextSubStepId);
              console.log("nextSubStep exists:", !!nextSubStep);

              if (nextSubStep) {
                const nextButton = nextSubStep.querySelector(
                  'button:not([onclick*="postNote"])'
                );
                if (nextButton) {
                  nextButton.disabled = false;
                  nextButton.classList.remove("btn-secondary");
                  nextButton.classList.add("btn-primary");
                }
                return;
              } else {
                console.log("No next substep, marking main step completed");
                markStepCompleted(mainStepId);
                enableNextStep(mainStepId);
                return;
              }
            }
            console.log("Non-no-answer outcome, marking main step completed");
            markStepCompleted(mainStepId);
            enableNextStep(mainStepId);
            return;
          } else if (
            mainStep &&
            mainStep.action === "call-emergency-contacts"
          ) {
            if (
              [
                "no-answer",
                "no-answer-voicemail",
                "no-answer-unable",
                "unable-to-connect",
                "wrong-number",
                "number-invalid",
              ].includes(selectedOutcome)
            ) {
              const nextSubStepId = `${mainStepId}-${subStepNum + 1}`;
              const nextSubStep = document.getElementById(nextSubStepId);
              if (nextSubStep) {
                const nextButton = nextSubStep.querySelector(
                  'button:not([onclick*="postNote"])'
                );
                if (nextButton) {
                  nextButton.disabled = false;
                  nextButton.classList.remove("btn-secondary");
                  nextButton.classList.add("btn-primary");
                }
                return;
              } else {
                markStepCompleted(mainStepId); // GLOBAL function call - needs parameter
                enableNextStep(mainStepId);
                return;
              }
            }
            markStepCompleted(mainStepId); // GLOBAL function call - needs parameter
            enableNextStep(mainStepId);
            return;
          }
        }

        // Normal progression
        enableNextStep(stepId);
        if (typeof silentlyUpdateDispatchConditions === "function") {
          silentlyUpdateDispatchConditions();
          requestAnimationFrame(silentlyUpdateDispatchConditions);
        }

        // Gas normalization trigger
        if (
          currentAlert?.gasNormalization?.enabled &&
          currentAlert.gasNormalization.triggerAfterStep === stepId &&
          !currentAlert._norm
        ) {
          currentAlert._norm = 1;
          setTimeout(() => triggerGasNormalization(currentAlert), 3000);
        }

        // ===== ADD 30-MINUTE TIMER FOR DISPATCH "YES" =====
        const decisionEl = document.getElementById("dispatch-decision");
        const dispatchDecision = decisionEl ? decisionEl.value : "";
      }

      function markStepCompleted(stepId) {
        const step = document.getElementById(stepId);
        const statusBadge = document.getElementById(stepId + "-status");

        if (step) {
          step.classList.add("completed");
          step.classList.remove("active");
          step.style.opacity = "0.8";

          const actionButton = step.querySelector(
            'button:not([onclick*="postNote"])'
          );
          if (actionButton) {
            actionButton.disabled = true;
            actionButton.classList.remove("btn-primary");
            actionButton.classList.add("btn-secondary");
          }

          step
            .querySelectorAll("select")
            .forEach((select) => (select.disabled = true));
        }

        // ✅ PROPER BADGE CLASS HANDLING - This fixes the yellow badge issue
        if (statusBadge) {
          statusBadge.textContent = "Completed";
          statusBadge.className = "status-badge completed"; // Clean replacement of all classes
        }

        if (!window.protocolState) window.protocolState = {};
        if (!Array.isArray(protocolState.completedSteps))
          protocolState.completedSteps = [];
        if (!protocolState.completedSteps.includes(stepId))
          protocolState.completedSteps.push(stepId);

        if (typeof enableNextStep === "function") {
          enableNextStep(stepId);
        }
      }

      function blockRemainingSteps(currentStepId, reason) {
        console.log(
          "=== blockRemainingSteps called with:",
          currentStepId,
          "reason:",
          reason
        );

        // Special handling for sub-steps (like step-3-1, step-4-1, etc.)
        if (
          currentStepId.includes("-") &&
          currentStepId.split("-").length === 3
        ) {
          console.log("=== Handling sub-step:", currentStepId);

          // Dynamically split any sub-step into parts
          const parts = currentStepId.split("-"); // ["step", "3", "1"] or ["step", "4", "1"]
          const mainStep = parts[0] + "-" + parts[1]; // "step-3" or "step-4"
          const subStep = parts[2]; // "1"

          console.log("mainStep:", mainStep, "subStep:", subStep);

          // Skip remaining sub-steps of the same main step
          const allSubSteps = document.querySelectorAll(`[id^="${mainStep}-"]`);
          console.log(
            "Found sub-steps:",
            Array.from(allSubSteps).map((el) => el.id)
          );

          allSubSteps.forEach((step) => {
            const stepParts = step.id.split("-");
            if (stepParts.length >= 3) {
              // Ensure it's actually a sub-step like step-3-2 or step-4-2
              const subStepNum = parseInt(stepParts[2]);
              const currentSubNum = parseInt(subStep);

              console.log(
                "Checking sub-step:",
                step.id,
                "subStepNum:",
                subStepNum,
                "vs currentSubNum:",
                currentSubNum
              );

              if (subStepNum > currentSubNum) {
                console.log("SKIPPING sub-step:", step.id);
                // Hide the dropdown for skipped steps
                const outcomeSection = document.getElementById(
                  step.id + "-outcome"
                );
                if (outcomeSection) {
                  outcomeSection.style.display = "none";
                }
                const status = document.getElementById(step.id + "-status");
                if (status) {
                  status.textContent = "Skipped. User confirmed OK.";
                  status.className = "status-badge";
                  status.style.background = "#6c757d";
                  status.style.color = "white";
                  status.style.animation = "none";
                  status.style.transition = "none";
                  status.classList.remove(
                    "completed",
                    "active",
                    "pulsing",
                    "timer-active",
                    "timer-alert"
                  );
                }
                step.style.opacity = "0.5";
                step.classList.remove("active");
              }
            }
          });

          // ALSO mark the main step as completed when resolving from a sub-step
          const mainStepId = mainStep; // Already calculated above

          console.log("Marking main step as completed:", mainStepId);

          const mainStepElement = document.getElementById(mainStepId);
          const mainStatus = document.getElementById(mainStepId + "-status");

          if (mainStepElement) {
            mainStepElement.classList.remove("active");
            mainStepElement.classList.add("completed");
          }

          if (mainStatus) {
            mainStatus.textContent = "Completed";
            mainStatus.className = "status-badge completed";
            mainStatus.style.animation = "none";
            mainStatus.style.transition = "none";
          }
        }

        // Get all steps after current one, including sub-steps
        const allSteps = document.querySelectorAll(".step");
        const currentIndex = parseInt(
          currentStepId.replace(/step-(\d+).*/, "$1")
        );

        console.log("currentIndex extracted:", currentIndex);

        allSteps.forEach((step) => {
          if (step.id && step.id.startsWith("step-")) {
            const stepIndex = parseInt(step.id.replace(/step-(\d+).*/, "$1"));

            console.log(
              "Processing step:",
              step.id,
              "stepIndex:",
              stepIndex,
              "vs currentIndex:",
              currentIndex
            );

            // Skip steps that come after the current step
            if (stepIndex > currentIndex) {
              console.log("SKIPPING main step:", step.id);
              // Hide the dropdown for skipped steps
              const outcomeSection = document.getElementById(
                step.id + "-outcome"
              );
              if (outcomeSection) {
                outcomeSection.style.display = "none";
              }
              const nextStatus = document.getElementById(step.id + "-status");

              step.style.opacity = "0.5";
              step.classList.remove("active");

              const nextButton = step.querySelector(
                'button:not([onclick*="postNote"])'
              );
              if (
                nextButton &&
                !nextButton.onclick.toString().includes("callDispatch")
              ) {
                nextButton.disabled = true;
                nextButton.classList.remove("btn-primary");
                nextButton.classList.add("btn-secondary");
                nextButton.style.pointerEvents = "none";
              }

              // Keep the textarea and post note button enabled
              const textarea = document.getElementById(step.id + "-note");
              const postBtn = document.getElementById(step.id + "-post-btn");

              if (textarea) {
                textarea.disabled = false;
                textarea.style.pointerEvents = "auto";
              }

              if (postBtn) {
                postBtn.style.pointerEvents = "auto";
                validatePostButton(step.id);
              }

              if (nextStatus) {
                nextStatus.textContent = "Skipped. User confirmed OK.";
                nextStatus.className = "status-badge";
                nextStatus.style.background = "#6c757d";
                nextStatus.style.color = "white";
                nextStatus.style.animation = "none";
                nextStatus.style.transition = "none";
                nextStatus.classList.remove(
                  "completed",
                  "active",
                  "pulsing",
                  "timer-active",
                  "timer-alert"
                );
              }
            }
          }
        });
      }

      function isGasLevelHigh() {
        const h2sStatus = document.getElementById("h2s-status");
        return h2sStatus && h2sStatus.textContent === "HIGH";
      }

      // ADD THIS NEW FUNCTION RIGHT HERE:
      function isGasAlert(alert) {
        if (!alert || !alert.id) return false;

        // Check for gas-related alert IDs
        const gasAlertIds = [
          "gas-high-threshold",
          "h2s-response",
          "h2s-high",
          "co-response",
          "co-high",
          "lel-response",
          "lel-high",
          "o2-response",
          "o2-high",
          "o2-low",
        ];

        return (
          gasAlertIds.includes(alert.id) ||
          alert.id.includes("gas") ||
          alert.id.includes("h2s") ||
          alert.id.includes("co") ||
          alert.id.includes("lel") ||
          alert.id.includes("o2")
        );
      }

      function getCurrentGasReading() {
        const h2sValueElement = document.getElementById("h2s-value");
        const h2sStatusElement = document.getElementById("h2s-status");

        if (!h2sValueElement || !h2sStatusElement) {
          return {
            type: "H₂S",
            value: "17.90",
            unit: " ppm",
            status: "HIGH",
          };
        }

        const h2sReading = h2sValueElement.textContent;
        const h2sStatus = h2sStatusElement.textContent;

        return {
          type: "H₂S",
          value: h2sReading.split(" ")[0],
          unit: " ppm",
          status: h2sStatus,
        };
      }

      function completeResolution(reason, overrideReason) {
        // Cancel any active timer when resolving alert
        cancelGlobalTimer();

        // Simple resolution log based on whether it's an override or normal
        if (overrideReason) {
          addLogEntry(
            "Alert resolved (Override: " + overrideReason + ")",
            "resolution"
          );
        } else {
          addLogEntry("Alert resolved.", "resolution");
        }

        // Mark resolution as complete
        const resolutionBadge = document.querySelector(
          ".resolution-section .status-badge"
        );
        if (resolutionBadge) {
          resolutionBadge.textContent = "Completed";
          resolutionBadge.classList.add("completed");
        }

        // Disable and update the resolve button
        const resolveButton = document.querySelector(
          ".resolution-section .btn-danger"
        );
        if (resolveButton) {
          resolveButton.disabled = true;
          resolveButton.classList.remove("btn-danger");
          resolveButton.classList.add("btn-secondary");
          resolveButton.textContent = "✅ Alert Resolved";
        }

        // Scroll to top to show the resolution log
        setTimeout(() => {
          window.scrollTo({
            top: 0,
            behavior: "smooth",
          });
        }, 100);
      }

      function resolveAlert(stepId) {
        // ⛔️ Guard first: Gas alert + any dangerous reading → force override modal
        if (
          typeof isGasAlert === "function" &&
          isGasAlert(currentAlert) &&
          (typeof isAnyGasDangerousNow === "function"
            ? isAnyGasDangerousNow()
            : typeof isGasLevelHigh === "function"
            ? isGasLevelHigh()
            : false)
        ) {
          // Prefer programmatic opener; fallback to button
          if (typeof openResolutionOverrideModal === "function") {
            openResolutionOverrideModal({ stepId, gas: "GAS HIGH" });
          } else if (typeof showOverrideModal === "function") {
            showOverrideModal();
          } else {
            (
              document.getElementById("override-resolution-btn") ||
              document.querySelector('[data-cy="override-resolution-btn"]')
            )?.click();
          }

          // Optional: focus the modal's reason select right away
          requestAnimationFrame(() => {
            (
              document.getElementById("override-reason") ||
              document.querySelector('[data-cy="override-reason"]')
            )?.focus();
          });
          return; // Modal will handle confirm → then call completeResolution(...)
        }

        // --- Existing logic (unchanged) ---
        const reasonSelect = document.querySelector(
          ".resolution-section select"
        );
        let reason = reasonSelect ? reasonSelect.value : "";

        // If no resolution reason selected, auto-determine it
        if (!reason) {
          reason =
            typeof determineResolutionType === "function"
              ? determineResolutionType(currentAlert)
              : "resolved";
          if (reasonSelect) {
            reasonSelect.value = reason;
          }
        }

        // LOCK UI: Disable and grey-out all elements except Cancel Resolution and Add Note
        lockUIForResolution();

        completeResolution(reason);
      }

      function lockUIForResolution() {
        // Handle Step 1 specifically - if still Active, mark as "Skipped"
        const step1 = document.getElementById("step-1");
        const step1Status = document.getElementById("step-1-status");
        if (step1 && step1.classList.contains("active")) {
          step1.classList.remove("active");
          step1.classList.add("completed");
          step1.style.opacity = "0.5";
          if (step1Status) {
            step1Status.textContent = "Skipped. User confirmed OK.";
            step1Status.classList.add("completed");
          }
        }

        // Disable and grey-out all steps
        const allSteps = document.querySelectorAll(".step");
        allSteps.forEach((step) => {
          // Grey out ALL steps (including completed ones) - use !important to override other styles
          step.style.setProperty("opacity", "0.5", "important");
          step.style.setProperty("pointer-events", "none", "important");

          // Disable all buttons in steps
          const buttons = step.querySelectorAll("button");
          buttons.forEach((btn) => (btn.disabled = true));

          // Disable all dropdowns in steps
          const selects = step.querySelectorAll("select");
          selects.forEach((select) => (select.disabled = true));

          // Disable all textareas in steps
          const textareas = step.querySelectorAll("textarea");
          textareas.forEach((textarea) => (textarea.disabled = true));
        });

        // Disable and grey-out timer controls MORE prominently
        const globalTimer = document.getElementById("globalTimer");
        if (globalTimer) {
          globalTimer.style.opacity = "0.3"; // More greyed out
          globalTimer.style.pointerEvents = "none";
          globalTimer.style.filter = "grayscale(50%)"; // Add grey filter

          const timerDropdown = globalTimer.querySelector("select");
          if (timerDropdown) timerDropdown.disabled = true;
        }

        // Disable resolution dropdown but keep buttons active
        const resolutionSelect = document.querySelector(
          ".resolution-section select"
        );
        if (resolutionSelect) {
          resolutionSelect.disabled = true;
          resolutionSelect.style.opacity = "0.5";
        }

        // Disable "Resolve Alert" button
        const resolveButton = document.querySelector(
          ".resolution-section .btn-danger"
        );
        if (resolveButton) {
          resolveButton.disabled = true;
          resolveButton.style.opacity = "0.5";
        }

        // KEEP ACTIVE: Cancel Resolution button and Add Note section
        const cancelButton = document.querySelector(
          ".resolution-section .btn-secondary"
        );
        if (cancelButton) {
          cancelButton.disabled = false;
          cancelButton.style.opacity = "1";
          cancelButton.style.pointerEvents = "auto";
        }

        // KEEP ACTIVE: Add Note section (but don't grey out Protocol Log section)
        const manualNotes = document.getElementById("manual-notes");
        const addNoteButton = document.querySelector(
          'button[onclick="addManualNote()"]'
        );
        if (manualNotes) {
          manualNotes.disabled = false;
          manualNotes.style.opacity = "1";
        }
        if (addNoteButton) {
          addNoteButton.disabled = false;
          addNoteButton.style.opacity = "1";
          addNoteButton.style.pointerEvents = "auto";
        }
      }

      function showOverrideModal() {
        const gasReading = getCurrentGasReading();
        document.getElementById("overrideGasReading").textContent =
          "Current Gas Reading: " +
          gasReading.type +
          ": " +
          gasReading.value +
          gasReading.unit +
          " (" +
          gasReading.status +
          ")";

        document.getElementById("modalOverlay").style.display = "block";
        document.getElementById("overrideModal").style.display = "block";

        // Enable/disable confirm button based on override reason selection
        const overrideReasonSelect = document.getElementById("override-reason");
        const confirmBtn = document.getElementById("confirmOverrideBtn");

        // Remove any existing event listeners to prevent duplicates
        const newOverrideReasonSelect = overrideReasonSelect.cloneNode(true);
        overrideReasonSelect.parentNode.replaceChild(
          newOverrideReasonSelect,
          overrideReasonSelect
        );

        // Add fresh event listener
        newOverrideReasonSelect.addEventListener("change", function () {
          document.getElementById("confirmOverrideBtn").disabled = !this.value;
        });

        // Reset the select and button state
        newOverrideReasonSelect.value = "";
        confirmBtn.disabled = true;
      }

      // Function 1: Enable button when dropdown changes
      function enableOverrideButton() {
        const overrideReason = document.getElementById("override-reason").value;
        const confirmBtn = document.getElementById("confirmOverrideBtn");

        confirmBtn.disabled = !overrideReason;
      }

      // ═══════════════════════════════════════════════════════════════
      // 🎨 UI RENDERING & UPDATE FUNCTIONS
      // ═══════════════════════════════════════════════════════════════

      function updateAlertHeader(alertConfig, userConfig) {
        const alertId = Math.floor(Math.random() * 9000000) + 1000000;
        const alertTime = formatAlertTime(new Date());

        document.getElementById("alert-title").textContent =
          "🚨 Alert Management - " +
          userConfig.name +
          " (" +
          alertConfig.displayName +
          ")";
        document.getElementById("alert-id").textContent = alertId;
        document.getElementById("employee-details").textContent =
          userConfig.name + " (ID: " + userConfig.id + ")";
        document.getElementById("device-details").textContent =
          userConfig.device;
        document.getElementById("mobile-number").textContent =
          userConfig.mobile;
        document.getElementById("alert-time").textContent = alertTime;
        document.getElementById("alert-trigger").textContent =
          alertConfig.displayName;
      }

      function formatAlertTime(alertDate) {
        const now = new Date();
        const diffMinutes = Math.floor((now - alertDate) / 60000);

        const timeStr =
          alertDate.toLocaleDateString("en-US", {
            month: "2-digit",
            day: "2-digit",
            year: "numeric",
          }) +
          " " +
          alertDate.toLocaleTimeString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            hour12: false,
          }) +
          " MDT";

        let timeAgo = "";
        if (diffMinutes === 0) timeAgo = "(just now)";
        else if (diffMinutes === 1) timeAgo = "(-1 minute ago)";
        else if (diffMinutes < 60) timeAgo = `(-${diffMinutes} minutes ago)`;
        else if (diffMinutes < 1440)
          timeAgo = `(-${Math.floor(diffMinutes / 60)} hours ago)`;
        else timeAgo = `(-${Math.floor(diffMinutes / 1440)} days ago)`;

        return `${timeStr} ${timeAgo}`;
      }

      function addAlertSequenceLogs(userConfig) {
        const now = new Date();
        const ackTime = new Date(now.getTime() - 9000);
        const serverTime = new Date(now.getTime() - 18000);
        const deviceTime = new Date(now.getTime() - 18000);

        const formatEDT = function (date) {
          return (
            date.toLocaleTimeString("en-US", {
              hour12: false,
              timeZone: "America/New_York",
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            }) + " EDT"
          );
        };

        addLogEntry(
          "Alert triggered by device.",
          "system",
          "*" + userConfig.company + "*",
          formatEDT(deviceTime)
        );
        addLogEntry(
          "Alert received by server.",
          "system",
          "*" + userConfig.company + "*",
          formatEDT(serverTime)
        );
        addLogEntry(
          "Alert acknowledged.",
          "system",
          "*Blackline Safety Operations Centre*",
          formatEDT(ackTime)
        );
      }

      function addLogEntry(message, type, source, customTime) {
        console.log(
          "addLogEntry called:",
          message.substring(0, 50) + "...",
          "type:",
          type
        );
        console.trace(); // This will show WHERE it was called from

        const logContainer = document.getElementById("protocolLog");
        const placeholder = logContainer.querySelector(".log-placeholder");

        if (placeholder) {
          placeholder.remove();
        }

        const entry = document.createElement("div");
        entry.className = "log-entry " + (type || "general");

        let timestamp, operator;

        if (customTime) {
          timestamp = customTime;
          operator = "";
        } else {
          timestamp =
            new Date().toLocaleTimeString("en-US", {
              hour12: false,
              timeZone: "America/Denver",
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            }) + " MST";
          operator = " | Op 417";
        }

        // Format different log types with better structure
        if (source) {
          // System logs (alert sequence) - timestamp on separate line
          entry.innerHTML =
            "<div>" +
            '<div class="log-source"><strong>' +
            source +
            "</strong></div>" +
            '<div class="log-timestamp" style="font-weight: bold; color: #333; margin-bottom: 5px;">2025-08-04 ' +
            timestamp +
            "</div>" +
            '<div class="log-content">' +
            formatLogMessage(message, type) +
            "</div>" +
            "</div>";
        } else {
          // Operator logs - with larger Op 417 text
          entry.innerHTML =
            '<div class="log-header">' +
            '<span class="log-timestamp">[' +
            timestamp +
            "]</span>" +
            '<div class="log-operator" style="font-size: 0.9em;">Op 417</div>' +
            "</div>" +
            '<div class="log-content">' +
            formatLogMessage(message, type) +
            "</div>";
        }

        logContainer.insertBefore(entry, logContainer.firstChild); // This adds to top
      }

      function formatLogMessage(message, type) {
        const hasYesDispatchHeader =
          /Called dispatch(?:, spoke to)?/i.test(message) &&
          /Dispatched\s.+\s to the following location:/i.test(message);
        const hasOldDispatchedHeader =
          /Dispatched\s.+\s to the following location:/i.test(message);
        const noDispatch = /Unable to dispatch/i.test(message);

        const isCoords = (line) => /^(\bGPS\s+)?Coordinates:/i.test(line);

        // --- YES DISPATCH (new/old headers) ---
        if (hasYesDispatchHeader || hasOldDispatchedHeader) {
          const lines = message
            .split("\n")
            .map((l) => l.trim())
            .filter(Boolean);
          const mainLine = lines[0];

          let formatted = `<div class="dispatch-summary" style="font-weight: normal; color: inherit;">📍 ${mainLine}</div>`;

          lines.slice(1).forEach((line) => {
            if (!line) return;

            if (
              /^Last Known Location\b/i.test(line) ||
              /^Last Known Location:/i.test(line)
            )
              formatted += `<div class="location-info">📍 ${line}</div>`;
            else if (/^Address:/i.test(line))
              formatted += `<div class="location-info">📍 ${line}</div>`;
            else if (isCoords(line))
              formatted += `<div class="coordinates">🗺️ ${line}</div>`;
            else if (/^Speed:/i.test(line))
              formatted += `<div class="dispatch-detail">${line}</div>`;
            else if (/^Last Location Date\/Time:/i.test(line))
              formatted += `<div class="dispatch-detail">${line}</div>`;
            else if (/^Device Status\b/i.test(line))
              formatted += `<div class="device-status">📱 ${line}</div>`;
            else if (/^Last Communication:/i.test(line))
              formatted += `<div class="device-status">${line}</div>`;
            else if (/^Battery( Level)?:/i.test(line))
              formatted += `<div class="device-stats">🔋 ${line}</div>`;
            else if (/^Signal( Strength)?:/i.test(line))
              formatted += `<div class="device-stats">🔋 ${line}</div>`;
            else if (/Waiting/i.test(line))
              formatted += `<div class="dispatch-detail">⏰ ${line}</div>`;
            else formatted += `<div class="dispatch-detail">${line}</div>`;
          });

          return formatted;
        }

        // --- NO DISPATCH ---
        if (noDispatch) {
          const lines = message
            .split("\n")
            .map((l) => l.trim())
            .filter(Boolean);
          const mainLine = lines[0];

          let formatted = `<div class="dispatch-summary" style="color: #dc3545; font-weight: bold;">${mainLine}</div>`;

          lines.slice(1).forEach((line) => {
            if (!line) return;

            if (
              /^Last Known Location\b/i.test(line) ||
              /^Last Known Location:/i.test(line)
            )
              formatted += `<div class="location-info">📍 ${line}</div>`;
            else if (/^Address:/i.test(line))
              formatted += `<div class="location-info">📍 ${line}</div>`;
            else if (isCoords(line))
              formatted += `<div class="coordinates">🗺️ ${line}</div>`;
            else if (/^Speed:/i.test(line))
              formatted += `<div class="dispatch-detail">${line}</div>`;
            else if (/^Last Location Date\/Time:/i.test(line))
              formatted += `<div class="dispatch-detail">${line}</div>`;
            else if (/^Last Communication:/i.test(line))
              formatted += `<div class="device-status">${line}</div>`;
            else if (/^Battery( Level)?:/i.test(line))
              formatted += `<div class="device-stats">🔋 ${line}</div>`;
            else if (/^Signal( Strength)?:/i.test(line))
              formatted += `<div class="device-stats">🔋 ${line}</div>`;
            else if (/Repeating STEPS/i.test(line)) {
              const clean = line.replace(/^🔄\s*/, ""); // avoid double icon
              formatted += `<div class="protocol-reset" style="color: #856404; font-weight: bold;">🔄 ${clean}</div>`;
            } else if (/Waiting/i.test(line))
              formatted += `<div class="dispatch-detail">⏰ ${line}</div>`;
            else formatted += `<div class="dispatch-detail">${line}</div>`;
          });

          return formatted;
        }

        // --- OLD LONG DISPATCH (fallback, generalized) ---
        if (/Dispatched\s.+\s to the following location:/i.test(message)) {
          const parts = message.split(
            /(?=Last Known Location|Coordinates:|Speed:|Last Location|Device Status|Battery:|Signal:)/
          );
          let formatted =
            '<div class="dispatch-summary">📍 <strong>Emergency Services Dispatched</strong></div>';

          parts.forEach((part) => {
            const p = part.trim();
            if (!p) return;

            if (p.includes("Last Known Location"))
              formatted += `<div class="location-info">📍 ${p}</div>`;
            else if (/^(\bGPS\s+)?Coordinates:/i.test(p))
              formatted += `<div class="coordinates">🗺️ ${p}</div>`;
            else if (p.startsWith("Device Status"))
              formatted += `<div class="device-status">📱 ${p}</div>`;
            else if (p.startsWith("Battery:") || p.startsWith("Signal:"))
              formatted += `<div class="device-stats">🔋 ${p}</div>`;
            else formatted += `<div class="dispatch-detail">${p}</div>`;
          });
          return formatted;
        }

        // --- Timers ---
        if (message.toLowerCase().includes("timer")) {
          return '<div class="timer-action">⏰ ' + message + "</div>";
        }

        // --- Step messages ---
        if (/^Step\s/i.test(message)) {
          return message;
        }

        // --- Default ---
        return message;
      }

      function getActionIcon(action) {
        const icons = {
          "call-device": "📞",
          "message-device": "📱",
          "call-user": "📞",
          "call-emergency-contacts": "👥",
          dispatch: "🚑",
          "Dispatch EMS": "🚑",
          "call-device": "📞",
          "Immediate Dispatch": "🚨",
          "Conditional Dispatch": "⚠️",
        };
        return icons[action] || "▶️";
      }

      function formatButtonText() {
        const buttons = document.querySelectorAll("button");
        buttons.forEach((btn) => {
          if (btn.textContent.includes("call-device")) {
            btn.textContent = btn.textContent.replace(
              "call-device",
              "Call device"
            );
          }
          if (btn.textContent.includes("message-device")) {
            btn.textContent = btn.textContent.replace(
              "message-device",
              "Message device"
            );
          }
          if (btn.textContent.includes("call-user")) {
            btn.textContent = btn.textContent.replace("call-user", "Call user");
          }
        });
      }

      // Pulls Gas Type, Level, and the current reading from the Gas Readings (Live) panel
      function getGasSnapshotFromPanel() {
        try {
          const panel =
            Array.from(document.querySelectorAll("*")).find((el) =>
              /Gas Readings\s*\(Live\)/i.test(el.textContent)
            ) || null;
          if (!panel) return "";

          const prettyGas = (s) => {
            if (!s) return "";
            const t = String(s).toLowerCase();
            if (t.includes("h2s") || t.includes("h₂s")) return "H₂S";
            if (t.includes("o2") || t.includes("o₂")) return "O₂";
            if (t.includes("co")) return "CO";
            if (t.includes("lel")) return "LEL";
            return s.toUpperCase();
          };
          const toKey = (p) =>
            String(p).toLowerCase().replace("₂", "2").replace(/\s+/g, "");

          // Prefer the gas chosen by normalization (if present)
          const normKey = (() => {
            try {
              const k = Object.keys(
                window.currentAlert?.gasNormalization?.targetLevels || {}
              )[0];
              return k ? k.toLowerCase().replace("₂", "2") : "";
            } catch {
              return "";
            }
          })();

          let primaryGas =
            (normKey && prettyGas(normKey)) ||
            prettyGas(window.currentAlert?.gasType) ||
            prettyGas(
              (panel.textContent.match(/Alert Type:\s*.*\(([^)]+)\)/i) || [
                ,
                "",
              ])[1]
            ) ||
            "H₂S";

          // Look for the matching ".gas-reading" (emoji-safe). Prefer one with a pill; else last match.
          const readings = Array.from(panel.querySelectorAll(".gas-reading"));
          const candidates = readings.filter((el) => {
            const txt = (el.textContent || "").trim().replace(/^[^\w]+/, "");
            return new RegExp(`^${primaryGas}\\s*:\\s*`, "i").test(txt);
          });
          const rowEl =
            candidates.find((el) =>
              el.querySelector(".gas-status, .status-pill")
            ) ||
            candidates[candidates.length - 1] ||
            null;

          const key = toKey(primaryGas);
          const valEl = rowEl ? rowEl.querySelector(`#${key}-value`) : null;
          const pillEl = rowEl ? rowEl.querySelector(`#${key}-status`) : null;

          // Reading (value + unit)
          let readingStr = "";
          if (valEl) {
            const raw = (valEl.textContent || "").trim();
            const num = parseFloat(raw);
            const unitMatch = raw.match(/([%a-zA-Z/]+)\s*$/);
            const inferredUnit =
              key === "o2" ? " %vol" : key === "lel" ? " %LEL" : " ppm";
            const unit = unitMatch ? ` ${unitMatch[1]}` : inferredUnit;
            readingStr = isNaN(num)
              ? `${primaryGas}: —`
              : `${primaryGas}: ${num.toFixed(2)}${unit}`;
          } else if (rowEl) {
            const m = (rowEl.textContent || "").match(
              /:\s*([0-9.]+)\s*([%a-zA-Z/]+)\b/i
            );
            readingStr = m
              ? `${primaryGas}: ${Number(m[1]).toFixed(2)} ${m[2]}`
              : `${primaryGas}: —`;
          } else {
            readingStr = `${primaryGas}: —`;
          }

          // Level
          const levelTokens = [
            "HIGH",
            "NORMAL",
            "LOW",
            "ELEVATED",
            "CRITICAL",
            "ALARM",
          ];
          const levelFromIds = (pillEl ? pillEl.textContent || "" : "")
            .trim()
            .toUpperCase();
          const levelInRow = rowEl
            ? levelTokens.find((tok) =>
                (rowEl.textContent || "").toUpperCase().includes(tok)
              ) || ""
            : "";
          const level = levelFromIds || levelInRow || "—";

          return `Gas Type: ${primaryGas}\nGas Level: ${level}\nGas Reading: ${readingStr}`;
        } catch (e) {
          console.warn("getGasSnapshotFromPanel failed:", e);
          return "";
        }
      }

      function getStepLabel(stepId) {
        const parts = stepId.split("-");
        if (parts.length === 2) {
          return `Step ${parts[1]}`; // "step-3" → "Step 3"
        } else if (parts.length === 3) {
          return `Step ${parts[1]}.${parts[2]}`; // "step-4-1" → "Step 4.1"
        }
        return stepId; // fallback
      }

      function loadProtocolSteps(protocolConfig, userConfig) {
        let protocolHTML =
          '<div style="margin-bottom: 20px;"><h4 style="color: #1565c0; margin: 0 0 10px 0;">📋 ' +
          protocolConfig.name +
          '</h4><p style="color: #666; font-size: 0.9em; margin: 0;">Showing only relevant steps for this alert type</p></div>';

        protocolConfig.steps.forEach(function (step, index) {
          const isFirst = index === 0;
          const isDispatchStep = step.action === "dispatch";

          // Build step classes - add dispatch-step class for dispatch steps
          let stepClasses = "step";
          if (isFirst || isDispatchStep) stepClasses += " active";
          if (isDispatchStep) stepClasses += " dispatch-step";

          // Open main step div
          protocolHTML +=
            '<div class="' +
            stepClasses +
            '" id="' +
            step.id +
            '">' +
            '<div class="step-header">' +
            '<h4 class="step-title">✅ STEP ' +
            (index + 1) +
            ": " +
            step.title +
            "</h4>" +
            '<span class="status-badge ' +
            (isFirst || step.action === "dispatch" ? "active" : "") +
            '" id="' +
            step.id +
            '-status">' +
            (isFirst || step.action === "dispatch" ? "Active" : "Pending") +
            "</span>" +
            "</div>";

          // Add contact info for relevant steps
          if (step.id === "step-3" || step.id === "step-2") {
            // Only show user contact for "Call User" actions
            if (step.action === "call-user") {
              protocolHTML +=
                '<div class="contact-info">' +
                "<strong>👤 " +
                userConfig.name +
                "</strong> 📞 " +
                userConfig.mobile +
                "</div>";
            }
          }

          // Handle Emergency Contacts
          if (step.action === "call-emergency-contacts") {
            const userKey = currentAlert.user;
            const emergencyContacts = AlertDataManager.usersData[userKey]
              ? AlertDataManager.usersData[userKey].emergencyContacts
              : [];

            // Add individual EC sections as sub-steps
            emergencyContacts.forEach(function (contact, index) {
              const contactStepId = step.id + "-" + (index + 1);

              protocolHTML +=
                '<div class="sub-step" id="' +
                contactStepId +
                '">' +
                '<div class="step-header">' +
                '<h5 class="step-title">📞 Call ' +
                contact.name +
                " at " +
                contact.phone +
                "</h5>" +
                '<span class="status-badge" id="' +
                contactStepId +
                '-status">Pending</span>' +
                "</div>" +
                '<div class="contact-info">' +
                "<strong>👤 " +
                contact.name +
                "</strong> 📞 " +
                contact.phone +
                " 🏷️ " +
                contact.role +
                "</div>" +
                '<button class="btn btn-primary" onclick="startStep(\'' +
                contactStepId +
                "')\" disabled>" +
                "📞 Call Emergency Contact" +
                "</button>" +
                '<div class="step-outcome" id="' +
                contactStepId +
                '-outcome" style="display: none; margin-top: 15px;">' +
                '<select id="' +
                contactStepId +
                '-select" onchange="autoPopulateNote(\'' +
                contactStepId +
                '\')" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
                '<option value="">Select outcome</option>' +
                '<option value="confirmed-ok">Confirmed user is okay</option>' +
                '<option value="ec-callback">Emergency contact called in and confirmed user is okay</option>' +
                '<option value="user-callback">User called in. Confirmed they are okay</option>' +
                '<option value="ec-callback-30min-outbound">EC will check on user and call back within 30 minutes</option>' +
                '<option value="ec-callback-30min">EC called in, will check on user and call back within 30 minutes</option>' +
                '<option value="no-answer-voicemail">No answer, left voicemail</option>' +
                '<option value="no-answer-unable">No answer, unable to leave voicemail</option>' +
                '<option value="wrong-number">Wrong number</option>' +
                '<option value="unable-to-connect">Unable to connect</option>' +
                "</select>" +
                '<textarea id="' +
                contactStepId +
                '-note" placeholder="Document the result..." style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 8px; box-sizing: border-box;" oninput="validatePostButton(\'' +
                contactStepId +
                "')\"></textarea>" +
                '<button class="btn btn-secondary" onclick="postNote(\'' +
                contactStepId +
                '\')" style="margin-top: 8px;" disabled id="' +
                contactStepId +
                '-post-btn">✅ Post Note</button>' +
                "</div>" +
                "</div>";
            });

            protocolHTML +=
              '<div style="margin: 15px 0; padding: 12px; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px; font-size: 0.9em; color: #1565c0; font-weight: 500;">' +
              "📍 If valid location not available, repeat STEPS 1, 2, 3 & 4 until someone is reached." +
              "</div>";

            // Close main step div
            protocolHTML += "</div>";
            return;
          }

          // Handle Combined Device/User Call
          if (step.action === "combined-device-user-call") {
            // Add individual call sub-steps
            step.subSteps.forEach(function (subStep, index) {
              const subStepId = step.id + "-" + (index + 1);

              protocolHTML +=
                '<div class="sub-step" id="' +
                subStepId +
                '">' +
                '<div class="step-header">' +
                '<h5 class="step-title">📞 ' +
                subStep.title +
                "</h5>" +
                '<span class="status-badge" id="' +
                subStepId +
                '-status">Pending</span>' +
                "</div>" +
                '<button class="btn btn-primary" onclick="startStep(\'' +
                subStepId +
                "')\" " +
                (index === 0 ? "" : "disabled") +
                ">" +
                getActionIcon(subStep.action) +
                " " +
                subStep.action +
                "</button>" +
                '<div class="step-outcome" id="' +
                subStepId +
                '-outcome" style="display: none; margin-top: 15px;">';

              // Add appropriate dropdown based on sub-step action
              if (subStep.action === "call-device") {
                protocolHTML +=
                  '<select id="' +
                  subStepId +
                  '-select" onchange="autoPopulateFromDropdown(\'' +
                  subStepId +
                  '\')" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
                  '<option value="">Select outcome</option>' +
                  '<option value="confirmed-ok">Spoke with ' +
                  userConfig.name +
                  ". Confirmed they are okay. Resolving alert.</option>" +
                  '<option value="user-callback">User called in. Confirmed they are okay</option>' +
                  '<option value="no-answer">No answer.</option>' +
                  '<option value="unable-to-call">Unable to call, device offline.</option>' +
                  "</select>";
              } else if (subStep.action === "call-user") {
                protocolHTML +=
                  '<select id="' +
                  subStepId +
                  '-select" onchange="autoPopulateFromDropdown(\'' +
                  subStepId +
                  '\')" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
                  '<option value="">Select outcome</option>' +
                  '<option value="confirmed-ok">Spoke with ' +
                  userConfig.name +
                  ", confirmed they are okay</option>" +
                  '<option value="no-answer-voicemail">No answer. Left voicemail</option>' +
                  '<option value="no-answer-unable-voicemail">No answer. Unable to leave voicemail</option>' +
                  '<option value="unable-to-connect">Unable to connect</option>' +
                  "</select>";
              }

              protocolHTML +=
                '<textarea id="' +
                subStepId +
                '-note" placeholder="Document the result..." style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 8px; box-sizing: border-box;" oninput="validatePostButton(\'' +
                subStepId +
                "')\"></textarea>" +
                '<button class="btn btn-secondary" onclick="postNote(\'' +
                subStepId +
                '\')" style="margin-top: 8px;" disabled id="' +
                subStepId +
                '-post-btn">✅ Post Note</button>' +
                "</div>" +
                "</div>";
            });

            // Close main step div
            protocolHTML += "</div>";
            return;
          }

          // Handle Dispatch Steps
          if (step.action === "dispatch") {
            protocolHTML +=
              '<div class="step-outcome" id="' +
              step.id +
              '-outcome" style="display: block; margin-top: 15px;">' +
              '<label for="dispatch-decision" style="display: block; margin-bottom: 8px; font-weight: bold;">Dispatch conditions met?</label>' +
              '<select id="dispatch-decision" onchange="handleDispatchDecision(\'' +
              step.id +
              '\')" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 15px;">' +
              '<option value="">-- System will evaluate --</option>' +
              '<option value="yes">Yes</option>' +
              '<option value="no">No</option>' +
              "</select>" +
              '<div id="service-type-container" style="display: none; margin-bottom: 15px;">' +
              '<label for="dispatch" style="display: block; font-weight: bold; margin-bottom: 8px; color: #333;">Dispatch Service Type:</label>' +
              '<select id="dispatch" onchange="autoPopulateDispatchNote(\'' +
              step.id +
              '\')" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 12px; font-size: 0.9em;">' +
              '<option value="">-- Select Service --</option>' +
              '<option value="Emergency Medical Services (EMS)">Emergency Medical Services (EMS)</option>' +
              '<option value="Police">Police</option>' +
              '<option value="Fire Department">Fire Department</option>' +
              '<option value="EMS and Police">EMS and Police</option>' +
              '<option value="EMS and Fire">EMS and Fire</option>' +
              '<option value="Police and Fire">Police and Fire</option>' +
              '<option value="EMS, Police and Fire">EMS, Police and Fire</option>' +
              "</select>" +
              "</div>" +
              '<div id="skip-reason-container" style="display: none; margin-bottom: 15px;">' +
              '<label for="skip-reason" style="display: block; font-weight: bold; margin-bottom: 8px; color: #856404;">Unmet Dispatch Condition:</label>' +
              '<select id="skip-reason" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 8px;">' +
              '<option value="">-- System will determine --</option>' +
              '<option value="gas-normalized">Gas levels back to normal</option>' +
              '<option value="device-offline">Device offline (last comm > 30 min, battery ≤ 10%, or signal ≤ 10%)</option>' +
              '<option value="location-stale">Location not valid or current</option>' +
              '<option value="device-moving">Device not stationary (≥ 5 km/h)</option>' +
              "</select>" +
              "</div>" +
              '<textarea id="' +
              step.id +
              '-note" placeholder="Document the dispatch decision..." style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 8px; box-sizing: border-box;" oninput="validatePostButton(\'' +
              step.id +
              "')\"></textarea>" +
              '<button class="btn btn-secondary" onclick="postNote(\'' +
              step.id +
              '\')" style="margin-top: 8px;" disabled id="' +
              step.id +
              '-post-btn">✅ Post Note</button>' +
              "</div>" +
              '<label for="' +
              '<div style="margin: 15px 0; padding: 12px; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px; font-size: 0.9em; color: #1565c0; font-weight: 500;">' +
              "📍 If valid location not available, repeat STEPS 1, 2, 3 & 4 until someone is reached." +
              "</div>";

            // Close main step div
            protocolHTML += "</div>";
            return;
          }

          // Standard processing for other steps
          protocolHTML +=
            '<button class="btn btn-primary" onclick="startStep(\'' +
            step.id +
            "')\" " +
            (!isFirst ? "disabled" : "") +
            ">" +
            getActionIcon(step.action) +
            " " +
            step.action +
            "</button>";

          // Step outcome section
          protocolHTML +=
            '<div class="step-outcome" id="' +
            step.id +
            '-outcome" style="display: none; margin-top: 15px;">';

          // Timer info
          if (step.timer) {
            protocolHTML +=
              '<div style="background: #fff3cd; padding: 8px; border-radius: 4px; margin: 10px 0; font-size: 0.85em;">' +
              "⏱️ Timer: " +
              Math.floor(step.timer / 60) +
              " minutes" +
              "</div>";
          }

          // Outcome dropdown
          protocolHTML +=
            '<select id="' +
            step.id +
            '-select" onchange="autoPopulateFromDropdown(\'' +
            step.id +
            "'); validatePostButton('" +
            step.id +
            '\')" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
            '<option value="">Select outcome</option>';

          // Action-based dropdown options
          if (step.action === "call-device") {
            protocolHTML +=
              '<option value="confirmed-ok">Spoke with ' +
              userConfig.name +
              ". Confirmed they are okay. Resolving alert.</option>" +
              '<option value="user-callback">User called in. Confirmed they are okay</option>' +
              '<option value="no-answer">No answer.</option>' +
              '<option value="unable-to-call">Unable to call, device offline.</option>';
          } else if (step.action === "message-device") {
            protocolHTML +=
              '<option value="no-response">No response</option>' +
              '<option value="unable-to-send">Unable to send text message, device offline</option>' +
              '<option value="device-no">Received "No" - User confirmed okay</option>' +
              '<option value="issue-resolved">Received "Issue resolved" - User confirmed okay</option>' +
              '<option value="false-alarm">Received "False alarm" - User confirmed okay</option>' +
              '<option value="understood">Received "Understood" - User confirmed okay</option>' +
              '<option value="device-yes">Received "Yes" - User confirmed okay</option>' +
              '<option value="send-help">Received "Send help" - Immediate assistance requested</option>';
          } else if (step.action === "call-user") {
            protocolHTML +=
              '<option value="confirmed-ok">Spoke with ' +
              userConfig.name +
              ", confirmed they are okay</option>" +
              '<option value="ec-callback">Emergency contact called in and confirmed user is okay</option>' +
              '<option value="user-callback">User called in. Confirmed they are okay</option>' +
              '<option value="ec-callback-30min">EC called in, will check on user and call back within 30 minutes</option>' +
              '<option value="no-answer-voicemail">No answer. Left voicemail</option>' +
              '<option value="no-answer-already-left">No answer. Voicemail had already been left</option>' +
              '<option value="no-answer-mailbox-full">No answer. Unable to leave voicemail, mailbox full</option>' +
              '<option value="no-answer-unable-voicemail">No answer. Unable to leave voicemail</option>' +
              '<option value="no-answer-mailbox-not-setup">No answer. Unable to leave voicemail, mailbox not set up yet</option>' +
              '<option value="no-phone-number">Unable to call, user has no phone number assigned</option>' +
              '<option value="number-disconnected">Number has been changed, disconnected or no longer in service</option>' +
              '<option value="unable-to-connect">Unable to connect</option>';
          } else {
            protocolHTML +=
              '<option value="completed">Action completed</option>' +
              '<option value="no-answer">No answer</option>';
          }

          protocolHTML += "</select>";

          // Note textarea
          protocolHTML +=
            '<textarea id="' +
            step.id +
            '-note" placeholder="Document the result..." ' +
            'style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 8px; box-sizing: border-box;" ' +
            "oninput=\"validatePostButton('" +
            step.id +
            "')\"></textarea>";

          // Post Note button
          protocolHTML +=
            '<button class="btn btn-secondary" onclick="postNote(\'' +
            step.id +
            '\')" style="margin-top: 8px;" disabled id="' +
            step.id +
            '-post-btn">✅ Post Note</button>' +
            "</div>";

          // Close main step div
          protocolHTML += "</div>";
        });

        // Resolution Section
        protocolHTML +=
          '<div class="resolution-section">' +
          '<div class="step-header">' +
          "<h3>✅ RESOLUTION</h3>" +
          '<span class="status-badge" id="resolution-status">Pending</span>' +
          "</div>" +
          '<select id="resolution-reason" style="width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
          '<option value="">-- Select reason --</option>' +
          '<option value="false-alert-without-dispatch">False alert without dispatch</option>' +
          '<option value="false-alert-with-dispatch">False alert with dispatch</option>' +
          '<option value="incident-without-dispatch">Incident without dispatch</option>' +
          '<option value="incident-with-dispatch">Incident with dispatch</option>' +
          "</select>" +
          '<div class="resolution-buttons">' +
          '<button class="btn btn-danger" onclick="resolveAlert()">✅ Resolve Alert</button>' +
          '<button class="btn btn-secondary" onclick="cancelResolution()">❌ Cancel Resolution</button>' +
          "</div>" +
          "</div>";

        document.getElementById("protocol-content").innerHTML = protocolHTML;
      }

      function autoPopulateNote(contactStepId) {
        const select = document.getElementById(contactStepId + "-select");
        const note = document.getElementById(contactStepId + "-note");

        if (!select || !note) return;

        const selectedValue = select.value;
        if (!selectedValue) return;

        const ecIndex = parseInt(contactStepId.split("-")[2]) - 1;
        const userKey = currentAlert.user;
        const contact =
          AlertDataManager.usersData[userKey].emergencyContacts[ecIndex];

        let noteText = "";
        let shouldScrollToResolution = false;

        // GROUP 1: RESOLUTION OUTCOMES
        if (selectedValue === "confirmed-ok") {
          noteText = "Confirmed user is okay and advised to resolve alert";
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback") {
          noteText = "Emergency contact called in and confirmed user is okay";
          shouldScrollToResolution = true;
        } else if (selectedValue === "user-callback") {
          noteText = "User called in. Confirmed they are okay";
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback-30min") {
          noteText =
            "Emergency contact called in, will check on user and call back within 30 minutes.";
          // Should start 30-min timer

          // GROUP 2: CONTINUE PROTOCOL OUTCOMES
        } else if (selectedValue === "no-answer-voicemail") {
          noteText = `Called ${contact.name} at ${contact.phone}. No answer, left voicemail`;
        } else if (selectedValue === "no-answer-unable") {
          noteText = `Called ${contact.name} at ${contact.phone}. No answer, unable to leave voicemail`;
        } else if (selectedValue === "wrong-number") {
          noteText = `Called ${contact.name} at ${contact.phone}. Wrong number`;
        } else if (selectedValue === "unable-to-connect") {
          noteText = `Called ${contact.name} at ${contact.phone}. Unable to connect`;
        } else if (selectedValue === "ec-callback-30min-outbound") {
          noteText = `Called ${contact.name} at ${contact.phone}. EC will check on user and call back within 30 minutes`;
        }

        if (noteText) {
          note.value = noteText;
          validatePostButton(contactStepId);
        }
      }

      function updateGasReadings(alertType) {
        const gasData = gasReadingsData[alertType] || gasReadingsData.default;

        Object.keys(gasData).forEach(function (gas) {
          const reading = gasData[gas];
          const valueElement = document.getElementById(gas + "-value");
          const statusElement = document.getElementById(gas + "-status");
          const readingElement = document.getElementById(gas + "-reading");

          const unit =
            gas === "o2" ? " %vol" : gas === "lel" ? " %LEL" : " ppm";

          if (valueElement) {
            valueElement.textContent = reading.value.toFixed(2) + unit;
          }

          if (statusElement) {
            statusElement.textContent = reading.status;
            statusElement.className =
              "gas-status " + reading.status.toLowerCase();
          }

          if (readingElement) {
            const icon = reading.status === "HIGH" ? "🔴" : "🟢";
            const gasLabel =
              gas === "h2s" ? "H₂S" : gas === "o2" ? "O₂" : gas.toUpperCase();
            readingElement.querySelector("span").innerHTML =
              icon +
              " " +
              gasLabel +
              ': <span class="gas-value">' +
              reading.value.toFixed(2) +
              unit +
              "</span>";
          }
        });

        if (alertType !== "default") {
          document.getElementById("triggeredBy").style.display = "block";
          document.getElementById("lastUpdated").style.display = "block";
          document.getElementById("gas-timestamp").textContent =
            new Date().toLocaleTimeString() + " MDT";
        }
      }

      function updateGasDisplay() {
        const timestamp = new Date().toLocaleTimeString("en-US", {
          hour12: false,
          timeZone: "America/Denver",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        });

        const timestampElement = document.getElementById("gas-timestamp");
        if (timestampElement) {
          timestampElement.textContent = timestamp + " MDT";
        }
      }

      function startGasMonitoring() {
        updateGasDisplay();
        gasUpdateInterval = setInterval(() => {
          updateGasDisplay();
        }, 5000);
      }

      // ═══════════════════════════════════════════════════════════════
      // 🔄 EVENT HANDLERS & DEMO FUNCTIONS
      // ═══════════════════════════════════════════════════════════════

      function toggleDemoPanel() {
        document.getElementById("demo-panel").classList.toggle("show");
      }

      function toggleDemoSection(sectionId) {
        const section = document.getElementById(sectionId);
        section.classList.toggle("collapsed");
      }

      function loadAlert(alertType) {
        const alertConfig = AlertDataManager.alertTypesData[alertType];
        if (!alertConfig) {
          console.error(`Alert type ${alertType} not found`);
          return;
        }

        const userConfig = AlertDataManager.usersData[alertConfig.user];
        const protocolConfig = ProtocolFactory.getProtocolConfig(alertType);

        // Global state
        currentAlert = alertConfig;
        currentUser = userConfig;

        // Clear existing logs
        const logContainer = document.getElementById("protocolLog");
        if (logContainer) logContainer.innerHTML = "";

        // ---- Hydrate Connectivity Panel from deviceConditions (presence-safe) ----
        const dc = alertConfig.deviceConditions || {};
        const setText = (id, text) => {
          const el = document.getElementById(id);
          if (el && text != null) el.textContent = String(text);
        };

        // Battery, Signal, Speed — simple replacements
        if (typeof dc.battery === "number")
          setText("battery-level", `${dc.battery}%`);
        if (typeof dc.signal === "number")
          setText("signal-strength", `${dc.signal}%`);
        if (typeof dc.deviceSpeed === "number") {
          const v = Number.isFinite(dc.deviceSpeed) ? dc.deviceSpeed : 0;
          setText("device-speed", `${v.toFixed(1)} km/h`);
        }

        // Device status badge/text (if your DOM exposes one)
        const statusNode =
          document.querySelector("#device-connectivity-status") ||
          document.querySelector('[data-cy="connectivity-status"]');
        if (statusNode && dc.deviceStatus)
          statusNode.textContent = dc.deviceStatus;

        // Last Communication: keep any absolute time already in the DOM,
        // and replace/append the relative "(X min ago)" part from fixtures
        if (typeof dc.lastComm === "number") {
          const lastEl = document.getElementById("last-comm-time");
          if (lastEl) {
            const raw = (lastEl.textContent || "").trim();
            const rel = `${dc.lastComm} min ago`;
            if (/\([^)]*\)/.test(raw)) {
              // Replace existing parenthetical
              lastEl.textContent = raw.replace(/\([^)]*\)/, `(${rel})`);
            } else if (raw) {
              // Append parenthetical after existing absolute time
              lastEl.textContent = `${raw} (${rel})`;
            } else {
              // Fallback: just show relative
              lastEl.textContent = rel;
            }
          }
        }

        // Location timestamp: calculate from locationAge
        if (typeof dc.locationAge === "number") {
          const locationEl = document.getElementById("location-timestamp");
          if (locationEl) {
            const now = new Date();
            const locationTime = new Date(
              now.getTime() - dc.locationAge * 60 * 1000
            );
            const formattedTime =
              locationTime.toLocaleDateString("en-US", {
                month: "short",
                day: "2-digit",
                year: "numeric",
              }) +
              " at " +
              locationTime.toLocaleTimeString("en-US", {
                hour: "2-digit",
                minute: "2-digit",
                hour12: false,
              }) +
              " MDT";
            locationEl.textContent = formattedTime;
          }
        }

        // ---- Initialize UI ----
        addAlertSequenceLogs(userConfig);
        updateAlertHeader(alertConfig, userConfig);
        updateGasReadings(alertConfig.gasType || alertType);
        loadProtocolSteps(protocolConfig, userConfig);
        initializeAlert(alertConfig, userConfig);

        formatButtonText();

        document.getElementById("alert-header")?.classList.add("active");
        document.getElementById("demo-panel")?.classList.remove("show");

        // After loading protocol, set Step 1 as Active
        setTimeout(() => {
          const step1 = document.getElementById("step-1");
          const step1Status = document.getElementById("step-1-status");

          if (step1) {
            step1.classList.add("active");
            step1.style.opacity = "1";
            // Optional: Scroll Step 1 into view
            step1.scrollIntoView({ behavior: "smooth", block: "center" });
          }

          if (step1Status) {
            step1Status.textContent = "Active";
            step1Status.className = "status-badge active";
          }

          // Start/refresh dispatch UI now that panel is hydrated
          if (typeof initializeDispatchMonitoring === "function") {
            initializeDispatchMonitoring();
          }
          if (typeof silentlyUpdateDispatchConditions === "function") {
            silentlyUpdateDispatchConditions();
          }
        }, 100);
      }

      function loadAlertFromJSON(alertId) {
        if (!alertsFromJSON) {
          alert("JSON data not loaded yet");
          return;
        }

        const alertData = alertsFromJSON.find((alert) => alert.id === alertId);
        if (!alertData) {
          console.error(`Alert ID ${alertId} not found in JSON`);
          return;
        }

        // Convert JSON to expected format and load
        currentAlert = convertJSONToAlertFormat(alertData);
        currentUser = convertJSONToUserFormat(alertData);

        // REMOVE THIS EXTRA CLOSING BRACE: }

        // Clear existing logs
        const logContainer = document.getElementById("protocolLog");
        logContainer.innerHTML = "";

        // Initialize UI
        addAlertSequenceLogs(currentUser);
        updateAlertHeader(currentAlert, currentUser);
        updateGasReadings(currentAlert.gasType || "default");
        const protocolConfig = protocolsData[currentAlert.protocolFile];
        loadProtocolSteps(protocolConfig, currentUser);
        initializeAlert(currentAlert, currentUser);

        document.getElementById("alert-header").classList.add("active");
        document.getElementById("demo-panel").classList.remove("show");

        // Handle test scenarios
        handleTestScenario(currentAlert);
      } // FUNCTION SHOULD CLOSE HERE

      function convertJSONToAlertFormat(alertData) {
        return {
          id: alertData.id,
          displayName: alertData.alert_subtype,
          user: alertData.user.toLowerCase().replace(" ", "-"),
          protocolFile: getProtocolFileFromType(alertData.type),
          gasType: alertData.is_gas_alert
            ? alertData.gas_type.toLowerCase() + "-high"
            : "default",
          testType: alertData.testType || "legacy",
        };
      }

      function convertJSONToUserFormat(alertData) {
        return {
          id: alertData.employee_id,
          name: alertData.user,
          device: alertData.device_type + "-" + alertData.device_id,
          mobile: alertData.mobile,
          company: alertData.organization,
          work: alertData.work,
          home: alertData.home,
          emergencyContacts: alertData.emergency_contacts.map((contact) => ({
            name: contact.name,
            phone: contact.phone,
            role: contact.role,
          })),
        };
      }

      function getProtocolFileFromType(alertType) {
        const typeMap = {
          "Gas Alert": "gas-emergency-protocol",
          "Fall Detection": "fall-detection-protocol",
          "SOS Alert": "sos-protocol",
          "No Motion": "no-motion-protocol",
          "Check-In Alert": "check-in-protocol",
          "Message Alert": "no-motion-protocol",
        };
        return typeMap[alertType] || "gas-emergency-protocol";
      }

      function handleTestScenario(alertConfig) {
        const gasMessages = [
          "False alarm",
          "Issue resolved",
          "I'm OK",
          "No",
          "Yes",
          "Understood",
        ];
        const nonGasMessages = [
          "Issue resolved",
          "False alarm",
          "I'm OK",
          "No",
          "Yes",
          "Send help",
        ];
        const helpMessages = ["Send help", "I am stranded", "Hazard in area"];

        if (alertConfig.testType === "spontaneous") {
          setTimeout(() => {
            let messagePool =
              alertConfig.protocolFile === "gas-emergency-protocol"
                ? gasMessages
                : nonGasMessages;
            const randomMessage =
              messagePool[Math.floor(Math.random() * messagePool.length)];
            simulateDeviceResponse(randomMessage, false);
          }, 3000);
        } else if (alertConfig.testType === "immediate-help") {
          setTimeout(() => {
            const helpMessage =
              helpMessages[Math.floor(Math.random() * helpMessages.length)];
            simulateDeviceResponse(helpMessage, false);
          }, 0);
        } else if (alertConfig.testType === "legacy") {
          if (alertConfig.id === "gas-high-threshold") {
            setTimeout(() => {
              const randomMessage =
                gasMessages[Math.floor(Math.random() * gasMessages.length)];
              simulateDeviceResponse(randomMessage, false);
            }, 3000);
          }
        }
      }

      function clearAlert() {
        currentAlert = null;
        currentUser = null;
        dispatchMade = false;

        document.getElementById("alert-header").classList.remove("active");
        updateGasReadings("default");
        document.getElementById("triggeredBy").style.display = "none";
        document.getElementById("lastUpdated").style.display = "none";
        document.getElementById("protocolLog").innerHTML =
          '<div class="log-placeholder">No alert loaded. Use demo controls to load an alert type and begin protocol.</div>';
        document.getElementById("protocol-content").innerHTML =
          '<div class="protocol-placeholder"><div class="protocol-frame"><div class="placeholder-text">No protocol loaded</div><div class="placeholder-subtitle">Alert type will load the relevant emergency response protocol</div></div></div>';
        document.getElementById("demo-panel").classList.remove("show");
      }

      function addManualNote() {
        const noteText = document.getElementById("manual-notes").value.trim();

        console.log("Adding note:", noteText);
        addLogEntry(noteText, "general");
        document.getElementById("manual-notes").value = "";

        // Re-disable button after posting (like other steps)
        const button = document.querySelector(
          'button[onclick="addManualNote()"]'
        );
        if (button) {
          button.disabled = true;
          button.classList.add("btn-secondary");
          button.classList.remove("btn-success");
        }
      }

      function sendManualMessage() {
        const messageInput = document.getElementById("manual-message-input");
        const charCounter = document.getElementById("charCounter");
        const sendBtn = document.getElementById("sendMessageBtn");

        const msg = messageInput.value.trim();
        if (msg.length === 0 || msg.length > 32) return;

        console.log("Manual message sent:", msg);

        messageInput.value = "";
        charCounter.textContent = "32 characters remaining";
        sendBtn.disabled = true;
      }

      function receiveMessageFromDevice(text) {
        const messageList = document.getElementById("receivedMessages");
        if (!messageList) return;

        const li = document.createElement("li");
        li.classList.add("unread");
        li.textContent = text;
        messageList.prepend(li);

        setTimeout(() => li.classList.remove("unread"), 5000);
      }

      function splitIntoTwoLines(text) {
        return text; // Simple implementation
      }

      function triggerImmediateDispatch() {
        dispatchMade = true;
      }

      // Demo functions for testing
      window.simulateDeviceResponse = function (
        responseText,
        isResponse = false
      ) {
        return; // DISABLED for manual testing - remove this line to re-enable
        if (protocolState.deviceMessageReceived) return;

        protocolState.deviceMessageReceived = true;
        receiveMessageFromDevice(responseText);

        const clearResolutionMessages = [
          "Issue resolved",
          "False alarm",
          "I'm OK",
        ];
        const ambiguousMessages = ["No", "Yes", "Understood"];

        if (currentAlert && currentAlert.id === "gas-high-threshold") {
          const gasReading = getCurrentGasReading();
          let messageType = isResponse ? "reply message" : "message";
          let shouldResolve =
            !isGasLevelHigh() && clearResolutionMessages.includes(responseText);
          let isAmbiguous = ambiguousMessages.includes(responseText);

          if (shouldResolve) {
            addLogEntry(
              `📱 Received ${messageType} '${responseText}', confirming the user is okay. Gas readings back to normal levels. Resolving alert.`,
              "step"
            );
            addLogEntry(`📤 Sent "Noted. Resolving alert." to device`, "step");
          } else if (isAmbiguous) {
            addLogEntry(
              `📱 Received ${messageType} '${responseText}'. Ambiguous response. Proceed with protocol escalation.`,
              "step"
            );
          } else {
            if (clearResolutionMessages.includes(responseText)) {
              addLogEntry(
                `📱 Received ${messageType} '${responseText}', confirming the user is okay. Gas levels remain elevated.`,
                "step"
              );
            } else {
              addLogEntry(
                `📱 Received ${messageType} '${responseText}'.`,
                "step"
              );
            }
          }
        } else {
          let messageType = isResponse ? "reply message" : "message";
          let shouldResolve = clearResolutionMessages.includes(responseText);
          let isAmbiguous = ambiguousMessages.includes(responseText);

          if (shouldResolve) {
            addLogEntry(
              `📱 Received ${messageType} '${responseText}', confirming the user is okay. Resolving alert.`,
              "step"
            );
            addLogEntry(`📤 Sent "Noted. Resolving alert." to device`, "step");
          } else if (isAmbiguous) {
            addLogEntry(
              `📱 Received ${messageType} '${responseText}'. Ambiguous response. Proceed with protocol escalation.`,
              "step"
            );
          } else {
            addLogEntry(
              `📱 Received ${messageType} '${responseText}'.`,
              "step"
            );
          }
        }

        if (responseText === "Send help") {
          addLogEntry(
            `📱 REceived 'Send help' message from device user. Escalating to dispatch or as required by protocol.`,
            "general"
          );
          triggerImmediateDispatch();
        }
      };

      window.setGasLevel = function (gas, value) {
        const gasData =
          gasReadingsData[
            currentAlert ? currentAlert.gasType || currentAlert.id : "default"
          ] || gasReadingsData.default;
        if (gasData[gas]) {
          gasData[gas].value = value;
          gasData[gas].status = value >= 10 ? "HIGH" : "NORMAL";
          updateGasReadings(
            currentAlert ? currentAlert.gasType || currentAlert.id : "default"
          );
          console.log("Set " + gas.toUpperCase() + " to " + value);
        }
      };

      // Demo functions for testing device connectivity
      window.setDeviceOffline = function (reason = "battery") {
        DeviceConnectivity.setDeviceOfflineScenario(reason);
        console.log(`Device set to OFFLINE (reason: ${reason})`);
        console.log("Current status:", DeviceConnectivity.currentStatus);
      };

      window.setDeviceOnline = function () {
        DeviceConnectivity.setDeviceOnlineScenario();
        console.log("Device set to ONLINE");
        console.log("Current status:", DeviceConnectivity.currentStatus);
      };

      window.testBatteryDead = function () {
        setDeviceOffline("battery");
      };
      window.testSignalLost = function () {
        setDeviceOffline("signal");
      };
      window.testCommunicationTimeout = function () {
        setDeviceOffline("communication");
      };

      window.checkDeviceStatus = function () {
        const status = DeviceConnectivity.currentStatus;
        const isOnline = DeviceConnectivity.isDeviceOnline();
        console.log("=== DEVICE STATUS CHECK ===");
        console.log("Last Communication:", status.lastCommunication);
        console.log("Battery:", status.battery + "%");
        console.log("Signal:", status.signal + "%");
        console.log(
          "BlackLine Online Status:",
          isOnline ? "🟢 ONLINE" : "🔴 OFFLINE"
        );
        return isOnline;
      };

      // ═══════════════════════════════════════════════════════════════
      // 🚑 ENHANCED DISPATCH STEP MANAGEMENT
      // ═══════════════════════════════════════════════════════════════

      function generateDispatchProtocolLog(
        decision,
        reason,
        selectedService,
        stepId
      ) {
        const getStep = (sid) =>
          typeof getStepLabel === "function"
            ? getStepLabel(sid)
            : String(sid).replace(/^step-/, "Step ");
        const stepLabel = getStep(stepId);

        // DOM pulls
        const locationElement = document.getElementById("device-location");
        const coordinatesElement =
          document.getElementById("device-coordinates");
        const speedElement = document.getElementById("device-speed");
        const locationTimestamp = document.getElementById("location-timestamp");
        const lastCommElement = document.getElementById("last-comm-time");
        const batteryElement = document.getElementById("battery-level");
        const signalElement = document.getElementById("signal-strength");

        // Helpers
        const timeAgoSuffix = (dateTimeString) => {
          if (!dateTimeString) return "";
          // Accepts "Aug 02, 2025 at 15:28 MDT"
          const clean = String(dateTimeString)
            .replace(" at ", " ")
            .replace(/\s+\b[A-Z]{2,4}\b$/, "");
          const dt = new Date(clean);
          if (isNaN(dt)) return "";
          const diffMin = Math.floor((Date.now() - dt.getTime()) / 60000);
          if (diffMin < 1) return " (just now)";
          if (diffMin < 60)
            return ` (${diffMin} minute${diffMin === 1 ? "" : "s"} ago)`;
          const h = Math.floor(diffMin / 60);
          if (h < 24) return ` (${h} hour${h === 1 ? "" : "s"} ago)`;
          const d = Math.floor(h / 24);
          return ` (${d} day${d === 1 ? "" : "s"} ago)`;
        };

        // looser parser for "00:26 MDT" or "13:31 MDT"
        const timeAgoSuffixLoose = (text) => {
          if (!text) return "";
          const cleaned = String(text)
            .replace(
              /\s*\((?:just now|\d+\s+(?:minute|minutes|hour|hours|day|days)\s+ago)\)\s*$/i,
              ""
            )
            .replace(
              /\b(ACDT|ACST|ADT|AEDT|AEST|AKDT|AKST|AST|BST|CDT|CEST|CET|CLT|COT|CST|EDT|EEST|EET|EST|GMT|HKT|IST|JST|MDT|MST|MSK|NZDT|NZST|PDT|PET|PKT|PST|UTC|WET|WEST)\b/gi,
              ""
            )
            .trim();

          const looksLikeTimeOnly = /^\d{1,2}:\d{2}$/.test(cleaned);
          const compose = looksLikeTimeOnly
            ? `${new Date().toDateString()} ${cleaned}`
            : cleaned;

          const dt = new Date(compose);
          if (isNaN(dt)) return "";
          const diffMin = Math.floor((Date.now() - dt.getTime()) / 60000);
          if (diffMin < 1) return " (just now)";
          if (diffMin < 60)
            return ` (${diffMin} minute${diffMin === 1 ? "" : "s"} ago)`;
          const h = Math.floor(diffMin / 60);
          if (h < 24) return ` (${h} hour${h === 1 ? "" : "s"} ago)`;
          const d = Math.floor(h / 24);
          return ` (${d} day${d === 1 ? "" : "s"} ago)`;
        };

        // Header
        let logEntry = "";
        if (decision === "yes") {
          logEntry = `${stepLabel}: Called dispatch. Dispatched ${
            selectedService || "Emergency Services"
          } to the following location:`;
        } else {
          logEntry = `${stepLabel}: Unable to dispatch - ${reason}:`;
        }

        // Location block
        logEntry += `\n\nLast Known Location:`;
        if (locationElement)
          logEntry += `\nAddress: ${locationElement.textContent}`;
        if (coordinatesElement)
          logEntry += `\nGPS Coordinates: ${coordinatesElement.textContent}`;
        if (speedElement) logEntry += `\nSpeed: ${speedElement.textContent}`;
        if (locationTimestamp) {
          const ts = locationTimestamp.textContent;
          logEntry += `\nLast Location Date/Time: ${ts}${timeAgoSuffix(ts)}`;
        }

        // Device status block (always for YES; for NO include when likely relevant)
        const includeStatus =
          decision === "yes" ||
          /offline|location|moving/i.test(String(reason || ""));
        if (includeStatus) {
          logEntry += `\n\nDevice Status`;
          if (lastCommElement) {
            const lc = lastCommElement.textContent;
            logEntry += `\nLast Communication: ${lc}${timeAgoSuffixLoose(lc)}`;
          }
          if (batteryElement)
            logEntry += `\nBattery: ${batteryElement.textContent}`;
          if (signalElement)
            logEntry += `\nSignal: ${signalElement.textContent}`;
        }

        return logEntry;
      }

      function callDispatch() {
        // This function is called AFTER:
        // 1. "Call Dispatch" button clicked
        // 2. System evaluated conditions → "Yes"
        // 3. User selected services
        // 4. Now actually calling dispatch

        dispatchMade = true;

        // Get selected service from the correct dropdown ID (keep your current ID)
        const serviceDropdown = document.getElementById("dispatch");
        const selectedService = serviceDropdown ? serviceDropdown.value : "";

        // Remove popup alert - handle validation within UI
        if (!selectedService) {
          console.log(
            "No service selected, but proceeding with default service"
          );
          // Could add inline error message here instead of popup
        }

        // Use selected service or default to "Emergency Services"
        const serviceToDispatch = selectedService || "Emergency Services";

        // Find current dispatch step dynamically (keep your fallback)
        const currentDispatchStep =
          document
            .querySelector('.step.active [onclick*="callDispatch"]')
            ?.closest(".step")?.id || "step-5";

        // ✅ Build the comprehensive YES-dispatch log from the Connectivity Panel
        const logEntry = generateDispatchProtocolLog(
          "yes",
          "", // reason not used for YES
          serviceToDispatch,
          currentDispatchStep
        );
        addLogEntry(logEntry, "step");

        // Start 30-minute dispatch callback timer (label with chosen service)
        startGlobalTimer(
          currentDispatchStep,
          "Dispatch Callback",
          serviceToDispatch,
          1800
        );

        // Update UI to show dispatch completion (keep your call)
        updateDispatchUI();

        // Auto-update resolution (keep your logic)
        const resolutionSelect = document.getElementById("resolution-reason");
        if (resolutionSelect && !resolutionSelect.value) {
          const resolutionType = determineResolutionType(currentAlert);
          resolutionSelect.value = resolutionType;
        }
      }

      function handleDispatchDecision(stepId) {
        const decisionElement = document.getElementById("dispatch-decision");
        const serviceContainer = document.getElementById(
          "service-type-container"
        );
        const skipContainer = document.getElementById("skip-reason-container");
        const notesArea = document.getElementById(stepId + "-note"); // ← Now dynamic

        // Safety check - only proceed if elements exist
        if (!decisionElement || !serviceContainer || !skipContainer) {
          return;
        }

        const decision = decisionElement.value;

        if (decision === "yes") {
          serviceContainer.style.display = "block";
          skipContainer.style.display = "none";
          if (notesArea)
            notesArea.placeholder =
              "Document dispatch details and service response...";
        } else if (decision === "no") {
          serviceContainer.style.display = "none";
          skipContainer.style.display = "block";
          if (notesArea)
            notesArea.placeholder = "Document why dispatch was not required...";
        } else {
          serviceContainer.style.display = "none";
          skipContainer.style.display = "none";
          if (notesArea) notesArea.placeholder = "Document the result...";
        }
      }

      /**
       * Evaluate if dispatch should be recommended based on technical conditions
       */
      function evaluateDispatchConditions() {
        const conditions = {
          shouldDispatch: false,
          passingConditions: [],
          failingReasons: [],
          primarySkipReason: null,
        };

        // ── helpers (local only) ────────────────────────────────────────────────
        const toNum = (s) => {
          const m = String(s || "").match(/-?\d+(\.\d+)?/);
          return m ? Number(m[0]) : NaN;
        };

        const parseMins = (txt) => {
          const t = String(txt || "").toLowerCase();
          const m = t.match(/(\d+)\s*min/);
          if (m) return Number(m[1]);
          const h = t.match(/(\d+)\s*hour/);
          if (h) return Number(h[1]) * 60;
          const a = t.match(/(\d+).*ago/);
          return a ? Number(a[1]) : NaN;
        };

        // NEW: handles absolute timestamps like "Aug 02, 2025 at 15:28 MDT"
        const parseAbsMins = (txt) => {
          const raw = String(txt || "").trim();
          if (!raw) return NaN;
          const norm = raw
            .replace(" at ", " ")
            .replace(/\s([A-Z]{2,4})\.?$/, "");
          const d = new Date(norm);
          return isNaN(d.getTime())
            ? NaN
            : Math.floor((Date.now() - d.getTime()) / 60000);
        };

        // ── user confirmation check (triggers resolution flow) ──────────────────
        const userConfirmedOK =
          typeof checkIfUserConfirmedOK === "function" &&
          checkIfUserConfirmedOK();
        const ecConfirmedOK =
          typeof checkIfECConfirmedUserOK === "function" &&
          checkIfECConfirmedUserOK();

        // If user confirmed OK → trigger resolution flow (no dispatch needed)
        if (userConfirmedOK) {
          conditions.failingReasons.push("User confirmed they are okay");
          conditions.primarySkipReason = "user-confirmed-ok";
          conditions.shouldDispatch = false;
          return conditions; // Early exit → resolution flow
        }

        if (ecConfirmedOK) {
          conditions.failingReasons.push(
            "Emergency contact confirmed user is okay"
          );
          conditions.primarySkipReason = "ec-confirmed-ok";
          conditions.shouldDispatch = false;
          return conditions; // Early exit → resolution flow
        }

        // ── universal dispatch gates (technical readiness only) ─────────────────
        const CT = window.CONNECTIVITY_THRESHOLDS || {
          lastCommMins: 30,
          batteryPct: 10,
          signalPct: 10,
        };
        const LT =
          (window.TIMEOUTS &&
            Number(window.TIMEOUTS.LOCATION_MAX_AGE_MINUTES)) ||
          5; // minutes
        const MOV =
          (window.TIMEOUTS && Number(window.TIMEOUTS.MOVING_MAX_SPEED_KMH)) ||
          5; // km/h

        // Read Connectivity Panel
        const lastCommEl = document.getElementById("last-comm-time");
        const batteryEl = document.getElementById("battery-level");
        const signalEl = document.getElementById("signal-strength");
        const locTsEl = document.getElementById("location-timestamp");
        const speedEl = document.getElementById("device-speed");

        const minsLastComm = parseMins(lastCommEl?.textContent);
        const batt = toNum(batteryEl?.textContent);
        const signal = toNum(signalEl?.textContent);
        const minsLocAge = parseAbsMins(locTsEl?.textContent);
        const speedKph = toNum(speedEl?.textContent);

        // 1) device offline check
        let isOffline = false;
        const offlineBits = [];
        if (!Number.isNaN(minsLastComm) && minsLastComm > CT.lastCommMins) {
          isOffline = true;
          offlineBits.push(`last comm ${minsLastComm} min ago`);
        }
        if (!Number.isNaN(batt) && batt <= CT.batteryPct) {
          isOffline = true;
          offlineBits.push(`battery ${batt}%`);
        }
        if (!Number.isNaN(signal) && signal <= CT.signalPct) {
          isOffline = true;
          offlineBits.push(`signal ${signal}%`);
        }
        if (isOffline) {
          const pretty = offlineBits.length
            ? `device offline (${offlineBits.join(", ")})`
            : "device offline";
          conditions.failingReasons.push(pretty);
          conditions.primarySkipReason ||= "device-offline";
        }

        // 2) location not current check
        const isLocStale = !Number.isNaN(minsLocAge) && minsLocAge > LT;
        if (isLocStale) {
          let ageText;
          if (minsLocAge < 60) {
            ageText = `${minsLocAge} min old`;
          } else if (minsLocAge < 1440) {
            const hours = Math.floor(minsLocAge / 60);
            ageText = `${hours} hour${hours === 1 ? "" : "s"} old`;
          } else {
            const days = Math.floor(minsLocAge / 1440);
            ageText = `${days} day${days === 1 ? "" : "s"} old`;
          }

          conditions.failingReasons.push(`location not current (${ageText})`);
          conditions.primarySkipReason ||= "location-stale";
        }

        // 3) device not stationary check
        const isMoving = !Number.isNaN(speedKph) && speedKph > MOV;
        if (isMoving) {
          conditions.failingReasons.push(
            `device not stationary (speed ${speedKph} km/h)`
          );
          conditions.primarySkipReason ||= "device-moving";
        }

        // ── GAS POLICY (override when safe) ──────────────────────────────────────
        let anyGasDanger = false;
        let isGasNow = false;
        try {
          isGasNow =
            typeof isGasAlert === "function" ? isGasAlert(currentAlert) : false;
          if (isGasNow) {
            const U = (id) =>
              (document.getElementById(id)?.textContent || "").toUpperCase();
            const dangerO2 = /ENRICHED|DEPLETED/.test(U("o2-status"));
            const dangerOthers =
              /\bHIGH\b/.test(U("h2s-status")) ||
              /\bHIGH\b/.test(U("co-status")) ||
              /\bHIGH\b/.test(U("lel-status"));
            anyGasDanger = !!(dangerO2 || dangerOthers);
          }
        } catch (e) {
          console.warn("Gas rule check failed:", e);
        }

        // ── final technical readiness decision ──────────────────────────────────
        const connectivityOK = !isOffline;
        const locationOK = !isLocStale;
        const motionOK = !isMoving;

        // If this is a gas alert and gas is NOT dangerous anymore, force NO dispatch
        try {
          const isGas =
            typeof isGasAlert === "function" ? isGasAlert(currentAlert) : false;
          if (isGas && !anyGasDanger) {
            conditions.shouldDispatch = false;
            if (
              !conditions.failingReasons.includes(
                "Gas levels returned to normal"
              )
            ) {
              conditions.failingReasons.unshift(
                "Gas levels returned to normal"
              );
            }
            conditions.primarySkipReason ||= "gas-normalized";
            return conditions; // Early return
          }
        } catch {
          /* no-op */
        }

        // Suggest "Yes" if all technical conditions are met
        conditions.shouldDispatch = connectivityOK && locationOK && motionOK;

        // Add positive conditions for clarity
        if (connectivityOK) {
          conditions.passingConditions.push("Device connectivity OK");
        }
        if (locationOK) {
          conditions.passingConditions.push("Location data current");
        }
        if (motionOK) {
          conditions.passingConditions.push("Device stationary");
        }

        // For gas alerts, add gas status
        try {
          const isGas =
            typeof isGasAlert === "function" ? isGasAlert(currentAlert) : false;
          if (isGas && anyGasDanger) {
            if (
              !conditions.passingConditions.includes("Gas levels dangerous")
            ) {
              conditions.passingConditions.unshift("Gas levels dangerous");
            }
          }
        } catch {
          /* no-op */
        }

        return conditions;
      }

      function silentlyUpdateDispatchConditions() {
        const dispatchDropdown = document.getElementById("dispatch-decision");
        const unmetDropdown = document.getElementById("skip-reason");
        if (!dispatchDropdown) return;

        let conditions;
        try {
          conditions = evaluateDispatchConditions();
        } catch {
          conditions =
            typeof evaluateDispatchConditionsFromConnectivity === "function"
              ? evaluateDispatchConditionsFromConnectivity()
              : {
                  shouldDispatch: false,
                  failingReasons: [],
                  primarySkipReason: null,
                };
        }

        const newValue = conditions.shouldDispatch ? "yes" : "no";

        // Only do heavy UI updates when value actually changes
        if (dispatchDropdown.value !== newValue) {
          dispatchDropdown.value = newValue;

          const serviceContainer = document.getElementById(
            "service-type-container"
          );
          const skipContainer = document.getElementById(
            "skip-reason-container"
          );

          if (newValue === "yes") {
            if (serviceContainer) serviceContainer.style.display = "block";
            if (skipContainer) skipContainer.style.display = "none";
          } else {
            if (serviceContainer) serviceContainer.style.display = "none";
            if (skipContainer) skipContainer.style.display = "block";

            // --- auto-populate skip reason ----------------------------
            if (unmetDropdown) {
              const key = (conditions.primarySkipReason || "").toLowerCase();
              const firstFail = (
                conditions.failingReasons?.[0] || ""
              ).toLowerCase();

              // Pick the best-fit reason (now includes gas)
              let auto =
                key ||
                (firstFail.includes("gas level") ||
                firstFail.includes("gas-normal")
                  ? "gas-normalized"
                  : firstFail.includes("offline")
                  ? "device-offline"
                  : firstFail.includes("location")
                  ? "location-stale"
                  : firstFail.includes("moving")
                  ? "device-moving"
                  : "");

              if (auto) unmetDropdown.value = auto;

              // --- auto-populate note box (dynamic step detection) ---
              const dispatchStep = dispatchDropdown.closest(".step");
              const noteBox =
                dispatchStep?.querySelector("textarea") ||
                document.getElementById(dispatchStep?.id + "-note") ||
                document.querySelector(
                  "#skip-reason-container textarea, #service-type-container textarea"
                );

              if (noteBox) {
                if (unmetDropdown.value === "gas-normalized") {
                  // Build gas snapshot with timestamp
                  let block = "";
                  try {
                    block =
                      typeof getGasSnapshotFromPanel === "function"
                        ? getGasSnapshotFromPanel()
                        : "";
                    if (block) {
                      const now = new Date();
                      const ts =
                        typeof FORMATTERS?.timestampMST === "function"
                          ? FORMATTERS.timestampMST(now)
                          : new Intl.DateTimeFormat("en-US", {
                              timeZone: "America/Denver",
                              year: "numeric",
                              month: "2-digit",
                              day: "2-digit",
                              hour: "2-digit",
                              minute: "2-digit",
                              second: "2-digit",
                              hour12: false,
                            }).format(now) + " MDT";
                      block = block.replace(
                        /(Gas Reading:\s*[^\n]+)/i,
                        `$1 (${ts})`
                      );
                    }
                  } catch {}

                  noteBox.value =
                    "Gas levels back to normal." +
                    (block ? `\n\n${block}` : "");
                } else if (!noteBox.value.trim()) {
                  // Fallback: copy the selected reason label to notes
                  const label =
                    unmetDropdown.options[unmetDropdown.selectedIndex]?.text ||
                    "";
                  if (label) noteBox.value = label;
                }
              }
            }
          }

          // Notify any listeners and re-validate with dynamic step detection
          dispatchDropdown.dispatchEvent(
            new Event("change", { bubbles: true })
          );

          // Dynamic step detection for validation
          const dispatchStep = dispatchDropdown.closest(".step");
          const dispatchStepId = dispatchStep?.id;

          if (typeof validatePostButton === "function" && dispatchStepId) {
            validatePostButton(dispatchStepId);
          }
        } else {
          // Even if value didn't change, ensure dispatch button reflects current state
          const dispatchStep = dispatchDropdown.closest(".step");
          const dispatchStepId = dispatchStep?.id;

          if (
            newValue === "no" &&
            typeof validatePostButton === "function" &&
            dispatchStepId
          ) {
            validatePostButton(dispatchStepId);
          }
        }

        // --- color-coding (unchanged) --------------------------------
        if (dispatchDropdown.value === "yes") {
          dispatchDropdown.style.backgroundColor = "#d4edda";
          dispatchDropdown.style.borderColor = "#28a745";
          dispatchDropdown.style.color = "#155724";
          dispatchDropdown.style.borderWidth = "2px";
        } else if (dispatchDropdown.value === "no") {
          dispatchDropdown.style.backgroundColor = "#f8d7da";
          dispatchDropdown.style.borderColor = "#dc3545";
          dispatchDropdown.style.color = "#721c24";
          dispatchDropdown.style.borderWidth = "2px";
        } else {
          dispatchDropdown.style.backgroundColor = "#ffffff";
          dispatchDropdown.style.borderColor = "#ddd";
          dispatchDropdown.style.color = "#333";
          dispatchDropdown.style.borderWidth = "1px";
        }
      }

      function checkIfUserConfirmedOK() {
        // Check if any step had "confirmed OK" outcome
        return protocolState.completedSteps.some((stepId) => {
          const select = document.getElementById(stepId + "-select");
          return select && select.value === "confirmed-ok";
        });
      }

      function checkIfECConfirmedUserOK() {
        // Check Emergency Contacts step outcomes for EC confirmation
        const ecStepId = getEmergencyContactsStepId();
        if (!ecStepId) return false;

        const ecSelect = document.getElementById(ecStepId + "-select");
        return ecSelect && ecSelect.value === "confirmed-ok";
      }

      function generateDispatchNotes(conditions) {
        // Base header
        let notes = "Dispatch: Decision Analysis\n\n";

        // === Read live Connectivity Panel values (no external helpers) ===
        const lastCommEl = document.getElementById("last-comm-time");
        const batteryEl = document.getElementById("battery-level");
        const signalEl = document.getElementById("signal-strength");

        const num = (s) => {
          const m = String(s || "").match(/-?\d+(\.\d+)?/);
          return m ? Number(m[0]) : NaN;
        };
        const parseLastCommMins = (txt) => {
          const t = String(txt || "").toLowerCase();
          if (t.includes("min")) {
            const m = num(t);
            return Number.isNaN(m) ? NaN : m;
          }
          if (t.includes("hour")) {
            const h = num(t);
            return Number.isNaN(h) ? NaN : Math.round(h * 60);
          }
          if (t.includes("ago")) {
            const m = num(t);
            return Number.isNaN(m) ? NaN : m;
          }
          return NaN;
        };

        const lastCommTxt = lastCommEl?.textContent || "";
        const battTxt = batteryEl?.textContent || "";
        const sigTxt = signalEl?.textContent || "";

        const mins = parseLastCommMins(lastCommTxt); // "47 min ago" -> 47
        const batt = num(battTxt); // "7%" -> 7
        const signal = num(sigTxt); // "9%" -> 9

        // Build an inline, human-friendly offline detail from the panel
        const offlineParts = [];
        if (!Number.isNaN(mins)) offlineParts.push(`last comm ${mins} min ago`);
        if (!Number.isNaN(batt)) offlineParts.push(`battery ${batt}%`);
        if (!Number.isNaN(signal)) offlineParts.push(`signal ${signal}%`);
        const offlineDetail = offlineParts.length
          ? `device offline (${offlineParts.join(", ")})`
          : "device offline";

        // === Compose notes ===
        if (conditions.shouldDispatch) {
          notes += "DISPATCH REQUIRED:\n";
          (conditions.passingConditions || []).forEach((condition) => {
            notes += "✓ " + condition + "\n";
          });
          notes += "\nDispatching emergency services per protocol.";
        } else {
          notes += "DISPATCH NOT REQUIRED:\n";

          // Print failing reasons, but upgrade any "device offline" text with live panel detail
          (conditions.failingReasons || []).forEach((reason) => {
            const pretty = /device\s*offline/i.test(String(reason))
              ? offlineDetail
              : String(reason);
            notes += "✗ " + pretty + "\n";
          });

          notes += "\nNo emergency services dispatch needed.";
        }

        // Optional: include a short connectivity snapshot at the bottom (kept plain text)
        // You can delete this block if you don't want the snapshot in notes.
        const anyPanel = lastCommTxt || battTxt || sigTxt;
        if (anyPanel) {
          notes += "\n\nConnectivity Snapshot";
          if (lastCommTxt) notes += "\nLast Communication: " + lastCommTxt;
          if (batteryEl) notes += "\nBattery: " + battTxt;
          if (signalEl) notes += "\nSignal: " + sigTxt;
        }

        return notes;
      }

      function updateDispatchUI() {
        // Enhanced visual feedback for dispatch actions
        const serviceContainer = document.getElementById(
          "service-type-container"
        );
        const dispatchStatus = document.getElementById("dispatch-status");

        if (serviceContainer && dispatchMade) {
          serviceContainer.style.background = "#d4edda";
          serviceContainer.style.borderColor = "#28a745";

          // Disable the service dropdown after dispatch
          const serviceDropdown = document.getElementById("service-dropdown");
          if (serviceDropdown) {
            serviceDropdown.disabled = true;
            serviceDropdown.style.opacity = "0.7";
          }

          // Update dispatch button
          const dispatchBtn = serviceContainer.querySelector("button");
          if (dispatchBtn) {
            dispatchBtn.disabled = true;
            dispatchBtn.innerHTML = "✅ Dispatch Completed";
            dispatchBtn.classList.remove("btn-danger");
            dispatchBtn.classList.add("btn-success");
          }
        }

        if (dispatchStatus && dispatchMade) {
          dispatchStatus.style.display = "block";
        }
      }

      function enhanceStepVisual(stepId) {
        // Add special styling for dispatch step when active
        const step = document.getElementById(stepId);
        if (step) {
          step.style.background = "linear-gradient(135deg, #fff3cd, #ffeaa7)";
          step.style.border = "2px solid #ffc107";
        }
      }

      function validateDispatchDecision() {
        const decisionEl = document.getElementById("dispatch-decision");
        if (!decisionEl) return false;

        const currentDispatchStep = document
          .querySelector(".step.active #dispatch-decision")
          ?.closest(".step")?.id;

        const dispatchNote = currentDispatchStep
          ? document.getElementById(currentDispatchStep + "-note")
          : null;

        let isValid = false;

        if (decisionEl.value === "yes") {
          const dispatchType =
            document.getElementById("service-dropdown") ||
            document.getElementById("dispatch");
          isValid = !!(
            dispatchType &&
            dispatchType.value &&
            dispatchNote &&
            dispatchNote.value.trim()
          );
        } else if (decisionEl.value === "no") {
          const skipReason = document.getElementById("skip-reason");
          isValid = !!(
            skipReason &&
            skipReason.value &&
            dispatchNote &&
            dispatchNote.value.trim()
          );
        }

        return isValid;
      }

      function logDispatchDecision(stepId) {
        // ← Add stepId parameter
        // Comprehensive logging for dispatch decisions
        const decision = document.getElementById("dispatch-decision").value;
        const gasReading = getCurrentGasReading();

        if (decision === "yes") {
          const services = getSelectedServices();
          const servicesText =
            services.length > 0 ? services.join(", ") : "Emergency Services";

          let logMessage =
            getStepLabel(stepId) +
            ": Dispatch decision - YES. Services: " +
            servicesText;

          if (currentAlert && currentAlert.id === "gas-high-threshold") {
            logMessage +=
              ". Gas level: " +
              gasReading.status +
              " – Gas Reading: " +
              gasReading.type +
              ": " +
              gasReading.value +
              gasReading.unit;
          }

          addLogEntry(logMessage, "step");
        } else if (decision === "no") {
          const skipReason = document.getElementById("skip-reason");
          const reasonText = skipReason.options[skipReason.selectedIndex].text;

          let logMessage =
            getStepLabel(stepId) +
            ": Dispatch decision - NO. Reason: " +
            reasonText;

          if (currentAlert && currentAlert.id === "gas-high-threshold") {
            logMessage +=
              ". Gas level: " +
              gasReading.status +
              " – Gas Reading: " +
              gasReading.type +
              ": " +
              gasReading.value +
              gasReading.unit;
          }

          addLogEntry(logMessage, "step");
        }
      }

      // ═══════════════════════════════════════════════════════════════
      // 🚑 DISPATCH CONDITION CHECKER (UPDATED)
      // ═══════════════════════════════════════════════════════════════

      function checkDispatchConditions(stepId) {
        console.log("checkDispatchConditions called for:", stepId);

        // Visual tweaks (kept)
        try {
          enhanceStepVisual(stepId);
        } catch (e) {
          /* no-op */
        }

        // Show the outcome section for whatever step invoked this
        const outcomeSection = document.getElementById(stepId + "-outcome");
        if (outcomeSection) outcomeSection.style.display = "block";

        // 👇 Single source of truth: let the unified updater compute & set everything
        const runUnified = () => {
          if (typeof silentlyUpdateDispatchConditions === "function") {
            silentlyUpdateDispatchConditions(); // sets dropdown, skip reason, textarea (gas), fires change
          }
        };

        // Do it now and on the next paint to beat any race with DOM rendering
        runUnified();
        requestAnimationFrame(runUnified);
        setTimeout(runUnified, 0);

        // (Optional) keep resolution reason auto-fill if empty
        try {
          const resolutionSelect = document.getElementById("resolution-reason");
          if (resolutionSelect && !resolutionSelect.value) {
            const resolutionType =
              typeof determineResolutionType === "function"
                ? determineResolutionType(currentAlert)
                : "";
            if (resolutionType) resolutionSelect.value = resolutionType;
          }
        } catch (e) {
          console.warn(
            "checkDispatchConditions: resolution select fill failed:",
            e
          );
        }

        // NOTE:
        // - We no longer call evaluateDispatchConditionsFromConnectivity() here.
        // - We do not directly set #dispatch-decision or #skip-reason here.
        //   silentlyUpdateDispatchConditions() already sets them AND dispatches a 'change' event.
        // - We do not call handleDispatchDecision() here; any listeners bound to the
        //   dropdown's change event will run because the unified updater fires it.
      }

      function evaluateDispatchConditionsFromConnectivity() {
        const conditions = {
          deviceOnline: false,
          locationFresh: false,
          deviceStationary: false,
        };
        const failedReasons = [];
        const passedReasons = [];

        // Check if we have perfect conditions from currentAlert
        if (currentAlert && currentAlert.deviceConditions) {
          const dc = currentAlert.deviceConditions;

          // Condition 1: Device Online
          conditions.deviceOnline =
            dc.lastComm < 30 && dc.battery > 10 && dc.signal > 10;
          if (conditions.deviceOnline) {
            passedReasons.push("Device online");
          } else {
            failedReasons.push(
              "Device offline (last comm > 30 min, battery ≤ 10%, or signal ≤ 10%)"
            );
          }

          // Condition 2: Location Fresh (< 5 min old)
          conditions.locationFresh = dc.locationAge < 5;
          if (conditions.locationFresh) {
            passedReasons.push("Location fresh");
          } else {
            failedReasons.push("Location not valid or current");
          }

          // Condition 3: Device Stationary (< 5 km/h)
          conditions.deviceStationary = dc.deviceSpeed < 5;
          if (conditions.deviceStationary) {
            passedReasons.push("Device stationary");
          } else {
            failedReasons.push("Device not stationary (≥ 5 km/h)");
          }
        } else {
          // Fallback to old DOM-based checking
          failedReasons.push("Location not valid or current");
        }

        const allConditionsMet =
          conditions.deviceOnline &&
          conditions.locationFresh &&
          conditions.deviceStationary;

        return {
          canDispatch: allConditionsMet,
          conditions: conditions,
          passedReasons: passedReasons,
          failedReasons: failedReasons,
        };
      }

      function generateDispatchAnalysisNotes(result) {
        // Get location and communication data from connectivity panel
        const locationElement = document.getElementById("device-location");
        const lastCommElement = document.getElementById("last-comm-time");
        const location = locationElement
          ? locationElement.textContent
          : "Location unknown";
        const lastComm = lastCommElement
          ? lastCommElement.textContent
          : "Communication time unknown";

        if (result.canDispatch) {
          // Get current dispatch step dynamically
          const currentDispatchStep = document
            .querySelector('.step.active [onclick*="checkDispatchConditions"]')
            ?.closest(".step")?.id;
          const stepNumber = currentDispatchStep
            ? currentDispatchStep.replace("step-", "")
            : "5";

          // Get all connectivity data
          const locationTimestamp =
            document
              .getElementById("location-timestamp")
              ?.textContent?.trim() || "";
          const address =
            document.getElementById("device-location")?.textContent?.trim() ||
            "";
          const coordinates =
            document
              .getElementById("device-coordinates")
              ?.textContent?.trim() || "";
          const speed =
            document.getElementById("device-speed")?.textContent?.trim() || "";
          const lastCommTimestamp =
            document
              .querySelector('[id*="last-communication"]')
              ?.textContent?.trim() || "";
          const battery =
            document.querySelector('[id*="battery"]')?.textContent?.trim() ||
            "";

          // Get signal data based on device type
          const deviceType = currentUser?.device?.includes("G7x")
            ? "G7x"
            : "G7c";
          let signalInfo = "";

          if (deviceType === "G7x") {
            const deviceSignal =
              document
                .querySelector('[id*="device-signal"]')
                ?.textContent?.trim() || "";
            const bridgeSignal =
              document
                .querySelector('[id*="bridge-signal"]')
                ?.textContent?.trim() || "";
            signalInfo =
              "**Device Signal Strength** - " +
              deviceSignal +
              "\n" +
              "**Bridge Signal Strength** - " +
              bridgeSignal +
              "\n\n";
          } else {
            const signal =
              document.querySelector('[id*="signal"]')?.textContent?.trim() ||
              "";
            signalInfo = "**Signal Strength** - " + signal + "\n\n";
          }

          return (
            `Step ${stepNumber}: Called dispatch, spoke to ___. Dispatched [SELECTED_SERVICES] to following location:\n\n` +
            "**Last Location**\n" +
            locationTimestamp +
            "\n\n" +
            "**Approximate Address**\n" +
            address +
            "\n\n" +
            "**Latitude / Longitude**\n" +
            coordinates +
            "\n\n" +
            "**Speed** - " +
            speed +
            "\n\n" +
            "**Last Communication**\n" +
            lastCommTimestamp +
            "\n\n" +
            "**Battery** - " +
            battery +
            "\n" +
            signalInfo
          );
        } else {
          // Get current dispatch step dynamically for proper step numbering
          const currentDispatchStep = document
            .querySelector('.step.active [onclick*="checkDispatchConditions"]')
            ?.closest(".step")?.id;
          const stepNumber = currentDispatchStep
            ? currentDispatchStep.replace("step-", "")
            : "5";

          // Get specific failed condition
          const failedCondition = result.failedReasons[0];

          // Just return the note text - no action triggering
          const stepMessage = `Step ${stepNumber}: Unable to dispatch - ${failedCondition.toLowerCase()}`;

          return stepMessage;
        }
      }

      // Function to restart protocol cycle
      function restartProtocolCycle() {
        console.log("🔄 Restarting protocol cycle - enabling steps 1-4");

        // ── Reset per-cycle runtime state ─────────────────────────────────────
        if (!window.protocolState) window.protocolState = {};
        if (
          protocolState.startedSteps &&
          typeof protocolState.startedSteps.clear === "function"
        ) {
          protocolState.startedSteps.clear();
        }
        if (Array.isArray(protocolState.completedSteps)) {
          protocolState.completedSteps = protocolState.completedSteps.filter(
            (id) => !/^step-[1-4](?:-.+)?$/.test(id)
          );
        }
        if (
          window.activeTimerData?.isRunning &&
          typeof cancelGlobalTimer === "function"
        ) {
          cancelGlobalTimer({ silent: true });
        }

        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const stepsToReset = ["step-1", "step-2", "step-3", "step-4"];

        stepsToReset.forEach((stepId, index) => {
          const step = document.getElementById(stepId);
          const statusBadge = document.getElementById(stepId + "-status");
          const button = step?.querySelector(
            'button:not([onclick*="postNote"])'
          );
          const isFirstStep = index === 0;

          const cfgStep = protocolConfig?.steps?.find((s) => s.id === stepId);
          const action = cfgStep?.action; // (kept in case you use it later)

          // Main step container reset
          if (step) {
            step.classList.remove("completed", "active");
            if (isFirstStep) step.classList.add("active");
            step.style.opacity = "1";
            step.style.pointerEvents = "auto";
            step.style.position = "";
            step.style.transform = "";

            const outcomeSection = document.getElementById(stepId + "-outcome");
            if (outcomeSection) outcomeSection.style.display = "none";
          }

          if (statusBadge) {
            statusBadge.textContent = isFirstStep ? "Active" : "Pending";
            statusBadge.className = isFirstStep
              ? "status-badge active"
              : "status-badge";
            statusBadge.style.background = "";
            statusBadge.style.color = "";
          }

          if (button) {
            button.disabled = !isFirstStep;
            button.classList.remove("btn-secondary", "btn-primary");
            button.classList.add(isFirstStep ? "btn-primary" : "btn-secondary");
            button.style.pointerEvents = "auto";

            if (!button.getAttribute("onclick")) {
              button.setAttribute("onclick", `startStep('${stepId}')`);
            }

            // keep labels human-friendly after restart
            formatButtonText?.();
          }

          // Sub-steps reset
          const subSteps = document.querySelectorAll(`[id^="${stepId}-"]`);
          subSteps.forEach((subStep) => {
            if (!subStep.classList.contains("sub-step")) return;

            const subStatusBadge = document.getElementById(
              subStep.id + "-status"
            );
            const subButton = subStep.querySelector(
              'button:not([onclick*="postNote"])'
            );

            subStep.classList.remove("completed", "active");

            const isFirstSubStep = isFirstStep && subStep.id.endsWith("-1");
            if (isFirstSubStep) subStep.classList.add("active");

            subStep.style.opacity = "1";
            subStep.style.pointerEvents = "auto";
            subStep.style.position = "";
            subStep.style.transform = "";

            const outcomeSection = document.getElementById(
              subStep.id + "-outcome"
            );
            if (outcomeSection) outcomeSection.style.display = "none";

            if (subStatusBadge) {
              subStatusBadge.textContent = isFirstSubStep
                ? "Active"
                : "Pending";
              subStatusBadge.className = isFirstSubStep
                ? "status-badge active"
                : "status-badge";
              subStatusBadge.style.background = "";
              subStatusBadge.style.color = "";
            }

            if (subButton) {
              subButton.disabled = !isFirstSubStep;
              subButton.classList.remove("btn-primary", "btn-secondary");
              subButton.classList.add(
                isFirstSubStep ? "btn-primary" : "btn-secondary"
              );
              subButton.style.pointerEvents = "auto";

              if (!subButton.getAttribute("onclick")) {
                subButton.setAttribute("onclick", `startStep('${subStep.id}')`);
              }
            }
          });
        });

        // ✅ Auto-scroll to Step 1 and focus its action button
        requestAnimationFrame(() => {
          const firstStep = document.getElementById("step-1");
          if (firstStep) {
            firstStep.scrollIntoView({ behavior: "smooth", block: "center" });
            const btn = firstStep.querySelector(
              'button:not([onclick*="postNote"])'
            );
            if (btn) btn.focus({ preventScroll: true });
          }
        });

        console.log("Protocol cycle restart completed");
      }

      // ═══════════════════════════════════════════════════════════════
      // 🚀 INITIALIZATION & STARTUP
      // ═══════════════════════════════════════════════════════════════

      document.addEventListener("DOMContentLoaded", function () {
        updateGasReadings("default");
        startGasMonitoring();

        // Initialize device connectivity
        DeviceConnectivity.updateConnectivityDisplay();

        // Update connectivity every 30 seconds
        setInterval(() => {
          DeviceConnectivity.updateConnectivityDisplay();
        }, 30000);

        const messageInput = document.getElementById("manual-message-input");
        const charCounter = document.getElementById("charCounter");
        const sendBtn = document.getElementById("sendMessageBtn");

        if (messageInput && charCounter && sendBtn) {
          messageInput.addEventListener("input", () => {
            const remaining = 32 - messageInput.value.length;
            charCounter.textContent = `${remaining} characters remaining`;
            sendBtn.disabled =
              remaining < 0 || messageInput.value.trim() === "";
          });
        }
      });

      document.addEventListener("click", function (event) {
        const demoPanel = document.getElementById("demo-panel");
        const demoGear = document.getElementById("demo-gear");

        if (
          demoPanel &&
          demoGear &&
          !demoPanel.contains(event.target) &&
          !demoGear.contains(event.target)
        ) {
          demoPanel.classList.remove("show");
        }
      });

      function triggerGasNormalization(alertConfig) {
        try {
          const cfg = alertConfig?.gasNormalization;
          if (!cfg?.enabled) return;

          const gasKey = Object.keys(cfg.targetLevels)[0] || "co";
          const target = cfg.targetLevels[gasKey];
          const value =
            typeof target === "object" ? Number(target.value) : Number(target);
          const status =
            typeof target === "object" && target.status
              ? String(target.status)
              : "NORMAL";

          const gasLabel =
            gasKey === "h2s"
              ? "H₂S"
              : gasKey === "o2"
              ? "O₂"
              : gasKey.toUpperCase();
          const unit =
            gasKey === "o2" ? " %vol" : gasKey === "lel" ? " %LEL" : " ppm";
          const newValueStr = `${value.toFixed(2)}${unit}`;

          // Find the Gas Readings (Live) panel
          const panel = Array.from(document.querySelectorAll("*")).find((el) =>
            /Gas Readings\s*\(Live\)/i.test(el.textContent)
          );
          if (!panel) return;

          // Prefer the LIST ".gas-reading" that matches this gas (not the big header)
          const readings = Array.from(panel.querySelectorAll(".gas-reading"));
          const matches = readings.filter((el) => {
            const t = (el.textContent || "").trim().replace(/^[^\w]+/, ""); // strip emoji
            return new RegExp(`^${gasLabel}\\s*:\\s*`, "i").test(t);
          });
          let rowEl =
            matches.find((el) =>
              el.querySelector(".gas-status, .status-pill")
            ) ||
            matches[matches.length - 1] ||
            null;
          if (!rowEl) rowEl = document.getElementById(`${gasKey}-reading`);
          if (!rowEl) return;

          // Peak reading (before change)
          let peakReading = "";
          const currentValEl =
            rowEl.querySelector(`#${gasKey}-value`) ||
            document.getElementById(`${gasKey}-value`);
          if (currentValEl && currentValEl.textContent) {
            const m = (currentValEl.textContent.match(/[\d.]+/) || [])[0];
            if (m) peakReading = `${gasLabel} ${Number(m).toFixed(2)}${unit}`;
          } else {
            const m = (rowEl.textContent.match(/:\s*([0-9.]+)/) || [])[1];
            if (m) peakReading = `${gasLabel} ${Number(m).toFixed(2)}${unit}`;
          }

          // Rebuild this row: icon + label + value
          const icon = status === "HIGH" ? "🔴" : "🟢";
          // ↓↓↓ ONE-CHAR CHANGE: remove the space after the colon
          rowEl.innerHTML = `${icon} ${gasLabel}:<span id="${gasKey}-value" class="gas-value">${newValueStr}</span>`;
          rowEl.id = `${gasKey}-reading`;

          // Ensure/Update status pill (append at end of the same .gas-reading)
          let pill =
            rowEl.querySelector(`#${gasKey}-status`) ||
            rowEl.querySelector(".gas-status, .status-pill") ||
            null;
          if (!pill) {
            pill = document.createElement("span");
            rowEl.appendChild(pill);
          }
          pill.id = `${gasKey}-status`;
          pill.textContent = status;
          pill.className = `gas-status ${status.toLowerCase()}`;

          // De-dupe stray IDs so future lookups hit THIS row
          ["reading", "value", "status"].forEach((sfx) => {
            Array.from(document.querySelectorAll(`#${gasKey}-${sfx}`)).forEach(
              (el) => {
                if (
                  el !==
                  (sfx === "reading"
                    ? rowEl
                    : sfx === "value"
                    ? rowEl.querySelector(`#${gasKey}-value`)
                    : pill)
                ) {
                  el.removeAttribute("id");
                }
              }
            );
          });

          // Update "Last updated" time
          const tsNode =
            document.querySelector("[data-gas-last-updated]") ||
            document.getElementById("gas-timestamp");
          if (tsNode) {
            const now = new Date();
            tsNode.textContent =
              typeof FORMATTERS?.timeOnlyMST === "function"
                ? FORMATTERS.timeOnlyMST(now)
                : new Intl.DateTimeFormat("en-US", {
                    timeZone: "America/Denver",
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit",
                    hour12: false,
                  }).format(now) + " MDT";
          }

          // System log
          const peakPart = peakReading ? ` Peak: ${peakReading}.` : "";
          addLogEntry(
            `${gasLabel} is no longer exceeding the high threshold.${peakPart} Current: ${gasLabel} ${newValueStr}.`,
            "system"
          );
        } catch (e) {
          console.warn("triggerGasNormalization failed:", e);
        }

        if (typeof silentlyUpdateDispatchConditions === "function") {
          silentlyUpdateDispatchConditions();
        }
      }

      function triggerResolutionFlow(
        fromStepId,
        reason = "User confirmed okay"
      ) {
        // 1. Mark current step complete
        if (fromStepId) {
          markStepCompleted(fromStepId);
        }

        // 2. Block all remaining steps
        blockRemainingSteps(fromStepId, reason);

        // 3. Auto-populate resolution dropdown
        const resolutionSelect = document.getElementById("resolution-reason");
        if (resolutionSelect && !resolutionSelect.value) {
          const resolutionType = determineResolutionType(currentAlert);
          resolutionSelect.value = resolutionType;
        }

        // 4. Scroll to resolution panel
        setTimeout(() => {
          const resolutionSection = document.querySelector(
            ".resolution-section"
          );
          if (resolutionSection) {
            resolutionSection.scrollIntoView({
              behavior: "smooth",
              block: "center",
            });
          }
        }, 300);
      }

      function canStepTriggerResolution(stepId) {
        // Any step can potentially trigger resolution based on its outcome
        // Check if step has resolution-triggering actions
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const stepConfig = protocolConfig.steps.find(
          (step) => step.id === stepId
        );

        // Resolution can be triggered by: Call User, Send Message, Contact ECs, or Dispatch
        const resolutionActions = [
          "call-user",
          "message-device",
          "call-emergency-contacts",
          "dispatch",
        ];
        return stepConfig && resolutionActions.includes(stepConfig.action);
      }

      function enableNextStep(stepId) {
        // Get current protocol to determine next step
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const currentIndex = protocolConfig.steps.findIndex(
          (step) => step.id === stepId
        );

        // Check if there's a next step
        if (
          currentIndex >= 0 &&
          currentIndex < protocolConfig.steps.length - 1
        ) {
          const nextStep = protocolConfig.steps[currentIndex + 1];
          const nextStepId = nextStep.id;

          const nextStepElement = document.getElementById(nextStepId);
          const nextButton = nextStepElement?.querySelector(
            'button:not([onclick*="postNote"])'
          );

          if (nextStepElement) {
            nextStepElement.classList.add("active");
            nextStepElement.style.opacity = "1";
            nextStepElement.style.pointerEvents = "auto";

            // AUTO-SCROLL: Scroll the newly active step into view
            nextStepElement.scrollIntoView({
              behavior: "smooth",
              block: "center",
            });
          }

          if (nextButton) {
            nextButton.disabled = false;
            nextButton.classList.remove("btn-secondary");
            nextButton.classList.add("btn-primary");
          }

          // Update status badge
          const statusBadge = document.getElementById(nextStepId + "-status");
          if (statusBadge) {
            statusBadge.textContent = "Active";
            statusBadge.className = "status-badge active";
          }

          // Auto-evaluate dispatch conditions if next step is dispatch
          if (nextStep.action === "dispatch") {
            setTimeout(() => {
              checkDispatchConditions(nextStepId);
            }, 500);
          }
        }
      }

      // Silent background monitoring - NO LOGGING
      function initializeDispatchMonitoring() {
        // Initial silent evaluation
        silentlyUpdateDispatchConditions();

        // Background monitoring every 2 minutes
        setInterval(silentlyUpdateDispatchConditions, 120000);
      }

      function autoPopulateDispatchNote(stepId) {
        const serviceSelect = document.getElementById("dispatch");
        const textarea = document.getElementById(stepId + "-note");
        const selectedService = serviceSelect?.value;

        if (selectedService && textarea) {
          const stepNumber = stepId.replace("step-", "");

          // Get real connectivity data
          const location = document
            .getElementById("device-location")
            .textContent.trim();
          const coordinates = document
            .getElementById("device-coordinates")
            .textContent.trim();
          const speed = document
            .getElementById("device-speed")
            .textContent.trim();
          const lastComm = document
            .getElementById("last-comm-time")
            .textContent.trim();
          const battery = document
            .getElementById("battery-level")
            .textContent.trim();
          const signal = document
            .getElementById("signal-strength")
            .textContent.trim();

          // Generate today's timestamp for dispatch purposes
          const now = new Date();
          const todaysTimestamp =
            now.toLocaleDateString("en-US", {
              year: "numeric",
              month: "short",
              day: "2-digit",
            }) +
            " at " +
            now.toLocaleTimeString("en-US", {
              hour: "2-digit",
              minute: "2-digit",
              hour12: false,
            }) +
            " MDT";

          const dispatchNote = `Step ${stepNumber}: Called dispatch, spoke to ___. Dispatched ${selectedService} to the following location:

      Last Location Date/Time: ${todaysTimestamp} (just now)

      Approximate Address: ${location}

      Latitude / Longitude: ${coordinates}

      Speed: ${speed}

      Last Communication: ${lastComm}

      Battery: ${battery}

      Signal Strength: ${signal}

      Waiting 30 minutes.`;

          textarea.value = dispatchNote;
          validatePostButton(stepId);
        }
      }

      // Silent background monitoring - NO LOGGING
      function initializeDispatchMonitoring() {
        // Initial silent evaluation
        silentlyUpdateDispatchConditions();

        // Background monitoring every 2 minutes
        setInterval(silentlyUpdateDispatchConditions, 120000);
      }

      function determineResolutionType(alertData) {
        // 1) Category: gas alerts are "incident", non-gas are "false-alert"
        const isGas =
          (typeof isGasAlert === "function" && isGasAlert(alertData)) ||
          /(^gas-|h2s|co|o2|lel)/i.test(alertData?.id || "") ||
          /h2s|co|o2|lel/i.test(alertData?.gasType || "");

        let category = isGas ? "incident" : "false-alert";

        // Optional: if your pre-alert banner sets a flag, prefer that category
        if (
          alertData?.isPreAlert === true ||
          window.currentAlert?.isPreAlert === true
        ) {
          category = "pre-alert";
        }

        // 2) Dispatch suffix: prefer explicit global, then dropdown, default to "no"
        let hasDispatch =
          typeof window.dispatchMade !== "undefined"
            ? !!window.dispatchMade
            : null;

        if (hasDispatch === null) {
          const dd = document.getElementById("dispatch-decision");
          if (dd) hasDispatch = dd.value === "yes";
        }
        if (hasDispatch === null) hasDispatch = false;

        const suffix = hasDispatch ? "with-dispatch" : "without-dispatch";

        return `${category}-${suffix}`;
      }
    </script>
  </body>
</html>
