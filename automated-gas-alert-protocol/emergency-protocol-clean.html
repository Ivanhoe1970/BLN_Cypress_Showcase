<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enhanced Blackline Live - Alert Management</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #f8f9fa;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
      }

      .header {
        background: linear-gradient(135deg, #e3f2fd, #bbdefb);
        color: #1565c0;
        padding: 20px;
        margin-bottom: 20px;
        border-radius: 8px;
        border: 1px solid #90caf9;
        display: none;
      }

      .header.active {
        display: block;
      }

      .alert-title {
        margin: 0;
        font-size: 1.5em;
        font-weight: bold;
        margin-bottom: 15px;
      }

      .alert-details {
        background: white;
        border: 1px solid #90caf9;
        border-radius: 6px;
        padding: 15px;
        color: #333;
      }

      .alert-info {
        display: block;
        font-size: 0.9em;
      }
      .info-item {
        padding: 3px 0;
      }
      .info-item strong {
        color: #1565c0;
        font-weight: 600;
      }

      .container {
        display: grid;
        grid-template-columns: 1fr 200px 1fr 300px;
        gap: 15px;
        max-width: 1600px;
        margin: 0 auto;
        padding: 20px;
      }

      .right-column {
        display: flex;
        flex-direction: column;
        gap: 15px;
        grid-column: 4;
      }

      .protocol-log {
        background: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 20px;
      }

      .protocol-log h3 {
        margin-top: 0;
        color: #333;
        font-size: 1.1em;
      }

      .log-container {
        height: calc(100vh - 350px);
        min-height: 400px;
        overflow-y: auto;
        background: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        border: 1px solid #e9ecef;
        margin-bottom: 20px;
      }

      .log-entry {
        margin: 8px 0;
        padding: 12px;
        background: white;
        border-left: 4px solid #28a745;
        border-radius: 6px;
        font-size: 0.9em;
        line-height: 1.4;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .log-entry.step {
        border-left-color: #007bff;
      }
      .log-entry.timer {
        border-left-color: #ffc107;
      }
      .log-entry.resolution {
        border-left-color: #dc3545;
      }
      .log-entry.gas {
        border-left-color: #fd7e14;
      }
      .log-entry.system {
        border-left-color: #6c757d;
      }

      .log-placeholder {
        color: #6c757d;
        text-align: center;
        margin-top: 120px;
        font-style: normal;
        font-size: 0.9em;
        font-family: inherit;
      }

      .global-timer {
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
        border-radius: 8px;
        padding: 15px;
        text-align: center;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        position: sticky;
        top: 20px;
        height: fit-content;
        font-size: 0.9em;
      }

      .timer-controls {
        margin-top: 12px;
        display: flex;
        justify-content: center;
        padding: 0 10px; /* Breathing room from timer edges */
      }

      .timer-meta {
        margin-top: 8px;
        font-size: 0.7em;
        opacity: 0.8;
        line-height: 1.2;
        display: flex;
        justify-content: space-between;
      }

      .cancel-btn {
        background: #dc3545;
        color: white !important;
        border: none;
        padding: 8px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        font-size: 0.75em;
        transition: background 0.2s;
        width: calc(100% - 20px);
        margin: 0 10px;
        display: block;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        opacity: 1 !important;
      }

      .cancel-btn:hover:not(:disabled) {
        background: #c82333;
      }

      .cancel-btn:disabled,
      #cancelTimerBtn.cancel-btn:disabled {
        opacity: 1 !important;
        cursor: not-allowed;
        color: white !important;
        background: #dc3545 !important;
      }

      .steps-section {
        background: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 20px;
      }

      .steps-section h3 {
        margin-top: 0;
        color: #333;
        font-size: 1.1em;
      }

      .gas-readings-card {
        background: white;
        border: 2px solid #28a745;
        border-radius: 8px;
        padding: 20px;
        position: sticky;
        top: 20px;
        height: fit-content;
      }

      .gas-readings-card h3 {
        margin-top: 0;
        color: #333;
        font-size: 1.1em;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .gas-reading {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid #e9ecef;
        font-size: 0.9em;
      }

      .gas-reading:last-child {
        border-bottom: none;
      }
      .gas-value {
        font-weight: bold;
      }

      .gas-status {
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.8em;
        font-weight: bold;
      }

      .gas-status.high {
        background: #f8d7da;
        color: #721c24;
      }

      .gas-status.normal {
        background: #d4edda;
        color: #155724;
      }

      .triggered-by {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 4px;
        padding: 8px;
        margin-bottom: 15px;
        font-size: 0.85em;
        font-weight: bold;
        color: #856404;
      }

      .last-updated {
        font-size: 0.8em;
        color: #6c757d;
        text-align: center;
        margin-top: 10px;
        font-style: italic;
      }

      .connectivity-panel {
        background: white;
        border: 2px solid #6c757d;
        border-radius: 8px;
        padding: 20px;
        height: fit-content;
      }

      .connectivity-panel h3 {
        margin-top: 0;
        color: #333;
        font-size: 1em;
        margin-bottom: 15px;
      }

      .device-status,
      .last-comm {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        font-size: 0.9em;
      }

      .status-pill {
        padding: 4px 10px;
        border-radius: 20px;
        font-weight: bold;
        font-size: 0.85em;
      }

      .status-pill.online {
        background: #d4edda;
        color: #155724;
      }

      .status-pill.offline {
        background: #f8d7da;
        color: #721c24;
      }

      .status-pill.loading {
        background: #fff3cd;
        color: #856404;
      }

      .step {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
        position: relative;
      }

      .step.completed {
        background: #d4edda;
        border-color: #c3e6cb;
      }

      .step.active {
        animation: pulse-border 1.5s infinite;
      }

      @keyframes pulse-border {
        0% {
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(0, 123, 255, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0);
        }
      }

      .step-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .step-title {
        font-weight: bold;
        color: #333;
        margin: 0;
        font-size: 0.95em;
      }

      .status-badge {
        background: #ffc107;
        color: #000;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.75em;
        font-weight: bold;
      }

      .status-badge.completed {
        background: #28a745;
        color: white;
      }

      .contact-info {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 4px;
        padding: 8px;
        margin: 8px 0;
        font-size: 0.85em;
      }

      .btn {
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
        font-size: 0.85em;
        transition: all 0.2s;
      }

      .btn-primary {
        background: #007bff;
        color: white;
      }

      .btn-primary:hover:not(:disabled) {
        background: #0056b3;
      }

      .btn-success {
        background: #28a745;
        color: white;
      }

      .btn-success:hover:not(:disabled) {
        background: #1e7e34;
      }

      .btn-secondary {
        background: #6c757d;
        color: white;
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .timer-inactive {
        opacity: 0.6;
        background: linear-gradient(135deg, #6c757d, #495057);
      }

      .manual-notes {
        width: 100%;
        height: 100px;
        border-radius: 5px;
        border: 1px solid #ddd;
        padding: 10px;
        box-sizing: border-box;
        resize: vertical;
        font-family: inherit;
        font-size: 0.9em;
      }

      .step-outcome {
        margin: 10px 0;
      }

      .step-outcome select {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.9em;
      }

      .step.skipped {
        background-color: #f8f9fa !important;
        opacity: 0.6;
        pointer-events: none;
      }

      .step.skipped .status-badge {
        background-color: #6c757d !important;
        color: white !important;
      }

      .step.skipped button {
        background-color: #6c757d !important;
        color: #dee2e6 !important;
        border-color: #6c757d !important;
      }

      .step-outcome textarea {
        width: 100%;
        height: 80px;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.9em;
        margin-top: 8px;
        box-sizing: border-box;
        resize: vertical;
      }

      .resolution-section {
        background: #fff;
        border: 2px solid #dc3545;
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
      }

      .resolution-section h3 {
        margin-top: 0;
        color: #dc3545;
      }

      .resolution-section select {
        width: 100%;
        padding: 10px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      .resolution-buttons {
        display: flex;
        gap: 10px;
        margin-top: 15px;
      }

      .btn-danger {
        background: #dc3545;
        color: white;
      }

      .btn-danger:hover:not(:disabled) {
        background: #c82333;
      }

      /* Production View Toggle */
      .production-toggle {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 0.8em;
        cursor: pointer;
        z-index: 2000;
        transition: all 0.3s;
      }

      .production-toggle:hover {
        background: rgba(0, 0, 0, 0.9);
      }

      .production-mode .demo-gear,
      .production-mode .demo-panel {
        display: none !important;
      }

      .production-mode .header {
        margin-top: 10px;
      }

      /* Demo Controls */
      .demo-gear {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
        background: #6c757d;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 1000;
        transition: all 0.3s;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      }

      .demo-gear:hover {
        background: #5a6268;
        transform: rotate(90deg);
      }

      .demo-gear::before {
        content: "⚙️";
        font-size: 20px;
      }

      .demo-panel {
        position: fixed;
        bottom: 70px;
        right: 20px;
        background: rgba(255, 255, 255, 0.98);
        border-radius: 8px;
        padding: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        border: 1px solid #e9ecef;
        z-index: 999;
        max-width: 280px;
        max-height: 70vh;
        overflow-y: auto;
        display: none;
      }

      .demo-panel.show {
        display: block;
        animation: slideUp 0.3s ease-out;
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .demo-panel h4 {
        margin: 8px 0 6px 0;
        color: #333;
        font-size: 0.85em;
        border-bottom: 1px solid #e9ecef;
        padding-bottom: 4px;
        font-weight: 600;
      }

      .demo-panel h4:first-child {
        margin-top: 0;
      }

      .demo-button-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 4px;
        margin-bottom: 8px;
      }

      .demo-button-single {
        display: grid;
        grid-template-columns: 1fr;
        gap: 4px;
        margin-bottom: 8px;
      }

      .demo-panel button {
        font-size: 0.7em;
        padding: 6px 8px;
        margin: 0;
        border-radius: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1.2;
        height: auto;
        min-height: 28px;
      }

      .demo-panel .btn-secondary {
        grid-column: 1 / -1;
        margin-top: 8px;
        font-weight: 600;
      }

      .demo-section {
        margin-bottom: 10px;
      }

      .demo-section:last-child {
        margin-bottom: 0;
      }

      /* Collapsible sections */
      .demo-section-header {
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        user-select: none;
      }

      .demo-section-header::after {
        content: "▼";
        font-size: 0.7em;
        color: #666;
        transition: transform 0.2s;
      }

      .demo-section.collapsed .demo-section-header::after {
        transform: rotate(-90deg);
      }

      .demo-section.collapsed .demo-section-content {
        display: none;
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .empty-state {
        text-align: center;
        color: #6c757d;
        padding: 100px 20px;
        font-size: 1.1em;
      }

      .empty-state h2 {
        color: #1565c0;
        margin-bottom: 15px;
      }

      .protocol-placeholder {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 300px;
        padding: 20px;
      }

      .protocol-frame {
        border: 2px solid #e9ecef;
        border-radius: 8px;
        padding: 40px 30px;
        text-align: center;
        background: #f8f9fa;
        width: 100%;
        max-width: 400px;
      }

      .placeholder-text {
        font-size: 1.1em;
        font-weight: 600;
        color: #6c757d;
        margin-bottom: 10px;
      }

      .placeholder-subtitle {
        font-size: 0.9em;
        color: #8d9499;
        line-height: 1.4;
      }

      .timer-active {
        opacity: 1;
        background: linear-gradient(135deg, #007bff, #0056b3);
      }

      .timer-alert {
        animation: flashRed 1s infinite;
      }

      @keyframes flashRed {
        0%,
        50% {
          background: linear-gradient(135deg, #dc3545, #c82333);
        }
        51%,
        100% {
          background: linear-gradient(135deg, #007bff, #0056b3);
        }
      }

      .container {
        display: grid;
        grid-template-columns: 1fr 200px 1fr 300px;
        gap: 15px;
        align-items: start; /* Ensures top alignment */
      }

      .panel-box {
        background: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 20px;
      }

      .messaging-section textarea.message-input {
        width: 100%;
        resize: none;
        padding: 8px;
        font-size: 14px;
        font-family: "Rubik", sans-serif;
        line-height: 1.4;
        border-radius: 6px;
        border: 1px solid #90caf9;
        background-color: #fff;
        box-sizing: border-box;
        height: 48px; /* 2 lines of text */
        outline: none;
      }

      .messaging-section textarea.message-input:focus {
        border-color: #1565c0;
        box-shadow: 0 0 0 2px rgba(21, 101, 192, 0.2);
      }

      .char-counter {
        font-size: 12px;
        color: #666;
        margin-top: 4px;
        margin-bottom: 8px;
        font-family: "Rubik", sans-serif;
      }

      .message-history {
        margin-top: 20px;
      }

      .message-history h4 {
        font-size: 16px;
        color: #1565c0;
        margin-bottom: 10px;
        font-family: "Rubik", sans-serif;
      }

      .message-list {
        list-style: none;
        padding-left: 0;
        max-height: 160px;
        overflow-y: auto;
        border: 1px solid #90caf9;
        border-radius: 6px;
        padding: 8px;
        background: #f9f9f9;
      }

      .message-list li {
        font-size: 14px;
        margin-bottom: 8px;
        line-height: 1.3;
        white-space: pre-line;
        font-family: "Rubik", sans-serif;
      }

      .message-list li.unread {
        font-weight: bold;
      }

      /* 🔒 Style for fully disabled protocol steps after resolution */
      .disabled-step {
        opacity: 0.5;
        pointer-events: none;
        background-color: #f1f1f1;
      }

      .disabled-step button,
      .disabled-step textarea,
      .disabled-step select {
        cursor: not-allowed;
      }

      #globalTimer {
        opacity: 1 !important;
        background: linear-gradient(135deg, #007bff, #0056b3) !important;
        color: white; /* Ensures text inside shows up */
      }

      #timerDisplay {
        color: white;
        font-size: 2em;
        display: block;
        visibility: visible;
        font-family: "Courier New", monospace;
        font-weight: bold;
        margin: 8px 0;
      }

      #timerInfo {
        color: white;
        font-size: 0.8em;
        line-height: 1.3;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 8px;
        margin: 8px 0;
        display: block;
        visibility: visible;
      }

      .middle-column-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        height: calc(100vh - 120px);
        overflow-y: auto;
        padding: 10px 0;
      }

      .global-timer {
        position: static !important;
        flex-shrink: 0;
      }

      .messaging-section {
        flex: 1;
        min-height: 200px;
      }

      .log-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        padding-bottom: 4px;
        border-bottom: 1px solid #e9ecef;
      }

      .log-timestamp {
        font-weight: bold;
        color: #495057;
        font-family: "Courier New", monospace;
      }

      .log-operator {
        font-size: 0.8em;
        color: #6c757d;
        font-weight: 500;
      }

      .log-source {
        color: #1565c0;
        font-size: 0.85em;
      }

      .log-date {
        font-size: 0.8em;
        color: #6c757d;
        font-family: "Courier New", monospace;
      }

      .log-content {
        color: #333;
        line-height: 1.5;
      }

      /* Specialized Log Content Styles */
      .dispatch-summary {
        font-weight: bold;
        color: #dc3545;
        margin-bottom: 8px;
        padding: 4px 0;
      }

      .location-info,
      .coordinates,
      .device-status,
      .device-stats,
      .dispatch-detail {
        margin: 4px 0;
        padding: 2px 0;
        font-size: 0.85em;
      }

      .gas-reading-detail {
        background: #f8f9fa;
        padding: 4px 8px;
        border-radius: 3px;
        margin-top: 4px;
        font-family: "Courier New", monospace;
        font-size: 0.8em;
      }

      .timer-action {
        color: #fd7e14;
        font-weight: 500;
      }

      .step-action {
        color: #007bff;
      }

      /* Log Type Colors - Update existing ones */
      .log-entry.step {
        border-left-color: #007bff;
      }
      .log-entry.timer {
        border-left-color: #ffc107;
      }
      .log-entry.resolution {
        border-left-color: #dc3545;
      }
      .log-entry.gas {
        border-left-color: #fd7e14;
      }
      .log-entry.system {
        border-left-color: #6c757d;
      }

      /* Override Modal Styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        z-index: 2000;
      }

      .override-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border: 3px solid #dc3545;
        border-radius: 10px;
        padding: 30px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        z-index: 2001;
        max-width: 500px;
        display: none;
      }

      .override-modal h3 {
        color: #dc3545;
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.2em;
      }

      .override-modal .gas-reading-display {
        background: #f8d7da;
        border: 1px solid #f5c6cb;
        border-radius: 4px;
        padding: 12px;
        margin: 15px 0;
        color: #721c24;
        font-weight: bold;
        text-align: center;
      }

      .override-modal select {
        width: 100%;
        padding: 10px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.9em;
      }

      .override-modal .modal-buttons {
        display: flex;
        gap: 10px;
        margin-top: 20px;
        justify-content: flex-end;
      }

      .override-modal .btn {
        padding: 10px 20px;
        font-size: 0.9em;
      }

      .status-badge.active {
        background: #007bff;
        color: white;
        animation: pulse 1.5s infinite;
      }

      .status-badge.waiting {
        background: #ffc107;
        color: #000;
      }

      .status-badge.skipped {
        background: #6c757d;
        color: white;
      }

      /* Pulsing animation for active state */
      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.4);
        }
        70% {
          box-shadow: 0 0 0 6px rgba(0, 123, 255, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0);
        }
      }

      .step.dispatch-step {
        opacity: 1 !important;
      }
    </style>
  </head>
  <body>
    <!-- Demo Controls -->
    <div class="demo-gear" id="demo-gear" onclick="toggleDemoPanel()"></div>
    <div class="demo-panel" id="demo-panel">
      <div class="demo-section" id="gas-section">
        <h4
          class="demo-section-header"
          onclick="toggleDemoSection('gas-section')"
        >
          Gas Alert Tests
        </h4>
        <div class="demo-section-content">
          <div class="demo-button-grid">
            <button
              class="btn btn-primary"
              onclick="loadAlert('h2s-response')"
              title="H₂S High - User confirms OK despite gas"
            >
              H₂S Override Test
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('co-spontaneous')"
              title="CO High - Gas normalizes after message"
            >
              CO Gas Normalization
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('gas-high-threshold')"
              title="H₂S High - Standard flow"
            >
              H₂S Standard Flow
            </button>
          </div>
        </div>
      </div>

      <div class="demo-section" id="nongas-section">
        <h4
          class="demo-section-header"
          onclick="toggleDemoSection('nongas-section')"
        >
          Non-Gas Tests
        </h4>
        <div class="demo-section-content">
          <div class="demo-button-grid">
            <button
              class="btn btn-primary"
              onclick="loadAlert('sos-immediate')"
              title="SOS Alert - Perfect dispatch YES flow"
            >
              SOS - Dispatch YES
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('no-motion')"
              title="Device Message - Manual texting test"
            >
              Message - Device Comms
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('fall-spontaneous')"
              title="Fall Detection - Protocol cycle test"
            >
              Fall - Protocol Cycle
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('no-motion')"
              title="No Motion - Standard test"
            >
              No Motion - Standard
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('missed-check-in')"
              title="Missed Check-In Protocol"
            >
              Check-In Test
            </button>
            <button
              class="btn btn-primary"
              onclick="loadAlert('message-test')"
              title="Device messaging and manual texting"
            >
              Message - Device Comms
            </button>
          </div>
        </div>
      </div>

      <div class="demo-button-single">
        <button class="btn btn-secondary" onclick="clearAlert()">
          Clear Alert
        </button>
      </div>
    </div>

    <!-- Alert Information Header -->
    <div class="header" id="alert-header">
      <h1 class="alert-title" id="alert-title">🚨 Alert Management</h1>

      <div class="alert-details">
        <div class="alert-info">
          <div class="info-item">
            <strong>Alert ID:</strong> <span id="alert-id">--</span>
          </div>
          <div class="info-item">
            <strong>Employee:</strong> <span id="employee-details">--</span>
          </div>
          <div class="info-item">
            <strong>Device:</strong> <span id="device-details">--</span>
          </div>
          <div class="info-item">
            <strong>Mobile:</strong> <span id="mobile-number">--</span>
          </div>
          <div class="info-item">
            <strong>Alert Time:</strong> <span id="alert-time">--</span>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <!-- Column 1: Protocol Log + Add Note -->
      <div
        class="left-column"
        style="grid-column: 1; display: flex; flex-direction: column; gap: 15px"
      >
        <!-- Protocol Log -->
        <div class="protocol-log panel-box">
          <h3>📋 Protocol Log</h3>
          <div class="log-container" id="protocolLog">
            <div class="log-placeholder">
              No alert loaded. Use demo controls to load an alert type and begin
              protocol.
            </div>
          </div>
        </div>

        <!-- Add Note -->
        <div class="panel-box">
          <h3>📝 Add Note</h3>
          <textarea
            id="manual-notes"
            class="manual-notes"
            placeholder="Add notes here..."
          ></textarea>
          <button
            class="btn btn-success"
            style="margin-top: 10px"
            onclick="addManualNote()"
          >
            Post Note
          </button>
        </div>
      </div>

      <!-- Column 2: Global Timer + Messaging -->
      <div class="middle-column-container" style="grid-column: 2">
        <!-- Global Timer -->
        <div class="global-timer timer-inactive panel-box" id="globalTimer">
          <h3>⏰ Timer</h3>
          <div class="timer-display" id="timerDisplay">--:--</div>
          <div class="timer-info" id="timerInfo">
            <strong>No active timer</strong>
          </div>
          <div class="timer-controls">
            <button
              class="cancel-btn"
              id="cancelTimerBtn"
              disabled
              onclick="cancelGlobalTimer()"
            >
              🛑 Cancel Timer
            </button>
          </div>
        </div>

        <!-- Messaging UI -->
        <div class="messaging-section panel-box">
          <h3>📨 This device supports messaging</h3>
          <textarea
            id="manual-message-input"
            class="message-input"
            rows="2"
            maxlength="32"
            placeholder="Enter custom message..."
          ></textarea>
          <div class="char-counter" id="charCounter">
            32 characters remaining
          </div>
          <button
            class="btn btn-primary"
            id="sendMessageBtn"
            onclick="sendManualMessage()"
            disabled
          >
            📤 Send
          </button>
          <div class="message-history" id="messageHistory">
            <h4>📬 Messages from Device</h4>
            <ul class="message-list" id="receivedMessages"></ul>
          </div>
        </div>
      </div>

      <!-- Column 3: Emergency Steps -->
      <div class="steps-section panel-box" style="grid-column: 3">
        <h3>🚨 Emergency Response Protocol</h3>
        <div id="protocol-content">
          <div class="protocol-placeholder">
            <div class="protocol-frame">
              <div class="placeholder-text">No protocol loaded</div>
              <div class="placeholder-subtitle">
                Alert type will load the relevant emergency response protocol
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Column 4: Gas Readings -->
      <div
        class="right-column"
        style="grid-column: 4; display: flex; flex-direction: column; gap: 15px"
      >
        <!-- Gas Readings -->
        <div class="panel-box" id="gasReadingsCard">
          <h3>🔎 Gas Readings (Live)</h3>
          <div class="triggered-by" id="triggeredBy" style="display: none">
            Alert Type: <span id="alert-trigger">--</span>
          </div>
          <div class="gas-reading" id="h2s-reading">
            <span
              >🟢 H₂S:
              <span class="gas-value" id="h2s-value">1.20 ppm</span></span
            >
            <span class="gas-status normal" id="h2s-status">NORMAL</span>
          </div>
          <div class="gas-reading" id="co-reading">
            <span
              >🟢 CO:
              <span class="gas-value" id="co-value">2.50 ppm</span></span
            >
            <span class="gas-status normal" id="co-status">NORMAL</span>
          </div>
          <div class="gas-reading" id="o2-reading">
            <span
              >🟢 O₂:
              <span class="gas-value" id="o2-value">20.90 %vol</span></span
            >
            <span class="gas-status normal" id="o2-status">NORMAL</span>
          </div>
          <div class="gas-reading" id="lel-reading">
            <span
              >🟢 LEL:
              <span class="gas-value" id="lel-value">0.50 %LEL</span></span
            >
            <span class="gas-status normal" id="lel-status">NORMAL</span>
          </div>
          <div class="last-updated" id="lastUpdated" style="display: none">
            Last updated: <span id="gas-timestamp">--</span>
          </div>
        </div>

        <!-- Device Connectivity Panel -->
        <div class="connectivity-panel" id="connectivityPanel">
          <h3>📡 Device Connectivity</h3>

          <div class="connectivity-item">
            <span>Status:</span>
            <span class="status-pill online" id="device-online-status"
              >🟢 Online</span
            >
          </div>

          <div class="connectivity-item">
            <span>Last Communication:</span>
            <span class="connectivity-value" id="last-comm-time"
              >Aug 02, 2025 at 17:11 MDT</span
            >
          </div>

          <div class="connectivity-item">
            <span>Battery Level:</span>
            <span class="connectivity-value" id="battery-level">85%</span>
          </div>

          <div class="connectivity-item">
            <span>Signal Strength:</span>
            <span class="connectivity-value" id="signal-strength">70%</span>
          </div>

          <div class="location-section">
            <h4>📍 Last Known Location</h4>

            <div class="connectivity-item">
              <span>Address:</span>
              <span class="connectivity-value" id="device-location"
                >144252 434 Ave E, Aldersyde, AB</span
              >
            </div>

            <div class="connectivity-item">
              <span>Coordinates:</span>
              <span class="connectivity-value" id="device-coordinates"
                >50.66004, -113.7685769</span
              >
            </div>

            <div class="connectivity-item">
              <span>Speed:</span>
              <span class="connectivity-value" id="device-speed">0.0 km/h</span>
            </div>

            <div class="connectivity-item">
              <span>Location Updated:</span>
              <span class="connectivity-value" id="location-timestamp"
                >Aug 02, 2025 at 15:28 MDT</span
              >
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Gas Override Modal -->
    <div class="modal-overlay" id="modalOverlay"></div>
    <div class="override-modal" id="overrideModal">
      <h3>⚠️ Gas levels are still elevated</h3>
      <p>Are you sure you want to resolve this alert?</p>

      <div class="gas-reading-display" id="overrideGasReading">
        Current Gas Reading: H₂S: 17.90 ppm (HIGH)
      </div>

      <label for="override-reason"
        ><strong>Please confirm the reason for override:</strong></label
      >
      <select id="override-reason">
        <option value="">-- Select override reason --</option>
        <option value="sensor-error">Sensor error</option>
        <option value="user-confirmed-safety">
          User confirmed they are okay
        </option>
        <option value="ec-confirmed-safety">
          Emergency contact confirmed user is okay
        </option>
        <option value="bump-test">Bump Test/Calibration in progress</option>
        <option value="other">Other</option>
      </select>

      <div class="modal-buttons">
        <button
          class="btn btn-danger"
          id="confirmOverrideBtn"
          disabled
          onclick="confirmOverride()"
        >
          Resolve Alert
        </button>
        <button class="btn btn-secondary" onclick="cancelOverride()">
          Cancel
        </button>
      </div>
    </div>
    <script>
      // ═══════════════════════════════════════════════════════════════
      // 📊 GLOBAL STATE & DATA
      // ═══════════════════════════════════════════════════════════════

      // Global state variables
      let currentAlert = null;
      let currentUser = null;
      let gasUpdateInterval = null;
      let dispatchMade = false;
      let globalTimerInterval = null;
      let activeTimerData = null;
      let globalTimerEndTime = null;
      let tabFlashInterval = null;
      let localTimerInterval = null;
      let beepTimeouts = [];
      let originalTitle = "Enhanced Blackline Live - Alert Management";

      // Protocol state management
      let protocolState = {
        completedSteps: [],
        currentStep: 1,
        dispatchMade: false,
        alertResolved: false,
        deviceMessageReceived: false,
        currentProtocol: null,
      };

      // Gas readings data
      const gasReadingsData = {
        "h2s-high": {
          h2s: { value: 17.9, status: "HIGH" },
          co: { value: 2.5, status: "NORMAL" },
          o2: { value: 20.9, status: "NORMAL" },
          lel: { value: 4.0, status: "NORMAL" },
        },
        "co-high": {
          h2s: { value: 1.2, status: "NORMAL" },
          co: { value: 250.0, status: "HIGH" },
          o2: { value: 20.9, status: "NORMAL" },
          lel: { value: 0.5, status: "NORMAL" },
        },
        "gas-high-threshold": {
          h2s: { value: 17.9, status: "HIGH" },
          co: { value: 2.5, status: "NORMAL" },
          o2: { value: 20.9, status: "NORMAL" },
          lel: { value: 4.0, status: "NORMAL" },
        },
        default: {
          h2s: { value: 1.2, status: "NORMAL" },
          co: { value: 2.5, status: "NORMAL" },
          o2: { value: 20.9, status: "NORMAL" },
          lel: { value: 0.5, status: "NORMAL" },
        },
      };

      let alertsFromJSON = null;

      // Load JSON data when page loads
      document.addEventListener("DOMContentLoaded", function () {
        // Load JSON alerts
        fetch("../cypress/fixtures/gas_alerts.json")
          .then((response) => response.json())
          .then((data) => {
            alertsFromJSON = data;
            console.log("Loaded alerts from JSON:", data.length, "alerts");
          })
          .catch((error) => {
            console.error("Failed to load JSON alerts:", error);
          });

        // Your existing initialization
        updateGasReadings("default");
        startGasMonitoring();

        // ADD MANUAL NOTES VALIDATION:
        const manualNotesTextarea = document.getElementById("manual-notes");
        const manualNotesButton = document.querySelector(
          'button[onclick="addManualNote()"]'
        );

        if (manualNotesTextarea && manualNotesButton) {
          // Initially disable button
          manualNotesButton.disabled = true;
          manualNotesButton.classList.add("btn-secondary");
          manualNotesButton.classList.remove("btn-success");

          // Enable/disable based on content
          manualNotesTextarea.addEventListener("input", function () {
            if (this.value.trim().length > 0) {
              manualNotesButton.disabled = false;
              manualNotesButton.classList.remove("btn-secondary");
              manualNotesButton.classList.add("btn-success");
            } else {
              manualNotesButton.disabled = true;
              manualNotesButton.classList.add("btn-secondary");
              manualNotesButton.classList.remove("btn-success");
            }
          });
        }
      });

      // Data Management System
      class AlertDataManager {
        static usersData = {
          "zach-sowell": {
            id: "373595",
            name: "Zach Sowell",
            device: "G7c-3571031421",
            mobile: "+1 470-505-6195",
            company: "WM - Corporate",
            work: "+1 470-505-6195",
            home: "+1 208-995-4975",
            emergencyContacts: [
              {
                name: "Daniel Reyes",
                phone: "+1-587-333-9271",
                role: "Site Supervisor",
              },
              {
                name: "Vanessa Liu",
                phone: "+1-780-452-1189",
                role: "Control Room Operator",
              },
            ],
          },
          "marcus-rodriguez": {
            id: "428756",
            name: "Marcus Rodriguez",
            device: "G7c-2947182653",
            mobile: "+1 403-555-0167",
            company: "Enbridge Pipelines",
            work: "+1 403-555-0167",
            home: "+1 403-555-0168",
            emergencyContacts: [
              {
                name: "Mike Chen",
                phone: "+1-403-555-0123",
                role: "Site Supervisor",
              },
              {
                name: "Sarah Kim",
                phone: "+1-403-555-0124",
                role: "Safety Coordinator",
              },
            ],
          },
        };

        static alertTypesData = {
          "h2s-spontaneous": {
            id: "h2s-spontaneous",
            displayName:
              "High threshold detected (H₂S) - Spontaneous - No Dispatch",
            user: "zach-sowell",
            protocolFile: "gas-emergency-protocol",
            gasType: "h2s-high",
            testType: "spontaneous",
            deviceConditions: {
              lastComm: 5,
              battery: 85,
              signal: 70,
              locationAge: 4320, // 3 days old (BAD - stale location)
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
          },
          "h2s-response": {
            id: "h2s-response",
            displayName:
              "High threshold detected (H₂S) - Response - No Dispatch",
            user: "zach-sowell",
            protocolFile: "gas-emergency-protocol",
            gasType: "h2s-high",
            testType: "response",
            deviceConditions: {
              lastComm: 5,
              battery: 85,
              signal: 70,
              locationAge: 2,
              deviceSpeed: 95, // 95 km/h (BAD - moving too fast)
              deviceStatus: "Online",
            },
          },
          "co-spontaneous": {
            id: "co-spontaneous",
            displayName: "High threshold detected (CO) - Dispatch",
            user: "marcus-rodriguez",
            protocolFile: "gas-emergency-protocol",
            gasType: "co-high",
            testType: "spontaneous",
            deviceConditions: {
              lastComm: 3,
              battery: 78,
              signal: 85,
              locationAge: 1,
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
          },
          "fall-spontaneous": {
            id: "fall-spontaneous",
            displayName: "Fall detection - Spontaneous - No Dispatch",
            user: "marcus-rodriguez",
            protocolFile: "fall-detection-protocol",
            gasType: "default",
            testType: "spontaneous",
            deviceConditions: {
              lastComm: 45, // 45 minutes ago (BAD - offline too long)
              battery: 5, // 5% (BAD - low battery)
              signal: 8, // 8% (BAD - weak signal)
              locationAge: 2,
              deviceSpeed: 0.0,
              deviceStatus: "Offline",
            },
          },
          "fall-detection": {
            id: "fall-detection",
            displayName: "Fall detection detected - Dispatch",
            user: "marcus-rodriguez",
            protocolFile: "fall-detection-protocol",
            gasType: "default",
            testType: "legacy",
            deviceConditions: {
              lastComm: 1,
              battery: 92,
              signal: 95,
              locationAge: 0.5,
              deviceSpeed: 2.1,
              deviceStatus: "Online",
            },
          },
          "sos-immediate": {
            id: "sos-immediate",
            displayName: "SOS alert - Immediate Help - Dispatch",
            user: "zach-sowell",
            protocolFile: "sos-protocol",
            gasType: "default",
            testType: "immediate-help",
            deviceConditions: {
              lastComm: 2,
              battery: 95,
              signal: 98,
              locationAge: 1,
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
          },
          "no-motion": {
            id: "no-motion",
            displayName: "No motion detected - No Dispatch",
            user: "marcus-rodriguez",
            protocolFile: "no-motion-protocol",
            gasType: "default",
            testType: "legacy",
            deviceConditions: {
              lastComm: 8,
              battery: 25,
              signal: 45,
              locationAge: 180, // 3 hours old (BAD - stale location)
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
          },
          "gas-high-threshold": {
            id: "gas-high-threshold",
            displayName: "High threshold detected (H₂S) - Dispatch",
            user: "zach-sowell",
            protocolFile: "gas-emergency-protocol",
            gasType: "h2s-high",
            testType: "legacy",
            deviceConditions: {
              lastComm: 4,
              battery: 88,
              signal: 82,
              locationAge: 2,
              deviceSpeed: 1.2,
              deviceStatus: "Online",
            },
          },
          "message-test": {
            id: "message-test",
            displayName: "Device Message Test - Dispatch",
            user: "marcus-rodriguez",
            protocolFile: "no-motion-protocol",
            gasType: "default",
            testType: "response",
            deviceConditions: {
              lastComm: 1,
              battery: 75,
              signal: 88,
              locationAge: 3,
              deviceSpeed: 0.5,
              deviceStatus: "Online",
            },
          },
          "missed-check-in": {
            id: "missed-check-in",
            displayName: "Missed check-in - No Dispatch",
            user: "zach-sowell",
            protocolFile: "missed-check-in-protocol",
            gasType: "default",
            testType: "response",
            deviceConditions: {
              lastComm: 12,
              battery: 35,
              signal: 22,
              locationAge: 3,
              deviceSpeed: 95.7, // 95.7 km/h (BAD - moving too fast)
              deviceStatus: "Online",
            },
          },
        };
      }
      // Protocol Factory
      class ProtocolFactory {
        static protocolsData = {
          "gas-emergency-protocol": {
            name: "Gas Emergency Protocol",
            steps: [
              {
                id: "step-1",
                title: "Call Device and Validate Need for Assistance", // ← Removed "STEP 1:"
                action: "call-device", // ← Changed from "Call G7c Device"
              },
              {
                id: "step-2",
                title:
                  "Send message 'Do you need help?' to device and wait 2 minutes",
                action: "message-device",
                timer: 120,
              },
              {
                id: "step-3",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-4",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-5",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "fall-detection-protocol": {
            name: "Fall Detection Protocol",
            steps: [
              {
                id: "step-1",
                title: "Send message 'Do you need help?' and wait 2 minutes",
                action: "message-device",
                timer: 120,
              },
              {
                id: "step-2",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-3",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-4",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "sos-protocol": {
            name: "SOS Emergency Protocol",
            steps: [
              {
                id: "step-1",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-2",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
              {
                id: "step-3",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
            ],
          },
          "no-motion-protocol": {
            name: "No Motion Detection Protocol",
            steps: [
              {
                id: "step-1",
                title: "Send message 'Do you need help?' and wait 5 minutes",
                action: "message-device",
                timer: 300,
              },
              {
                id: "step-2",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-3",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-4",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "missed-check-in-protocol": {
            name: "Missed Check-in Protocol",
            steps: [
              {
                id: "step-1",
                title: "Send message 'Do you need help?' and wait 2 minutes",
                action: "message-device",
                timer: 120,
              },
              {
                id: "step-2",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-3",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
            ],
          },

          "gas-emergency-protocol-high": {
            name: "Gas Emergency Protocol (High Levels)",
            steps: [
              {
                id: "step-1",
                title:
                  "Send message 'Leave the area, understood?' to device and wait 5 minutes",
                action: "message-device",
                timer: 300,
              },
              {
                id: "step-2",
                title: "Call Device and Validate Need for Assistance",
                action: "call-device",
              },
              {
                id: "step-3",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-4",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-5",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "gas-emergency-protocol-normal": {
            name: "Gas Emergency Protocol (Normal Levels)",
            steps: [
              {
                id: "step-1",
                title:
                  "Send message 'Do you need help?' to device and wait 5 minutes",
                action: "message-device",
                timer: 300,
              },
              {
                id: "step-2",
                title: "Call Device and Validate Need for Assistance",
                action: "call-device",
              },
              {
                id: "step-3",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-4",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-5",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
        };

        static getProtocolConfig(alertType) {
          const alertConfig = AlertDataManager.alertTypesData[alertType];
          return this.protocolsData[alertConfig.protocolFile];
        }
      }

      // Device Connectivity System
      class DeviceConnectivity {
        static currentStatus = {
          online: true,
          lastCommunication: new Date(),
          battery: 85,
          signal: 70,
          connectionType: "Cellular",
        };

        static isDeviceOnline() {
          const info = this.currentStatus;
          if (!info) return false;

          const lastComm = new Date(info.lastCommunication);
          const now = new Date();
          const diffMinutes = (now - lastComm) / (1000 * 60);
          if (diffMinutes > 30) return false; // Last communication ≤ 30 minutes ago
          if (info.battery <= 10) return false; // Battery > 10%
          if (info.signal <= 10) return false; // Signal strength > 10%

          return true;
        }

        static updateConnectivityDisplay() {
          const panel = document.getElementById("connectivityPanel");
          const statusElement = document.getElementById("device-online-status");
          const lastCommElement = document.getElementById("last-comm-time");
          const batteryElement = document.getElementById("battery-level");
          const signalElement = document.getElementById("signal-strength");

          if (!this.currentStatus) {
            if (panel) panel.style.display = "none";
            return;
          } else {
            if (panel) panel.style.display = "";
          }

          const isOnline = this.isDeviceOnline();

          // Status badge
          if (statusElement) {
            if (isOnline) {
              statusElement.textContent = "🟢 Online";
              statusElement.className = "status-pill online";
            } else {
              statusElement.textContent = "🔴 Offline";
              statusElement.className = "status-pill offline";
            }
          }

          // Battery with color coding
          if (batteryElement) {
            batteryElement.textContent = this.currentStatus.battery + "%";
            if (this.currentStatus.battery > 50) {
              batteryElement.style.color = "#28a745"; // Green
            } else if (this.currentStatus.battery > 20) {
              batteryElement.style.color = "#ffc107"; // Yellow
            } else {
              batteryElement.style.color = "#dc3545"; // Red
            }
          }

          // Signal strength
          if (signalElement) {
            signalElement.textContent = this.currentStatus.signal + "%";
          }

          // Last communication
          if (lastCommElement) {
            const lastComm = new Date(this.currentStatus.lastCommunication);
            const now = new Date();
            const diffMinutes = Math.floor((now - lastComm) / 60000);

            const timeStr =
              lastComm.toLocaleTimeString("en-US", {
                hour12: false,
                timeZone: "America/Denver",
                hour: "2-digit",
                minute: "2-digit",
              }) + " MDT";

            let timeAgo = "";
            if (diffMinutes === 0) timeAgo = "(just now)";
            else if (diffMinutes === 1) timeAgo = "(1 minute ago)";
            else if (diffMinutes < 60) timeAgo = `(${diffMinutes} minutes ago)`;
            else {
              const hours = Math.floor(diffMinutes / 60);
              const mins = diffMinutes % 60;
              timeAgo = `(${hours}h${mins > 0 ? ` ${mins}m` : ""} ago)`;
            }

            lastCommElement.textContent = `${timeStr} ${timeAgo}`;
            lastCommElement.style.color =
              diffMinutes > 5 || !isOnline ? "#dc3545" : "";
            lastCommElement.style.fontWeight =
              diffMinutes > 5 || !isOnline ? "bold" : "";
          }
        }

        // Test Scenarios for Demo/Testing
        static setDeviceOnlineScenario() {
          this.currentStatus = {
            online: true,
            lastCommunication: new Date(Date.now() - 2 * 60 * 1000), // 2 min ago
            battery: 85,
            signal: 70,
            connectionType: "Cellular",
          };
          this.updateConnectivityDisplay();
        }

        static setDeviceOfflineScenario(reason = "battery") {
          const scenarios = {
            battery: {
              lastCommunication: new Date(Date.now() - 10 * 60 * 1000),
              battery: 0,
              signal: 60,
            },
            signal: {
              lastCommunication: new Date(Date.now() - 15 * 60 * 1000),
              battery: 80,
              signal: 0,
            },
            communication: {
              lastCommunication: new Date(Date.now() - 45 * 60 * 1000),
              battery: 80,
              signal: 60,
            },
          };

          this.currentStatus = {
            online: false,
            connectionType: "Cellular",
            ...scenarios[reason],
          };
          this.updateConnectivityDisplay();
        }
      }

      function confirmOverride() {
        const overrideReasonSelect = document.getElementById("override-reason");
        const overrideReason = overrideReasonSelect.value;

        if (!overrideReason) {
          alert("Please select an override reason");
          return;
        }

        // Get the display text BEFORE clearing anything
        const overrideText =
          overrideReasonSelect.options[overrideReasonSelect.selectedIndex].text;

        const reasonSelect = document.getElementById("resolution-reason");
        let reason = reasonSelect ? reasonSelect.value : "";

        // If no resolution reason was selected, set a default one
        if (!reason) {
          reason = determineResolutionType(currentAlert);
          if (reasonSelect) {
            reasonSelect.value = reason;
          }
        }

        // Close the override modal
        document.getElementById("modalOverlay").style.display = "none";
        document.getElementById("overrideModal").style.display = "none";
        document.getElementById("override-reason").value = ""; // This clears it
        document.getElementById("confirmOverrideBtn").disabled = true;

        lockUIForResolution();

        // Pass the display text, not the value
        completeResolution(reason, overrideText); // Pass the text, not the value
      }

      function startGlobalTimer(
        stepId,
        label,
        contactName = "",
        durationInSeconds = 1800
      ) {
        // Store the ORIGINAL step ID for resolution tracking
        let originalStepId = stepId;

        // If this is an EC callback timer, preserve the original step
        if (stepId === "ec-callback") {
          // Try to get the original step from activeTimerData before overwriting
          originalStepId = activeTimerData?.originalStepId || "step-2";
        }

        // ✅ SET activeTimerData with originalStepId tracking
        activeTimerData = {
          stepId,
          label,
          contactName,
          durationInSeconds,
          originalStepId: originalStepId, // Track which step started this timer chain
        };

        const display = document.getElementById("timerDisplay");
        const info = document.getElementById("timerInfo");
        const globalTimer = document.getElementById("globalTimer");
        const startTime = new Date();

        // Set global end time for state tracking
        globalTimerEndTime = new Date(
          startTime.getTime() + durationInSeconds * 1000
        );

        // Update timer metadata
        const timerStart = document.getElementById("timerStart");
        const timerEnd = document.getElementById("timerEnd");
        if (timerStart)
          timerStart.textContent =
            startTime.toLocaleTimeString("en-US", {
              hour12: false,
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            }) + " hrs.";
        if (timerEnd)
          timerEnd.textContent =
            globalTimerEndTime.toLocaleTimeString("en-US", {
              hour12: false,
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            }) + " hrs.";

        // Update header
        info.innerHTML = contactName
          ? `<strong>${label}</strong><br>${contactName}`
          : `<strong>${label}</strong>`;

        // ✅ Build dropdown with ORIGINAL options only (removed dispatch-specific options)
        const controls = document.querySelector(".timer-controls");
        controls.innerHTML = `
    <select data-cy="global-cancel-dropdown" onchange="handleGlobalTimerCancellation(this.value)" 
            class="btn btn-secondary" 
            style="padding: 8px 16px; font-size: 0.8em; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: background 0.2s; width: 100%;"            
            aria-label="Cancel response timer">
        <option value="">Cancel Timer</option>
        <option value="user-callback">User called in and confirmed they are okay</option>
        <option value="ec-callback">Emergency contact called in and confirmed user is okay</option>
        <option value="ec-callback-30min">Emergency contact called in - Will contact user and call back (30 min timer)</option>
        <option value="device-offline">Device went offline</option>
        <option value="custom">Type reason</option>
    </select>
  `;

        // ✅ Start visual state
        globalTimer.classList.remove("timer-inactive");
        globalTimer.classList.add("timer-active");
        globalTimer.style.opacity = "1";
        globalTimer.style.display = "block";

        // Scroll timer into view when started
        globalTimer.scrollIntoView({ behavior: "smooth", block: "center" });

        // Log proper Step 2 message or timer message
        if (stepId === "step-2" && durationInSeconds === 120) {
          // Only for initial 2-minute timer
          addLogEntry(
            'Step 2: Sent "Do you need help?" to device. Waiting 2 minutes for reply.',
            "step"
          );
        }

        function updateDisplay() {
          const now = new Date();
          const remaining = Math.max(
            0,
            Math.floor((globalTimerEndTime - now) / 1000)
          );
          const mins = String(Math.floor(remaining / 60)).padStart(2, "0");
          const secs = String(remaining % 60).padStart(2, "0");
          display.textContent = `${mins}:${secs}`;

          if (remaining <= 0) {
            clearInterval(globalTimerInterval);
            globalTimerInterval = null;
            globalTimerEndTime = null;

            display.textContent = "00:00";
            info.innerHTML = `<strong>⏰ Timer expired</strong>`;

            // 🔊 Optional audio
            try {
              const audioCtx = new (window.AudioContext ||
                window.webkitAudioContext)();
              const osc = audioCtx.createOscillator();
              const gain = audioCtx.createGain();
              osc.type = "sine";
              osc.frequency.setValueAtTime(800, audioCtx.currentTime);
              gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
              osc.connect(gain);
              gain.connect(audioCtx.destination);
              osc.start();
              osc.stop(audioCtx.currentTime + 0.5);
            } catch (e) {
              console.warn("🔇 Audio not supported.");
            }

            // 🚨 Visual alert - Tab flashing (if function exists)
            if (typeof startTabFlashing === "function") {
              startTabFlashing("🚨 TIMER EXPIRED");
            }

            // Clear dropdown after expiry
            document.querySelector(".timer-controls").innerHTML = "";

            if (activeTimerData && activeTimerData.stepId) {
              // Handle timer expiration based on type
              if (activeTimerData.stepId === "ec-callback") {
                // EC callback timer expired
                addLogEntry(
                  `⏰ Emergency contact callback timer expired. Proceeding to next step.`,
                  "step"
                );
                // Check if this step has dispatch action (dispatch steps don't have next steps)
                const protocolConfig = ProtocolFactory.getProtocolConfig(
                  currentAlert.id
                );
                const stepConfig = protocolConfig.steps.find(
                  (step) => step.id === activeTimerData.originalStepId
                );

                if (stepConfig && stepConfig.action !== "dispatch") {
                  enableNextStep(activeTimerData.originalStepId);
                }
              } else if (activeTimerData.stepId.startsWith("step-")) {
                // Regular step timer expired
                const stepNum = activeTimerData.stepId.replace("step-", "");
                addLogEntry(
                  `Step ${stepNum}: Timer expired. Proceeding to next step.`,
                  "step"
                );
                markStepComplete(activeTimerData.stepId);

                // Check if this step has dispatch action (dispatch steps don't have next steps)
                const protocolConfig = ProtocolFactory.getProtocolConfig(
                  currentAlert.id
                );
                const stepConfig = protocolConfig.steps.find(
                  (step) => step.id === activeTimerData.stepId
                );

                if (stepConfig && stepConfig.action !== "dispatch") {
                  enableNextStep(activeTimerData.stepId);
                }
              }
            } else {
              // Non-step timers (if any)
              const expiredMessage = `⏰ TIMER EXPIRED: ${activeTimerData.label}`;
              addLogEntry(expiredMessage, "timer");
            }

            // Optional: Add gas reading log for gas alerts
            if (currentAlert && isGasAlert(currentAlert)) {
              const gasReading = getCurrentGasReading();
              addLogEntry(
                `Gas level: ${gasReading.status}\nGas Reading: ${gasReading.type}: ${gasReading.value}${gasReading.unit}`,
                "timer"
              );
            }
          }
        }

        updateDisplay();
        globalTimerInterval = setInterval(updateDisplay, 1000);
      }

      function handleGlobalTimerCancellation(reason) {
        if (!reason) return;

        console.log("Timer cancellation selected:", reason);

        // Stop the timer
        if (globalTimerInterval) {
          clearInterval(globalTimerInterval);
          globalTimerInterval = null;
          globalTimerEndTime = null;
        }

        // Get current step info BEFORE clearing activeTimerData
        let currentStepId = activeTimerData?.stepId;
        let originalStepId = activeTimerData?.originalStepId;

        // Handle EC callback special case
        if (currentStepId === "ec-callback") {
          currentStepId = originalStepId || "step-2";
          console.log("Adjusted currentStepId for EC callback:", currentStepId);
        }

        // Handle different cancellation reasons
        if (reason === "user-callback") {
          let logMessage =
            "User called in and confirmed they are okay. Resolving alert.";

          // Add gas info for gas alerts
          if (currentAlert && isGasAlert(currentAlert)) {
            const gasReading = getCurrentGasReading();
            logMessage +=
              "<br><br>" +
              "Gas Type: " +
              gasReading.type +
              "<br>" +
              "Gas Level: " +
              gasReading.status +
              "<br>" +
              "📊 Gas Reading: " +
              gasReading.value +
              gasReading.unit;
          }

          addLogEntry(logMessage, "step");

          // Mark the originating step as completed before triggering resolution
          if (currentStepId && canStepTriggerResolution(currentStepId)) {
            console.log("Marking step as completed:", currentStepId);
            markStepComplete(currentStepId);

            // Also mark main Step 4 as completed if this is a sub-step
            if (currentStepId.startsWith("step-4-")) {
              console.log("Also marking main Step 4 as completed");
              markStepComplete("step-4");
            }

            console.log("Step marked as completed, now triggering resolution");
          }

          // Use unified resolution flow
          console.log(
            "Calling triggerResolutionFlow with stepId:",
            currentStepId
          );
          if (currentStepId) {
            triggerResolutionFlow(currentStepId, "EC confirmed user okay");
          } else {
            console.error("NO STEP ID - Resolution flow failed!");
          }
        } else if (reason === "ec-callback") {
          let logMessage =
            "Emergency contact called in and confirmed user is okay. Resolving alert.";

          // Add gas info for gas alerts
          if (currentAlert && isGasAlert(currentAlert)) {
            const gasReading = getCurrentGasReading();
            logMessage +=
              "<br><br>" +
              "Gas Type: " +
              gasReading.type +
              "<br>" +
              "Gas Level: " +
              gasReading.status +
              "<br>" +
              "📊 Gas Reading: " +
              gasReading.value +
              gasReading.unit;
          }

          addLogEntry(logMessage, "step");

          // Use unified resolution flow
          console.log(
            "Calling triggerResolutionFlow with stepId:",
            currentStepId
          );
          if (currentStepId) {
            triggerResolutionFlow(currentStepId, "EC confirmed user okay");
          } else {
            console.error("NO STEP ID - Resolution flow failed!");
          }
        } else if (reason === "ec-callback-cancel-dispatch") {
          // Option 1: EC confirmed user is okay - RESOLVE IMMEDIATELY
          addLogEntry(
            "Emergency contact called in, advised to cancel dispatch. They confirmed user is okay. Resolving alert.",
            "step"
          );

          // Use unified resolution flow for immediate resolution
          if (currentStepId) {
            triggerResolutionFlow(
              currentStepId,
              "EC cancelled dispatch and confirmed user okay"
            );
          }
        } else if (reason === "ec-callback-cancel-dispatch-30min") {
          // Option 2: EC will check on user - START 30-MIN TIMER
          addLogEntry(
            "Emergency contact called in, advised to cancel dispatch. They will check on user and call back within 30 minutes.",
            "step"
          );

          // Cancel dispatch timer and start new 30-minute EC callback timer
          if (currentStepId) {
            startGlobalTimer(
              "ec-callback",
              "EC Callback",
              "Emergency Contact",
              1800
            );
          }

          // Mark current step as "Waiting" for EC callback
          const statusBadge = document.getElementById(
            currentStepId + "-status"
          );
          if (statusBadge) {
            statusBadge.textContent = "Waiting";
            statusBadge.className = "status-badge waiting";
          }

          // Update timer info display
          const info = document.getElementById("timerInfo");
          if (info) {
            info.innerHTML = "<strong>Waiting for EC callback</strong>";
          }

          // Don't resolve - just wait for EC callback
          return;
        } else if (reason === "ec-callback-30min") {
          addLogEntry(
            "Emergency contact called in, will check on user and call back within 30 minutes.",
            "step"
          );
          // Start new 30-minute timer
          if (currentStepId) {
            startGlobalTimer(
              "ec-callback",
              "EC Callback",
              "Emergency Contact",
              1800
            );
          }

          // Update timer info display to something better than "Timer cancelled"
          const info = document.getElementById("timerInfo");
          if (info) {
            info.innerHTML = "<strong>Waiting for EC callback</strong>";
          }

          // Don't show "Timer cancelled" - return early
          return;
        } else if (reason === "device-offline") {
          addLogEntry("Device went offline", "step");
          if (currentStepId) {
            markStepComplete(currentStepId);
            enableNextStep(currentStepId);
          }
        } else if (reason === "custom") {
          const customReason = prompt("Enter cancellation reason:");
          if (customReason) {
            addLogEntry("Timer cancelled: " + customReason, "step");
            if (currentStepId) {
              markStepComplete(currentStepId);
              enableNextStep(currentStepId);
            }
          }
        }

        // Reset timer display
        const display = document.getElementById("timerDisplay");
        const info = document.getElementById("timerInfo");
        const globalTimer = document.getElementById("globalTimer");

        if (display) display.textContent = "--:--";
        if (info) info.innerHTML = "<strong>Timer cancelled</strong>";
        if (globalTimer) {
          globalTimer.classList.remove("timer-active");
          globalTimer.classList.add("timer-inactive");
        }

        // Reset the dropdown
        const dropdown = document.querySelector(
          '[data-cy="global-cancel-dropdown"]'
        );
        if (dropdown) dropdown.value = "";

        // Clear activeTimerData ONLY if not starting a new timer
        if (
          reason !== "ec-callback-30min" &&
          reason !== "ec-callback-cancel-dispatch-30min"
        ) {
          activeTimerData = null;
        }
      }

      function cancelGlobalTimer() {
        if (!globalTimerInterval) return;

        clearInterval(globalTimerInterval);
        globalTimerInterval = null;
        globalTimerEndTime = null;

        const display = document.getElementById("timerDisplay");
        const info = document.getElementById("timerInfo");
        const timer = document.getElementById("globalTimer");
        const cancelBtn = document.getElementById("cancelTimerBtn");

        display.textContent = "--:--";
        info.innerHTML = "<strong>No active timer</strong>";
        timer.classList.remove("timer-active");
        timer.classList.add("timer-inactive");

        // Disable the cancel button after cancelling
        if (cancelBtn) {
          cancelBtn.disabled = true;
        }

        addLogEntry("Timer cancelled", "timer");
        // stopTabFlashing();
      }

      // ═══════════════════════════════════════════════════════════════
      // 🚨 PROTOCOL CONTROL FUNCTIONS
      // ═══════════════════════════════════════════════════════════════

      function initializeAlert(alertConfig, userConfig) {
        protocolState = {
          completedSteps: [],
          currentStep: 1,
          dispatchMade: false,
          alertResolved: false,
          deviceMessageReceived: false,
          currentProtocol: alertConfig.protocolFile,
        };
      }

      function getStepTimer(stepId) {
        if (!currentAlert) return null;

        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const stepConfig = protocolConfig.steps.find(
          (step) => step.id === stepId
        );

        return stepConfig ? stepConfig.timer : null;
      }

      function startStep(stepId) {
        console.log("startStep called with:", stepId);

        // Show outcome section for all steps EXCEPT Step 2 (which uses global timer)
        if (stepId !== "step-2") {
          const outcomeSection = document.getElementById(stepId + "-outcome");
          if (outcomeSection) {
            outcomeSection.style.display = "block";
          }
        }

        // Handle Step 2 messaging for all alert types
        if (stepId === "step-2") {
          const timerDuration = getStepTimer("step-2");

          if (timerDuration) {
            console.log("Timer duration found:", timerDuration);
            console.log("About to call startGlobalTimer");
            startGlobalTimer(
              "step-2",
              "Waiting for device reply",
              "",
              timerDuration
            );
            console.log("startGlobalTimer call completed");
          } else {
            console.log("No timer duration found for step-2");
          }

          // Simulate device response after 30-60 seconds
          setTimeout(() => {
            const responses = [
              "No",
              "Yes",
              "Send help",
              "False alarm",
              "I'm okay",
              "Understood",
            ];
            const randomResponse =
              responses[Math.floor(Math.random() * responses.length)];
            simulateDeviceResponse(randomResponse, true);
          }, Math.random() * 30000 + 30000);
        }
      }

      function validatePostButton(stepId) {
        const note = document.getElementById(stepId + "-note");

        // Find button by looking in the step's container instead of by ID
        const stepElement = document.getElementById(stepId);
        const button = stepElement
          ? stepElement.querySelector(
              'button[class*="btn"]:not([onclick*="startStep"])'
            )
          : null;

        if (!note || !button) return;

        const hasText = note.value.trim().length > 0;

        // Set button state based on textarea content
        button.disabled = !hasText;

        if (hasText) {
          button.classList.remove("btn-secondary");
          button.classList.add("btn-success");
        } else {
          button.classList.remove("btn-success");
          button.classList.add("btn-secondary");
        }
      }

      function autoPopulateFromDropdown(stepId) {
        const select = document.getElementById(stepId + "-select");
        const note = document.getElementById(stepId + "-note");

        if (!select || !note || !currentUser) return;

        const selectedValue = select.value;
        if (!selectedValue) return;

        let noteText = "";
        let shouldScrollToResolution = false;

        // Get current step action for action-based handling
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const currentStep = protocolConfig.steps.find(
          (step) => step.id === stepId
        );
        const stepAction = currentStep?.action;

        console.log("DEBUG: stepId =", stepId, "stepAction =", stepAction);

        // ACTION-BASED LOGIC
        if (stepAction === "call-user") {
          // GROUP 1: RESOLUTION OUTCOMES (User confirmed okay)
          if (selectedValue === "confirmed-ok") {
            noteText = `${stepId.replace("step-", "Step ")}: Called ${
              currentUser.name
            } at ${
              currentUser.mobile
            }. Confirmed they are okay. Resolving alert.`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "ec-callback") {
            noteText = `${stepId.replace(
              "step-",
              "Step "
            )}: Emergency contact called in and confirmed ${
              currentUser.name
            } is okay. Resolving alert.`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "user-callback") {
            noteText = `${stepId.replace(
              "step-",
              "Step "
            )}: User called in. Confirmed they are okay. Resolving alert.`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "ec-callback-30min") {
            noteText = `${stepId.replace(
              "step-",
              "Step "
            )}: Emergency contact called in, will check on user and call back within 30 minutes.`;
            // REMOVED TIMER LOGIC - will be handled in postNote()
          }
          // GROUP 2: VOICEMAIL OUTCOMES
          else if (selectedValue === "no-answer-voicemail") {
            noteText = `${stepId.replace("step-", "Step ")}: Called ${
              currentUser.name
            } at ${currentUser.mobile}, no answer. Left voicemail.`;
          } else if (selectedValue === "no-answer-already-left") {
            noteText = `${stepId.replace("step-", "Step ")}: Called ${
              currentUser.name
            } at ${
              currentUser.mobile
            }, no answer. Voicemail had already been left.`;
          }
          // GROUP 3: VOICEMAIL ISSUES
          else if (selectedValue === "no-answer-mailbox-full") {
            noteText = `${stepId.replace("step-", "Step ")}: Called ${
              currentUser.name
            } at ${
              currentUser.mobile
            }, no answer. Unable to leave voicemail, mailbox full.`;
          } else if (selectedValue === "no-answer-unable-voicemail") {
            noteText = `${stepId.replace("step-", "Step ")}: Called ${
              currentUser.name
            } at ${currentUser.mobile}, no answer. Unable to leave voicemail.`;
          } else if (selectedValue === "no-answer-mailbox-not-setup") {
            noteText = `${stepId.replace("step-", "Step ")}: Called ${
              currentUser.name
            } at ${
              currentUser.mobile
            }, no answer. Unable to leave voicemail, mailbox not set up yet.`;
          }
          // GROUP 4: CONNECTION/SYSTEM ISSUES
          else if (selectedValue === "no-phone-number") {
            noteText = `${stepId.replace(
              "step-",
              "Step "
            )}: Unable to call, user has no phone number assigned.`;
          } else if (selectedValue === "number-disconnected") {
            noteText = `${stepId.replace("step-", "Step ")}: Called ${
              currentUser.name
            } at ${
              currentUser.mobile
            }. Number has been changed, disconnected or no longer in service.`;
          } else if (selectedValue === "unable-to-connect") {
            noteText = `${stepId.replace("step-", "Step ")}: Called ${
              currentUser.name
            } at ${currentUser.mobile}. Unable to connect.`;
          }
        } else if (
          stepAction === "call-emergency-contacts" ||
          stepId === "step-4" ||
          stepId.startsWith("step-4-")
        ) {
          // Handle Step 4 and sub-steps
          if (selectedValue === "confirmed-ok") {
            noteText =
              "Emergency contact called in. Confirmed user is okay and advised to resolve alert";
            shouldScrollToResolution = true;
          } else if (selectedValue === "ec-callback") {
            noteText =
              "Emergency contact called in and confirmed user is okay. Resolving alert";
            shouldScrollToResolution = true;
          } else if (selectedValue === "user-callback") {
            noteText =
              "User called in. Confirmed they are okay. Resolving alert";
            shouldScrollToResolution = true;
          } else if (selectedValue === "ec-callback-30min") {
            noteText =
              "Emergency contact called in, will check on user and call back within 30 minutes";
            // REMOVED TIMER LOGIC - will be handled in postNote()
          } else if (selectedValue === "no-answer") {
            noteText = "No answer from contacts";
          } else if (selectedValue === "completed") {
            noteText = "Contacted emergency contacts";
          } else if (selectedValue === "no-answer-voicemail") {
            noteText = "No answer, left voicemail";
          } else if (selectedValue === "no-answer-unable") {
            noteText = "No answer, unable to leave voicemail";
          } else if (selectedValue === "wrong-number") {
            noteText = "Wrong number";
          } else if (selectedValue === "unable-to-connect") {
            noteText = "Unable to connect";
          }
        } else if (stepAction === "dispatch") {
          // Handle Step 5 user/EC callback options
          if (selectedValue === "user-callback") {
            noteText =
              "User called in. Confirmed they are okay. Resolving alert";
            shouldScrollToResolution = true;
          } else if (selectedValue === "ec-callback") {
            noteText =
              "Emergency contact called in and confirmed user is okay. Resolving alert";
            shouldScrollToResolution = true;
          } else if (selectedValue === "ec-callback-cancel-dispatch") {
            noteText =
              "Emergency contact called in, advised to cancel dispatch. They confirmed user is okay / will check on user. Resolving alert";
            shouldScrollToResolution = true;
          } else if (selectedValue === "ec-callback-cancel-dispatch-30min") {
            noteText =
              "Emergency contact called in, advised to cancel dispatch. They will check on user and call back within 30 minutes";
            // Timer logic will be handled in postNote()
          } else if (selectedValue === "ec-callback-30min") {
            noteText =
              "Emergency contact called in, will check on user and call back within 30 minutes";
            // NO TIMER LOGIC FOR DISPATCH STEP - will be handled in postNote()
          }
        }
        // FALLBACK: STEP-BASED LOGIC (for protocols without action defined)
        else if (stepId === "step-1") {
          if (selectedValue === "confirmed-ok") {
            noteText =
              "Spoke with " +
              currentUser.name +
              ". Confirmed they are okay. Resolving alert";
            shouldScrollToResolution = true;
          } else if (selectedValue === "user-callback") {
            noteText =
              "User called in. Confirmed they are okay. Resolving alert";
            shouldScrollToResolution = true;
          } else if (selectedValue === "no-answer") {
            noteText = "Called device. No answer";
          } else if (selectedValue === "unable-to-call") {
            noteText = "Unable to call, device offline";
          }
        } else if (stepId === "step-2") {
          if (selectedValue === "unable-to-send") {
            noteText = "Unable to send text message, device offline";
          } else if (selectedValue === "no-response") {
            noteText =
              'Sent message "Do you need help?" to device. No response received';
            setTimeout(() => {
              note.value = noteText;
              addLogEntry(noteText, "step");
              markStepComplete(stepId);
              enableNextStep(stepId);
              note.value = "";
              note.disabled = false;
              validatePostButton(stepId);
            }, 100);
            return;
          } else if (selectedValue === "device-no") {
            noteText = 'Received message "No" from device. User confirmed okay';
            shouldScrollToResolution = true;
          } else if (selectedValue === "issue-resolved") {
            noteText =
              'Received message "Issue resolved" from device. User confirmed okay';
            shouldScrollToResolution = true;
          } else if (selectedValue === "false-alarm") {
            noteText =
              'Received message "False alarm" from device. User confirmed okay';
            shouldScrollToResolution = true;
          }
        } else if (stepId === "step-3") {
          console.log("Step 3 - selectedValue:", selectedValue);
          if (selectedValue === "confirmed-ok") {
            noteText = `Called ${currentUser.name} at ${currentUser.mobile}. Confirmed they are OK`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "ec-callback") {
            noteText = `Emergency contact called in and confirmed ${currentUser.name} is okay. Resolving alert`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "user-callback") {
            noteText = `User called in. Confirmed they are okay. Resolving alert`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "ec-callback-30min") {
            noteText = `Emergency contact called in, will check on user and call back within 30 minutes`;
            // REMOVED TIMER LOGIC - will be handled in postNote()
          } else if (selectedValue === "no-answer-voicemail") {
            noteText = `${stepId.replace("step-", "Step ")}: Called ${
              currentUser.name
            } at ${currentUser.mobile}, no answer. Left voicemail`;
          } else if (selectedValue === "no-answer-already-left") {
            noteText = `${stepId.replace("step-", "Step ")}: Called ${
              currentUser.name
            } at ${
              currentUser.mobile
            }, no answer. Voicemail had already been left`;
          } else if (selectedValue === "no-answer-mailbox-full") {
            noteText = `${stepId.replace("step-", "Step ")}: Called ${
              currentUser.name
            } at ${
              currentUser.mobile
            }, no answer. Unable to leave voicemail, mailbox full`;
          } else if (selectedValue === "no-answer-unable-voicemail") {
            noteText = `${stepId.replace("step-", "Step ")}: Called ${
              currentUser.name
            } at ${currentUser.mobile}, no answer. Unable to leave voicemail`;
          } else if (selectedValue === "no-answer-mailbox-not-setup") {
            noteText = `${stepId.replace("step-", "Step ")}: Called ${
              currentUser.name
            } at ${
              currentUser.mobile
            }, no answer. Unable to leave voicemail, mailbox not set up yet`;
          } else if (selectedValue === "no-phone-number") {
            noteText = `${stepId.replace(
              "step-",
              "Step "
            )}: Unable to call, user has no phone number assigned`;
          } else if (selectedValue === "number-disconnected") {
            noteText = `${stepId.replace(
              "step-",
              "Step "
            )}: Number has been changed, disconnected or no longer in service`;
          } else if (selectedValue === "unable-to-connect") {
            noteText = `${stepId.replace("step-", "Step ")}: Unable to connect`;
          }
        }

        if (noteText) {
          note.value = noteText;
          console.log("Setting noteText:", noteText);
          validatePostButton(stepId);
        } else {
          console.log("No noteText generated for:", selectedValue);
        }
      }

      function postNote(stepId) {
        console.log(
          "=== postNote called for:",
          stepId,
          "at",
          new Date().toISOString()
        );

        const note = document.getElementById(stepId + "-note");
        const select = document.getElementById(stepId + "-select");

        if (!note || !note.value.trim()) {
          alert("Please enter text before posting note");
          return;
        }

        // Store selected outcome BEFORE clearing
        const selectedOutcome = select ? select.value : "";
        const logMessage = note.value.trim();

        // ADD DEBUG LINES HERE:
        console.log("Selected outcome:", selectedOutcome);
        console.log("Log message:", logMessage);
        console.log("About to check Step 5...");

        // Special validation for Dispatch steps
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const stepConfig = protocolConfig.steps.find(
          (step) => step.id === stepId
        );
        const stepAction = stepConfig?.action;

        if (stepAction === "dispatch") {
          // CHECK IF THIS IS A USER/EC CALLBACK (new options)
          if (
            selectedOutcome === "user-callback" ||
            selectedOutcome === "ec-callback" ||
            selectedOutcome === "ec-callback-cancel-dispatch" ||
            selectedOutcome === "ec-callback-cancel-dispatch-30min" ||
            selectedOutcome === "ec-callback-30min"
          ) {
            // Handle user/EC callbacks - cancel any active timers and use normal step processing

            // Cancel any active dispatch timer (except for timer scenarios)
            if (
              globalTimerInterval &&
              selectedOutcome !== "ec-callback-30min" &&
              selectedOutcome !== "ec-callback-cancel-dispatch-30min"
            ) {
              cancelGlobalTimer();
            }

            // For ec-callback-cancel-dispatch-30min, cancel dispatch timer and start EC timer
            if (selectedOutcome === "ec-callback-cancel-dispatch-30min") {
              // Cancel dispatch timer and start new 30-minute EC callback timer
              if (currentUser && currentUser.emergencyContacts[0]) {
                const ec = currentUser.emergencyContacts[0];
                startGlobalTimer(stepId, "EC Callback", ec.name, 1800);
              }

              // Just log the EC callback promise and continue
              addLogEntry(logMessage, "step");

              // Mark step as "Waiting" for EC callback
              const statusBadge = document.getElementById(stepId + "-status");
              if (statusBadge) {
                statusBadge.textContent = "Waiting";
                statusBadge.className = "status-badge waiting";
              }

              // Clear textarea but keep it enabled
              note.value = "";
              note.disabled = false;
              validatePostButton(stepId);

              return; // Don't mark step complete or trigger resolution
            }

            // For ec-callback-30min, just log and continue with dispatch timer
            if (selectedOutcome === "ec-callback-30min") {
              // Start 30-minute timer silently when posting the note
              if (currentUser && currentUser.emergencyContacts[0]) {
                const ec = currentUser.emergencyContacts[0];
                startGlobalTimer(stepId, "EC Callback", ec.name, 1800);
              }

              // Just log the EC callback promise and continue
              addLogEntry(logMessage, "step");

              // Clear textarea but keep it enabled
              note.value = "";
              note.disabled = false;
              validatePostButton(stepId);

              return; // Don't mark step complete or trigger resolution
            }
            // Continue to normal step processing for other callback types
          } else {
            // Handle regular dispatch decisions
            const decision = document.getElementById("dispatch-decision").value;
            const skipReasonElement = document.getElementById("skip-reason");
            const dispatchTypeElement =
              document.getElementById("dispatch-type");

            const reason = skipReasonElement
              ? skipReasonElement.options[skipReasonElement.selectedIndex].text
              : "";
            const selectedService = dispatchTypeElement
              ? dispatchTypeElement.value
              : "";

            // Create comprehensive dispatch log with protocol reset message
            let dispatchLog = generateDispatchProtocolLog(
              decision,
              reason,
              selectedService,
              stepId
            );

            // For NO dispatch, add the protocol reset message to the same log entry
            if (decision === "no") {
              const protocolConfig = ProtocolFactory.getProtocolConfig(
                currentAlert.id
              );
              const stepCount = protocolConfig.steps.length - 1; // Exclude dispatch step
              const stepNumbers = Array.from(
                { length: stepCount },
                (_, i) => i + 1
              ).join(", ");

              dispatchLog += `\n\nRepeating STEPS ${stepNumbers} until someone is reached.`;
            }

            addLogEntry(dispatchLog, "step");

            // ADD TIMER FOR "YES" DISPATCH:
            if (decision === "yes") {
              dispatchMade = true;
              startGlobalTimer(
                stepId,
                "call back for an update on dispatch",
                "Emergency Services",
                1800
              );

              // For "YES" dispatch, mark as "Waiting" - don't complete until timer expires or callback
              const statusBadge = document.getElementById(stepId + "-status");
              if (statusBadge) {
                statusBadge.textContent = "Waiting";
                statusBadge.className = "status-badge waiting";
              }
            } else {
              // For "NO" dispatch (protocol reset), mark as completed
              markStepComplete(stepId);
            }

            // Clear Step 5 textarea but keep it enabled
            note.value = "";
            note.disabled = false;
            validatePostButton(stepId);

            // Hide the conditional containers
            handleDispatchDecision();

            // Handle step disabling based on dispatch decision
            if (decision === "no") {
              setTimeout(() => {
                // Reset protocol to initial state
                const allSteps = document.querySelectorAll(".step");
                allSteps.forEach((step) => {
                  if (step.id !== stepId) {
                    step.classList.remove("completed", "active");

                    const status = step.querySelector(".status-badge");
                    if (status) {
                      status.textContent = "Pending";
                      status.classList.remove("completed");
                    }

                    // RE-ENABLE DROPDOWNS AND TEXTAREAS for sub-steps
                    const selects = step.querySelectorAll("select");
                    selects.forEach((select) => (select.disabled = false));

                    const textareas = step.querySelectorAll("textarea");
                    textareas.forEach(
                      (textarea) => (textarea.disabled = false)
                    );

                    const button = step.querySelector(
                      'button:not([onclick*="postNote"])'
                    );
                    if (button) {
                      if (step.id === "step-1") {
                        button.disabled = false;
                        button.classList.remove("btn-secondary");
                        button.classList.add("btn-primary");
                        step.classList.add("active");
                      } else {
                        button.disabled = true;
                        button.classList.remove("btn-primary");
                        button.classList.add("btn-secondary");
                      }
                    }
                  }
                });

                // Reset protocol state
                protocolState.completedSteps = [];
                protocolState.currentStep = 1;

                const protocolConfig = ProtocolFactory.getProtocolConfig(
                  currentAlert.id
                );
                const stepCount = protocolConfig.steps.length - 1; // Exclude dispatch step
                const stepNumbers = Array.from(
                  { length: stepCount },
                  (_, i) => i + 1
                ).join(", ");

                // Disable current dispatch step after protocol reset
                const currentDispatchStep = document.getElementById(stepId);
                if (currentDispatchStep) {
                  currentDispatchStep.style.opacity = "0.6";

                  const buttons =
                    currentDispatchStep.querySelectorAll("button");
                  buttons.forEach((btn) => (btn.disabled = true));

                  // Disable only dispatch-specific selects, NOT User/EC callback
                  const dispatchSelects = currentDispatchStep.querySelectorAll(
                    "#dispatch-decision, #dispatch, #skip-reason"
                  );
                  dispatchSelects.forEach((select) => (select.disabled = true));

                  // Keep User/EC callback select active for incoming calls
                  const callbackSelect = currentDispatchStep.querySelector(
                    "#" + stepId + "-select"
                  );
                  if (callbackSelect) {
                    callbackSelect.disabled = false;
                  }

                  // Keep textarea and Post Note button active for callback logging
                  const textareas =
                    currentDispatchStep.querySelectorAll("textarea");
                  textareas.forEach((textarea) => (textarea.disabled = false));

                  // Keep Post Note button active
                  const postButtons = currentDispatchStep.querySelectorAll(
                    '[onclick*="postNote"]'
                  );
                  postButtons.forEach((button) => (button.disabled = false));
                }

                // SCROLL TO STEP 1 AND RESTART CYCLE
                setTimeout(() => {
                  const step1 = document.getElementById("step-1");
                  if (step1) {
                    // Scroll to Step 1 to restart the cycle
                    step1.scrollIntoView({
                      behavior: "smooth",
                      block: "center",
                    });

                    // Ensure Step 1 is properly highlighted as active
                    step1.classList.add("active");
                    step1.style.opacity = "1";

                    // Update Step 1 status badge
                    const step1Status =
                      document.getElementById("step-1-status");
                    if (step1Status) {
                      step1Status.textContent = "Active";
                      step1Status.className = "status-badge active";
                    }
                  }
                }, 500); // Short delay after protocol reset
              }, 1000);
            } else {
              // For "yes" decision, disable dispatch controls but keep User/EC callback active
              const step = document.getElementById(stepId);
              if (step) {
                step.style.opacity = "0.6";

                // Disable only dispatch-specific buttons, NOT Post Note
                const dispatchButtons = step.querySelectorAll(
                  'button:not([onclick*="postNote"])'
                );
                dispatchButtons.forEach((btn) => (btn.disabled = true));

                // Disable only dispatch selects, NOT User/EC callback
                const dispatchSelects = step.querySelectorAll(
                  "#dispatch-decision, #dispatch, #skip-reason"
                );
                dispatchSelects.forEach((select) => (select.disabled = true));

                // Keep User/EC callback and textarea active for incoming calls
                const callbackSelect = step.querySelector(
                  "#" + stepId + "-select"
                );
                const textareas = step.querySelectorAll("textarea");
                const postButtons = step.querySelectorAll(
                  '[onclick*="postNote"]'
                );

                if (callbackSelect) callbackSelect.disabled = false;
                textareas.forEach((textarea) => (textarea.disabled = false));
                postButtons.forEach((button) => (button.disabled = false));
              }
            }

            return; // Skip normal logging for dispatch decisions only
          }
        }

        // CHECK FOR 30-MINUTE TIMER OUTCOMES and start timer here (for non-dispatch steps)
        if (
          selectedOutcome === "ec-callback-30min" &&
          stepAction !== "dispatch"
        ) {
          // Start 30-minute timer silently when posting the note
          if (currentUser && currentUser.emergencyContacts[0]) {
            const ec = currentUser.emergencyContacts[0];
            startGlobalTimer(stepId, "EC Callback", ec.name, 1800);
          }

          // Log the EC callback message
          addLogEntry(logMessage, "step");

          // Store the original step ID so timer cancellation knows which step to complete
          if (activeTimerData) {
            activeTimerData.originalStepId = stepId;
          }

          // Mark the step status as "Waiting"
          const statusBadge = document.getElementById(stepId + "-status");
          if (statusBadge) {
            statusBadge.textContent = "Waiting";
            statusBadge.className = "status-badge waiting";
          }

          // Disable other steps while waiting for EC callback
          if (stepId === "step-3") {
            // Disable Step 4 buttons when Step 3 has timer
            const step41Button = document.querySelector(
              "#step-4-1 button:not([onclick*='postNote'])"
            );
            const step42Button = document.querySelector(
              "#step-4-2 button:not([onclick*='postNote'])"
            );
            if (step41Button) step41Button.disabled = true;
            if (step42Button) step42Button.disabled = true;
          } else if (stepId === "step-4-1") {
            // Disable Step 4-2 button when Step 4-1 has timer
            const step42Button = document.querySelector(
              "#step-4-2 button:not([onclick*='postNote'])"
            );
            if (step42Button) step42Button.disabled = true;
          }

          // Clear textarea but keep it enabled
          note.value = "";
          note.disabled = false;
          validatePostButton(stepId);

          return; // Don't enable next step - wait for timer
        }

        // Add log entry for gas alerts with gas reading info
        if (currentAlert && isGasAlert(currentAlert)) {
          try {
            const gasReading = getCurrentGasReading();

            // Check if this is a "confirmed OK" scenario
            const isConfirmedOK =
              selectedOutcome === "confirmed-ok" ||
              selectedOutcome === "ec-callback" ||
              selectedOutcome === "user-callback" ||
              logMessage.toLowerCase().includes("confirmed they are ok") ||
              logMessage.toLowerCase().includes("confirmed ok");

            if (isConfirmedOK) {
              // Full gas formatting ONLY for confirmed OK
              const formattedMessage =
                logMessage +
                ". Gas readings have not normalized. Resolving alert.<br><br>" +
                "Gas Type: " +
                gasReading.type +
                "<br>" +
                "Gas Level: " +
                gasReading.status +
                "<br>" +
                "Gas Reading: " +
                gasReading.value +
                gasReading.unit;
              addLogEntry(formattedMessage, "step");
            } else {
              // Simple log for other outcomes (no answer, etc.)
              addLogEntry(logMessage, "step");
            }
          } catch (e) {
            console.error("ERROR in gas logging:", e);
            addLogEntry(logMessage, "step");
          }
        } else {
          addLogEntry(logMessage, "step");
        }

        // Mark current step as completed
        const step = document.getElementById(stepId);
        const statusBadge = document.getElementById(stepId + "-status");

        if (step) {
          step.classList.remove("active");
          step.classList.add("completed");
        }

        if (statusBadge) {
          statusBadge.textContent = "Completed";
          statusBadge.classList.add("completed");
        }

        // Clear note and reset
        note.value = "";
        if (select) select.value = "";
        note.disabled = false;
        validatePostButton(stepId);

        // Check for "Confirmed OK" outcomes
        const isConfirmedOK =
          selectedOutcome === "confirmed-ok" ||
          selectedOutcome === "ec-callback" ||
          selectedOutcome === "user-callback" ||
          logMessage.toLowerCase().includes("confirmed they are ok") ||
          logMessage.toLowerCase().includes("confirmed ok");

        if (isConfirmedOK) {
          triggerResolutionFlow(stepId, "User confirmed okay");
          return;
        }

        // Handle EC step progression
        if (typeof stepId === "string" && stepId.startsWith("step-4-")) {
          handleECStepCompletion(stepId);
        } else {
          enableNextStep(stepId);
        }
      }

      function handleECStepCompletion(stepId) {
        const ecIndex = parseInt(stepId.split("-")[2]);
        const nextECIndex = ecIndex + 1;
        const nextECStepId = "step-4-" + nextECIndex;

        const nextECStep = document.getElementById(nextECStepId);
        if (nextECStep) {
          // Enable next EC sub-step
          const nextButton = nextECStep.querySelector(
            'button:not([onclick*="postNote"])'
          );
          if (nextButton) {
            nextButton.disabled = false;
            nextButton.classList.remove("btn-secondary");
            nextButton.classList.add("btn-primary");
          }
        } else {
          // No more EC sub-steps - check if all EC steps are completed
          const step41Status = document.getElementById("step-4-1-status");
          const step42Status = document.getElementById("step-4-2-status");

          // If both EC sub-steps are completed, mark main Step 4 as completed and enable Step 5
          if (
            step41Status?.textContent === "Completed" &&
            step42Status?.textContent === "Completed"
          ) {
            // Mark main Step 4 as completed
            markStepComplete("step-4");

            // Enable Step 5
            enableNextStep("step-4");
          }
        }
      }

      function markStepComplete(stepId) {
        const step = document.getElementById(stepId);
        const statusBadge = document.getElementById(stepId + "-status");

        if (step) {
          step.classList.add("completed");
          step.classList.remove("active");

          // Make step look completed but keep it interactive
          step.style.opacity = "0.8"; // Less faded
          // REMOVED: step.style.pointerEvents = "none";

          // Only disable the main action button, not Post Note
          const actionButton = step.querySelector(
            'button:not([onclick*="postNote"])'
          );
          if (actionButton) {
            actionButton.disabled = true;
            actionButton.classList.remove("btn-primary");
            actionButton.classList.add("btn-secondary");
          }

          // Disable dropdowns but keep textareas and post buttons enabled
          const selects = step.querySelectorAll("select");
          selects.forEach((select) => (select.disabled = true));

          // DON'T disable textareas or Post Note buttons
          // Keep them available for additional notes
        }

        if (statusBadge) {
          statusBadge.textContent = "Completed";
          statusBadge.className = "status-badge completed"; // This replaces ALL classes
        }

        // stopTabFlashing();
        protocolState.completedSteps.push(stepId);

        // RE-EVALUATE DISPATCH CONDITIONS AFTER STEP COMPLETION
        silentlyUpdateDispatchConditions();

        // AUTO-SCROLL: Enable and scroll to next step
        enableNextStep(stepId);
      }

      function blockRemainingSteps(currentStepId, reason) {
        console.log(
          "=== blockRemainingSteps called with:",
          currentStepId,
          "reason:",
          reason
        );

        // Special handling for sub-steps (like step-4-1)
        if (currentStepId.includes("-")) {
          console.log("=== Handling sub-step:", currentStepId);

          // FIX: Properly split step-4-1 into parts
          const parts = currentStepId.split("-"); // ["step", "4", "1"]
          const mainStep = parts[0] + "-" + parts[1]; // "step-4"
          const subStep = parts[2]; // "1"

          console.log("mainStep:", mainStep, "subStep:", subStep);

          // Skip remaining sub-steps of the same main step
          const allSubSteps = document.querySelectorAll(`[id^="${mainStep}-"]`);
          console.log(
            "Found sub-steps:",
            Array.from(allSubSteps).map((el) => el.id)
          );

          allSubSteps.forEach((step) => {
            const stepParts = step.id.split("-");
            if (stepParts.length >= 3) {
              // Ensure it's actually a sub-step like step-4-2
              const subStepNum = parseInt(stepParts[2]);
              const currentSubNum = parseInt(subStep);

              console.log(
                "Checking sub-step:",
                step.id,
                "subStepNum:",
                subStepNum,
                "vs currentSubNum:",
                currentSubNum
              );

              if (subStepNum > currentSubNum) {
                console.log("SKIPPING sub-step:", step.id);
                // Hide the dropdown for skipped steps
                const outcomeSection = document.getElementById(
                  step.id + "-outcome"
                );
                if (outcomeSection) {
                  outcomeSection.style.display = "none";
                }
                const status = document.getElementById(step.id + "-status");
                if (status) {
                  status.textContent = "Skipped. User confirmed OK.";
                  status.className = "status-badge";
                  status.style.background = "#6c757d";
                  status.style.color = "white";
                  status.style.animation = "none";
                  status.style.transition = "none";
                  status.classList.remove(
                    "completed",
                    "active",
                    "pulsing",
                    "timer-active",
                    "timer-alert"
                  );
                }
                step.style.opacity = "0.5";
                step.classList.remove("active");
              }
            }
          });
        }

        // ALSO mark the main step as completed when resolving from a sub-step
        const parts = currentStepId.split("-");
        const mainStepId = parts[0] + "-" + parts[1]; // "step-4"

        console.log("Marking main step as completed:", mainStepId);

        const mainStep = document.getElementById(mainStepId);
        const mainStatus = document.getElementById(mainStepId + "-status");

        if (mainStep) {
          mainStep.classList.remove("active");
          mainStep.classList.add("completed");
        }

        if (mainStatus) {
          mainStatus.textContent = "Completed";
          mainStatus.className = "status-badge completed";
          mainStatus.style.animation = "none";
          mainStatus.style.transition = "none";
        }

        // Get all steps after current one, including sub-steps
        const allSteps = document.querySelectorAll(".step");
        const currentIndex = parseInt(
          currentStepId.replace(/step-(\d+).*/, "$1")
        );

        console.log("currentIndex extracted:", currentIndex);

        allSteps.forEach((step) => {
          if (step.id && step.id.startsWith("step-")) {
            const stepIndex = parseInt(step.id.replace(/step-(\d+).*/, "$1"));

            console.log(
              "Processing step:",
              step.id,
              "stepIndex:",
              stepIndex,
              "vs currentIndex:",
              currentIndex
            );

            // Skip steps that come after the current step
            if (stepIndex > currentIndex) {
              console.log("SKIPPING main step:", step.id);
              // Hide the dropdown for skipped steps
              const outcomeSection = document.getElementById(
                step.id + "-outcome"
              );
              if (outcomeSection) {
                outcomeSection.style.display = "none";
              }
              const nextStatus = document.getElementById(step.id + "-status");

              step.style.opacity = "0.5";
              step.classList.remove("active");

              const nextButton = step.querySelector(
                'button:not([onclick*="postNote"])'
              );
              if (
                nextButton &&
                !nextButton.onclick.toString().includes("callDispatch")
              ) {
                nextButton.disabled = true;
                nextButton.classList.remove("btn-primary");
                nextButton.classList.add("btn-secondary");
                nextButton.style.pointerEvents = "none";
              }

              // Keep the textarea and post note button enabled
              const textarea = document.getElementById(step.id + "-note");
              const postBtn = document.getElementById(step.id + "-post-btn");

              if (textarea) {
                textarea.disabled = false;
                textarea.style.pointerEvents = "auto";
              }

              if (postBtn) {
                postBtn.style.pointerEvents = "auto";
                validatePostButton(step.id);
              }

              if (nextStatus) {
                nextStatus.textContent = "Skipped. User confirmed OK.";
                nextStatus.className = "status-badge";
                nextStatus.style.background = "#6c757d";
                nextStatus.style.color = "white";
                nextStatus.style.animation = "none";
                nextStatus.style.transition = "none";
                nextStatus.classList.remove(
                  "completed",
                  "active",
                  "pulsing",
                  "timer-active",
                  "timer-alert"
                );
              }
            }
          }
        });
      }

      function isGasLevelHigh() {
        const h2sStatus = document.getElementById("h2s-status");
        return h2sStatus && h2sStatus.textContent === "HIGH";
      }

      // ADD THIS NEW FUNCTION RIGHT HERE:
      function isGasAlert(alert) {
        if (!alert || !alert.id) return false;

        // Check for gas-related alert IDs
        const gasAlertIds = [
          "gas-high-threshold",
          "h2s-response",
          "h2s-high",
          "co-response",
          "co-high",
          "lel-response",
          "lel-high",
          "o2-response",
          "o2-high",
          "o2-low",
        ];

        return (
          gasAlertIds.includes(alert.id) ||
          alert.id.includes("gas") ||
          alert.id.includes("h2s") ||
          alert.id.includes("co") ||
          alert.id.includes("lel") ||
          alert.id.includes("o2")
        );
      }
      function getCurrentGasReading() {
        const h2sValueElement = document.getElementById("h2s-value");
        const h2sStatusElement = document.getElementById("h2s-status");

        if (!h2sValueElement || !h2sStatusElement) {
          return {
            type: "H₂S",
            value: "17.90",
            unit: " ppm",
            status: "HIGH",
          };
        }

        const h2sReading = h2sValueElement.textContent;
        const h2sStatus = h2sStatusElement.textContent;

        return {
          type: "H₂S",
          value: h2sReading.split(" ")[0],
          unit: " ppm",
          status: h2sStatus,
        };
      }

      function completeResolution(reason, overrideReason) {
        // Simple resolution log based on whether it's an override or normal
        if (overrideReason) {
          addLogEntry(
            "Alert resolved (Override: " + overrideReason + ")",
            "resolution"
          );
        } else {
          addLogEntry("Alert resolved.", "resolution");
        }

        // Mark resolution as complete
        const resolutionBadge = document.querySelector(
          ".resolution-section .status-badge"
        );
        if (resolutionBadge) {
          resolutionBadge.textContent = "Completed";
          resolutionBadge.classList.add("completed");
        }

        // Disable and update the resolve button
        const resolveButton = document.querySelector(
          ".resolution-section .btn-danger"
        );
        if (resolveButton) {
          resolveButton.disabled = true;
          resolveButton.classList.remove("btn-danger");
          resolveButton.classList.add("btn-secondary");
          resolveButton.textContent = "✅ Alert Resolved";
        }

        // Scroll to top to show the resolution log
        setTimeout(() => {
          window.scrollTo({
            top: 0,
            behavior: "smooth",
          });
        }, 100);
      }

      function resolveAlert() {
        const reasonSelect = document.querySelector(
          ".resolution-section select"
        );
        let reason = reasonSelect ? reasonSelect.value : "";

        // If no resolution reason selected, auto-determine it
        if (!reason) {
          reason = determineResolutionType(currentAlert);
          if (reasonSelect) {
            reasonSelect.value = reason;
          }
        }

        // Check if gas levels are high and require override
        if (currentAlert && isGasAlert(currentAlert) && isGasLevelHigh()) {
          showOverrideModal();
          return;
        }

        // LOCK UI: Disable and grey-out all elements except Cancel Resolution and Add Note
        lockUIForResolution();

        completeResolution(reason);
      }

      function lockUIForResolution() {
        // Handle Step 1 specifically - if still Active, mark as "Skipped"
        const step1 = document.getElementById("step-1");
        const step1Status = document.getElementById("step-1-status");
        if (step1 && step1.classList.contains("active")) {
          step1.classList.remove("active");
          step1.classList.add("completed");
          step1.style.opacity = "0.5";
          if (step1Status) {
            step1Status.textContent = "Skipped. User confirmed OK.";
            step1Status.classList.add("completed");
          }
        }

        // Disable and grey-out all steps
        const allSteps = document.querySelectorAll(".step");
        allSteps.forEach((step) => {
          // Grey out ALL steps (including completed ones) - use !important to override other styles
          step.style.setProperty("opacity", "0.5", "important");
          step.style.setProperty("pointer-events", "none", "important");

          // Disable all buttons in steps
          const buttons = step.querySelectorAll("button");
          buttons.forEach((btn) => (btn.disabled = true));

          // Disable all dropdowns in steps
          const selects = step.querySelectorAll("select");
          selects.forEach((select) => (select.disabled = true));

          // Disable all textareas in steps
          const textareas = step.querySelectorAll("textarea");
          textareas.forEach((textarea) => (textarea.disabled = true));
        });

        // Disable and grey-out timer controls MORE prominently
        const globalTimer = document.getElementById("globalTimer");
        if (globalTimer) {
          globalTimer.style.opacity = "0.3"; // More greyed out
          globalTimer.style.pointerEvents = "none";
          globalTimer.style.filter = "grayscale(50%)"; // Add grey filter

          const timerDropdown = globalTimer.querySelector("select");
          if (timerDropdown) timerDropdown.disabled = true;
        }

        // Disable resolution dropdown but keep buttons active
        const resolutionSelect = document.querySelector(
          ".resolution-section select"
        );
        if (resolutionSelect) {
          resolutionSelect.disabled = true;
          resolutionSelect.style.opacity = "0.5";
        }

        // Disable "Resolve Alert" button
        const resolveButton = document.querySelector(
          ".resolution-section .btn-danger"
        );
        if (resolveButton) {
          resolveButton.disabled = true;
          resolveButton.style.opacity = "0.5";
        }

        // KEEP ACTIVE: Cancel Resolution button and Add Note section
        const cancelButton = document.querySelector(
          ".resolution-section .btn-secondary"
        );
        if (cancelButton) {
          cancelButton.disabled = false;
          cancelButton.style.opacity = "1";
          cancelButton.style.pointerEvents = "auto";
        }

        // KEEP ACTIVE: Add Note section (but don't grey out Protocol Log section)
        const manualNotes = document.getElementById("manual-notes");
        const addNoteButton = document.querySelector(
          'button[onclick="addManualNote()"]'
        );
        if (manualNotes) {
          manualNotes.disabled = false;
          manualNotes.style.opacity = "1";
        }
        if (addNoteButton) {
          addNoteButton.disabled = false;
          addNoteButton.style.opacity = "1";
          addNoteButton.style.pointerEvents = "auto";
        }
      }

      function showOverrideModal() {
        const gasReading = getCurrentGasReading();
        document.getElementById("overrideGasReading").textContent =
          "Current Gas Reading: " +
          gasReading.type +
          ": " +
          gasReading.value +
          gasReading.unit +
          " (" +
          gasReading.status +
          ")";

        document.getElementById("modalOverlay").style.display = "block";
        document.getElementById("overrideModal").style.display = "block";

        // Enable/disable confirm button based on override reason selection
        const overrideReasonSelect = document.getElementById("override-reason");
        const confirmBtn = document.getElementById("confirmOverrideBtn");

        // Remove any existing event listeners to prevent duplicates
        const newOverrideReasonSelect = overrideReasonSelect.cloneNode(true);
        overrideReasonSelect.parentNode.replaceChild(
          newOverrideReasonSelect,
          overrideReasonSelect
        );

        // Add fresh event listener
        newOverrideReasonSelect.addEventListener("change", function () {
          document.getElementById("confirmOverrideBtn").disabled = !this.value;
        });

        // Reset the select and button state
        newOverrideReasonSelect.value = "";
        confirmBtn.disabled = true;
      }

      // Function 1: Enable button when dropdown changes
      function enableOverrideButton() {
        const overrideReason = document.getElementById("override-reason").value;
        const confirmBtn = document.getElementById("confirmOverrideBtn");

        confirmBtn.disabled = !overrideReason;
      }

      // ═══════════════════════════════════════════════════════════════
      // 🎨 UI RENDERING & UPDATE FUNCTIONS
      // ═══════════════════════════════════════════════════════════════

      function updateAlertHeader(alertConfig, userConfig) {
        const alertId = Math.floor(Math.random() * 9000000) + 1000000;
        const alertTime = formatAlertTime(new Date());

        document.getElementById("alert-title").textContent =
          "🚨 Alert Management - " +
          userConfig.name +
          " (" +
          alertConfig.displayName +
          ")";
        document.getElementById("alert-id").textContent = alertId;
        document.getElementById("employee-details").textContent =
          userConfig.name + " (ID: " + userConfig.id + ")";
        document.getElementById("device-details").textContent =
          userConfig.device;
        document.getElementById("mobile-number").textContent =
          userConfig.mobile;
        document.getElementById("alert-time").textContent = alertTime;
        document.getElementById("alert-trigger").textContent =
          alertConfig.displayName;
      }

      function formatAlertTime(alertDate) {
        const now = new Date();
        const diffMinutes = Math.floor((now - alertDate) / 60000);

        const timeStr =
          alertDate.toLocaleDateString("en-US", {
            month: "2-digit",
            day: "2-digit",
            year: "numeric",
          }) +
          " " +
          alertDate.toLocaleTimeString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            hour12: false,
          }) +
          " MDT";

        let timeAgo = "";
        if (diffMinutes === 0) timeAgo = "(just now)";
        else if (diffMinutes === 1) timeAgo = "(-1 minute ago)";
        else if (diffMinutes < 60) timeAgo = `(-${diffMinutes} minutes ago)`;
        else if (diffMinutes < 1440)
          timeAgo = `(-${Math.floor(diffMinutes / 60)} hours ago)`;
        else timeAgo = `(-${Math.floor(diffMinutes / 1440)} days ago)`;

        return `${timeStr} ${timeAgo}`;
      }

      function addAlertSequenceLogs(userConfig) {
        const now = new Date();
        const ackTime = new Date(now.getTime() - 9000);
        const serverTime = new Date(now.getTime() - 18000);
        const deviceTime = new Date(now.getTime() - 18000);

        const formatEDT = function (date) {
          return (
            date.toLocaleTimeString("en-US", {
              hour12: false,
              timeZone: "America/New_York",
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            }) + " EDT"
          );
        };

        addLogEntry(
          "Alert triggered by device.",
          "system",
          "*" + userConfig.company + "*",
          formatEDT(deviceTime)
        );
        addLogEntry(
          "Alert received by server.",
          "system",
          "*" + userConfig.company + "*",
          formatEDT(serverTime)
        );
        addLogEntry(
          "Alert acknowledged.",
          "system",
          "*Blackline Safety Operations Centre*",
          formatEDT(ackTime)
        );
      }

      function addLogEntry(message, type, source, customTime) {
        console.log(
          "addLogEntry called:",
          message.substring(0, 50) + "...",
          "type:",
          type
        );
        console.trace(); // This will show WHERE it was called from

        const logContainer = document.getElementById("protocolLog");
        const placeholder = logContainer.querySelector(".log-placeholder");

        if (placeholder) {
          placeholder.remove();
        }

        const entry = document.createElement("div");
        entry.className = "log-entry " + (type || "general");

        let timestamp, operator;

        if (customTime) {
          timestamp = customTime;
          operator = "";
        } else {
          timestamp =
            new Date().toLocaleTimeString("en-US", {
              hour12: false,
              timeZone: "America/Denver",
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            }) + " MST";
          operator = " | Op 417";
        }

        // Format different log types with better structure
        if (source) {
          // System logs (alert sequence) - timestamp on separate line
          entry.innerHTML =
            "<div>" +
            '<div class="log-source"><strong>' +
            source +
            "</strong></div>" +
            '<div class="log-timestamp" style="font-weight: bold; color: #333; margin-bottom: 5px;">2025-08-04 ' +
            timestamp +
            "</div>" +
            '<div class="log-content">' +
            formatLogMessage(message, type) +
            "</div>" +
            "</div>";
        } else {
          // Operator logs - with larger Op 417 text
          entry.innerHTML =
            '<div class="log-header">' +
            '<span class="log-timestamp">[' +
            timestamp +
            "]</span>" +
            '<div class="log-operator" style="font-size: 0.9em;">Op 417</div>' +
            "</div>" +
            '<div class="log-content">' +
            formatLogMessage(message, type) +
            "</div>";
        }

        logContainer.insertBefore(entry, logContainer.firstChild); // This adds to top
      }

      function formatLogMessage(message, type) {
        // Handle new dispatch format with "Called dispatch, spoke to"
        if (
          message.includes("Called dispatch, spoke to") &&
          message.includes("Dispatched")
        ) {
          const lines = message.split("\n").filter((line) => line.trim());

          // Extract the main dispatch line
          const mainLine = lines[0];

          // Format with proper HTML structure
          let formatted = `<div class="dispatch-summary" style="font-weight: normal; color: inherit;">📍 ${mainLine}</div>`;

          // Process each line for proper formatting
          lines.slice(1).forEach((line) => {
            const trimmedLine = line.trim();
            if (!trimmedLine) return;

            if (trimmedLine.includes("Last Known Location Address:")) {
              formatted +=
                '<div class="location-info">📍 ' + trimmedLine + "</div>";
            } else if (trimmedLine.includes("Coordinates:")) {
              formatted +=
                '<div class="coordinates">🗺️ ' + trimmedLine + "</div>";
            } else if (trimmedLine.includes("Speed:")) {
              formatted +=
                '<div class="dispatch-detail">' + trimmedLine + "</div>";
            } else if (trimmedLine.includes("Last Location Date/Time:")) {
              formatted +=
                '<div class="dispatch-detail">' + trimmedLine + "</div>";
            } else if (
              trimmedLine.includes("Device Status Last Communication:")
            ) {
              formatted +=
                '<div class="device-status">📱 ' + trimmedLine + "</div>";
            } else if (
              trimmedLine.includes("Battery:") ||
              trimmedLine.includes("Signal:")
            ) {
              formatted +=
                '<div class="device-stats">🔋 ' + trimmedLine + "</div>";
            } else if (trimmedLine.includes("Waiting")) {
              formatted +=
                '<div class="dispatch-detail">⏰ ' + trimmedLine + "</div>";
            } else {
              formatted +=
                '<div class="dispatch-detail">' + trimmedLine + "</div>";
            }
          });

          return formatted;
        }
        // Handle "Unable to dispatch" messages
        else if (message.includes("Unable to dispatch")) {
          const lines = message.split("\n").filter((line) => line.trim());

          // Extract the main unable to dispatch line
          const mainLine = lines[0];

          // Format with proper HTML structure
          let formatted = `<div class="dispatch-summary" style="color: #dc3545; font-weight: bold;">❌ ${mainLine}</div>`;

          // Process remaining lines with same formatting as dispatch
          lines.slice(1).forEach((line) => {
            const trimmedLine = line.trim();
            if (!trimmedLine) return;

            if (trimmedLine.includes("Last Known Location")) {
              formatted +=
                '<div class="location-info">📍 ' + trimmedLine + "</div>";
            } else if (trimmedLine.includes("Address:")) {
              formatted +=
                '<div class="location-info">📍 ' + trimmedLine + "</div>";
            } else if (trimmedLine.includes("Coordinates:")) {
              formatted +=
                '<div class="coordinates">🗺️ ' + trimmedLine + "</div>";
            } else if (trimmedLine.includes("Speed:")) {
              formatted +=
                '<div class="dispatch-detail">' + trimmedLine + "</div>";
            } else if (trimmedLine.includes("Last Location Date/Time:")) {
              formatted +=
                '<div class="dispatch-detail">' + trimmedLine + "</div>";
            } else if (trimmedLine.includes("Repeating STEPS")) {
              formatted +=
                '<div class="protocol-reset" style="color: #856404; font-weight: bold;">🔄 ' +
                trimmedLine +
                "</div>";
            } else {
              formatted +=
                '<div class="dispatch-detail">' + trimmedLine + "</div>";
            }
          });

          return formatted;
        }
        // Clean up long dispatch messages (old format)
        else if (
          message.includes(
            "Dispatched Emergency Services to the following location:"
          )
        ) {
          const parts = message.split(
            /(?=Last Known Location|Coordinates:|Speed:|Last Location|Device Status|Battery:|Signal:)/
          );
          let formatted =
            '<div class="dispatch-summary">📍 <strong>Emergency Services Dispatched</strong></div>';

          parts.forEach((part) => {
            if (part.trim()) {
              if (part.includes("Last Known Location")) {
                formatted +=
                  '<div class="location-info">📍 ' + part.trim() + "</div>";
              } else if (part.includes("Coordinates:")) {
                formatted +=
                  '<div class="coordinates">🗺️ ' + part.trim() + "</div>";
              } else if (part.includes("Device Status")) {
                formatted +=
                  '<div class="device-status">📱 ' + part.trim() + "</div>";
              } else if (
                part.includes("Battery:") ||
                part.includes("Signal:")
              ) {
                formatted +=
                  '<div class="device-stats">🔋 ' + part.trim() + "</div>";
              } else {
                formatted +=
                  '<div class="dispatch-detail">' + part.trim() + "</div>";
              }
            }
          });
          return formatted;
        }
        // FIXED: Handle ALL timer messages (Started, EXPIRED, etc.)
        else if (message.includes("timer") || message.includes("TIMER")) {
          return '<div class="timer-action">⏰ ' + message + "</div>";
        }
        // Step messages - just return as-is since they're already formatted
        else if (message.includes("Step ")) {
          return message;
        }
        // Default formatting
        else {
          return message;
        }
      }

      function getActionIcon(action) {
        const icons = {
          "call-device": "📞",
          "message-device": "📱",
          "call-user": "📞",
          "call-emergency-contacts": "👥",
          dispatch: "🚑",
          "Dispatch EMS": "🚑",
          "call-device": "📞",
          "Immediate Dispatch": "🚨",
          "Conditional Dispatch": "⚠️",
        };
        return icons[action] || "▶️";
      }

      function getStepLabel(stepId) {
        const parts = stepId.split("-");
        if (parts.length === 2) {
          return `Step ${parts[1]}`; // "step-3" → "Step 3"
        } else if (parts.length === 3) {
          return `Step ${parts[1]}.${parts[2]}`; // "step-4-1" → "Step 4.1"
        }
        return stepId; // fallback
      }

      function loadProtocolSteps(protocolConfig, userConfig) {
        let protocolHTML =
          '<div style="margin-bottom: 20px;"><h4 style="color: #1565c0; margin: 0 0 10px 0;">📋 ' +
          protocolConfig.name +
          '</h4><p style="color: #666; font-size: 0.9em; margin: 0;">Showing only relevant steps for this alert type</p></div>';

        protocolConfig.steps.forEach(function (step, index) {
          const isFirst = index === 0;
          const isDispatchStep = step.action === "dispatch";

          // Build step classes - add dispatch-step class for dispatch steps
          let stepClasses = "step";
          if (isFirst || isDispatchStep) stepClasses += " active";
          if (isDispatchStep) stepClasses += " dispatch-step";

          protocolHTML +=
            '<div class="' +
            stepClasses +
            '" id="' +
            step.id +
            '">' +
            '<div class="step-header">' +
            '<h4 class="step-title">✅ ' +
            step.title +
            "</h4>" +
            '<span class="status-badge ' +
            (isFirst || step.action === "dispatch" ? "active" : "") +
            '" id="' +
            step.id +
            '-status">' +
            (isFirst || step.action === "dispatch" ? "Active" : "Pending") +
            "</span>" +
            "</div>";

          // Add contact info for relevant steps
          if (step.id === "step-3" || step.id === "step-2") {
            // Only show user contact for "Call User" actions
            if (step.action === "call-user") {
              protocolHTML +=
                '<div class="contact-info">' +
                "<strong>👤 " +
                userConfig.name +
                "</strong> 📞 " +
                userConfig.mobile +
                "</div>";
            }
            // For "Contact Emergency Contacts" - don't add user info (ECs will be added separately)
            // For "Dispatch Services" - don't add any contact info
          }

          // Handle Step 4 with Emergency Contacts
          if (step.id === "step-4") {
            const userKey = currentAlert.user;
            const emergencyContacts = AlertDataManager.usersData[userKey]
              ? AlertDataManager.usersData[userKey].emergencyContacts
              : [];

            protocolHTML +=
              '<div class="step-content" style="margin: 15px 0;">' +
              "Contact emergency contacts in order of priority" +
              "</div>";

            // Add individual EC sections
            emergencyContacts.forEach(function (contact, index) {
              const contactStepId = "step-4-" + (index + 1);
              const isFirstEC = index === 0;

              protocolHTML +=
                '<div class="step" id="' +
                contactStepId +
                '" style="margin: 10px 0;">' +
                '<div class="step-header">' +
                '<h5 class="step-title">📞 Call ' +
                contact.name +
                " at " +
                contact.phone +
                "</h5>" +
                '<span class="status-badge" id="' +
                contactStepId +
                '-status">Pending</span>' +
                "</div>" +
                '<div class="contact-info">' +
                "<strong>👤 " +
                contact.name +
                "</strong> 📞 " +
                contact.phone +
                " 🏷️ " +
                contact.role +
                "</div>" +
                '<button class="btn btn-primary" onclick="startStep(\'' +
                contactStepId +
                "')\" disabled>" +
                "📞 Call Emergency Contact" +
                "</button>" +
                '<div class="step-outcome" id="' +
                contactStepId +
                '-outcome" style="display: none; margin-top: 15px;">' +
                '<select id="' +
                contactStepId +
                '-select" onchange="autoPopulateNote(\'' +
                contactStepId +
                '\')" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
                '<option value="">Select outcome</option>' +
                // GROUP 1: RESOLUTION OUTCOMES (User confirmed okay)
                '<option value="confirmed-ok">Confirmed user is okay</option>' +
                '<option value="ec-callback">Emergency contact called in and confirmed user is okay</option>' +
                '<option value="user-callback">User called in. Confirmed they are okay</option>' +
                // GROUP 1.5: TIMER/WAITING OUTCOMES
                '<option value="ec-callback-30min">EC called in, will check on user and call back within 30 minutes</option>' +
                // GROUP 2: CONTINUE PROTOCOL OUTCOMES (Keep trying next steps)
                '<option value="no-answer-voicemail">No answer, left voicemail</option>' +
                '<option value="no-answer-unable">No answer, unable to leave voicemail</option>' +
                '<option value="wrong-number">Wrong number</option>' +
                '<option value="unable-to-connect">Unable to connect</option>' +
                "</select>" +
                '<textarea id="' +
                contactStepId +
                '-note" placeholder="Document the result..." style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 8px; box-sizing: border-box;" oninput="validatePostButton(\'' +
                contactStepId +
                "')\"></textarea>" +
                '<button class="btn btn-secondary" onclick="postNote(\'' +
                contactStepId +
                '\')" style="margin-top: 8px;" disabled id="' +
                contactStepId +
                '-post-btn">✅ Post Note</button>' +
                "</div>" +
                "</div>";
            });

            protocolHTML +=
              '<div style="margin: 15px 0; padding: 12px; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px; font-size: 0.9em; color: #1565c0; font-weight: 500;">' +
              "📍 If valid location not available, repeat STEPS 1, 2, 3 & 4 until someone is reached." +
              "</div>";

            protocolHTML += "</div>"; // Close the main step-4 div

            return; // Skip standard processing for Step 4
          }

          // Handle Step 5 with Dispatch Logic
          if (step.action === "dispatch") {
            console.log(
              "DEBUG: Generating full dispatch interface for step:",
              step.id
            ); // ADD THIS
            protocolHTML +=
              '<div class="step-outcome" id="' +
              step.id +
              '-outcome" style="display: block; margin-top: 15px;">' +
              // EXISTING DISPATCH DECISION LOGIC
              '<label for="dispatch-decision" style="display: block; margin-bottom: 8px; font-weight: bold;">Dispatch conditions met?</label>' +
              '<select id="dispatch-decision" onchange="handleDispatchDecision(\'' +
              step.id +
              '\')" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 15px;">' +
              '<option value="">-- System will evaluate --</option>' +
              '<option value="yes">Yes</option>' +
              '<option value="no">No</option>' +
              "</select>" +
              // Service Selection (fix dropdown ID)
              '<div id="service-type-container" style="display: none; margin-bottom: 15px;">' +
              '<label for="dispatch" style="display: block; font-weight: bold; margin-bottom: 8px; color: #333;">Dispatch Service Type:</label>' +
              '<select id="dispatch" onchange="autoPopulateDispatchNote(\'' +
              step.id +
              '\')" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 12px; font-size: 0.9em;">' +
              '<option value="">-- Select Service --</option>' +
              '<option value="Emergency Medical Services (EMS)">Emergency Medical Services (EMS)</option>' +
              '<option value="Police">Police</option>' +
              '<option value="Fire Department">Fire Department</option>' +
              '<option value="EMS and Police">EMS and Police</option>' +
              '<option value="EMS and Fire">EMS and Fire</option>' +
              '<option value="Police and Fire">Police and Fire</option>' +
              '<option value="EMS, Police and Fire">EMS, Police and Fire</option>' +
              "</select>" +
              "</div>" +
              // Skip Reason (hidden by default)
              '<div id="skip-reason-container" style="display: none; margin-bottom: 15px;">' +
              '<label for="skip-reason" style="display: block; font-weight: bold; margin-bottom: 8px; color: #856404;">Unmet Dispatch Condition:</label>' +
              '<select id="skip-reason" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 8px;">' +
              '<option value="">-- System will determine --</option>' +
              '<option value="device-offline">Device offline (last comm > 30 min, battery ≤ 10%, or signal ≤ 10%)</option>' +
              '<option value="location-stale">Location not valid or current</option>' +
              '<option value="device-moving">Device not stationary (≥ 5 km/h)</option>' +
              "</select>" +
              "</div>" +
              // Notes textarea
              '<textarea id="' +
              step.id +
              '-note" placeholder="Document the dispatch decision..." style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 8px; box-sizing: border-box;" oninput="validatePostButton(\'' +
              step.id +
              "')\"></textarea>" +
              '<button class="btn btn-secondary" onclick="postNote(\'' +
              step.id +
              '\')" style="margin-top: 8px;" disabled id="' +
              step.id +
              '-post-btn">✅ Post Note</button>' +
              "</div>" + // Close Dispatch Logic-outcome
              // ADD NEW: USER/EC CALLBACK DROPDOWN
              '<label for="' +
              step.id +
              '-select" style="display: block; margin-bottom: 8px; font-weight: bold;">User/EC Callback During Dispatch Wait:</label>' +
              '<select id="' +
              step.id +
              '-select" onchange="autoPopulateFromDropdown(\'' +
              step.id +
              '\')" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
              '<option value="">Select outcome</option>' +
              '<option value="user-callback">User called in and confirmed they are okay</option>' +
              '<option value="ec-callback">Emergency contact called in and confirmed user is okay</option>' +
              '<option value="ec-callback-cancel-dispatch-30min">Emergency contact called in, advised to cancel dispatch. They will check on user and call back within 30 minutes</option>' +
              "</select>" +
              '<div style="margin: 15px 0; padding: 12px; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px; font-size: 0.9em; color: #1565c0; font-weight: 500;">' +
              "📍 If valid location not available, repeat STEPS 1, 2, 3 & 4 until someone is reached." +
              "</div>" +
              "</div>"; // Close step

            return; // Skip standard processing for Step 5
          }

          // Standard processing for other steps
          if (step.action === "dispatch") {
            protocolHTML +=
              '<button class="btn btn-primary" onclick="checkDispatchConditions(\'' +
              step.id +
              "')\" " +
              (!isFirst ? "disabled" : "") +
              ">" +
              getActionIcon(step.action) +
              " " +
              step.action +
              "</button>";
          } else {
            protocolHTML +=
              '<button class="btn btn-primary" onclick="startStep(\'' +
              step.id +
              "')\" " +
              (!isFirst ? "disabled" : "") +
              ">" +
              getActionIcon(step.action) +
              " " +
              step.action +
              "</button>";
          }

          // Step outcome section
          protocolHTML +=
            '<div class="step-outcome" id="' +
            step.id +
            '-outcome" style="display: none; margin-top: 15px;">';

          // Timer info
          if (step.timer) {
            protocolHTML +=
              '<div style="background: #fff3cd; padding: 8px; border-radius: 4px; margin: 10px 0; font-size: 0.85em;">' +
              "⏱️ Timer: " +
              Math.floor(step.timer / 60) +
              " minutes" +
              "</div>";
          }

          // Outcome dropdown
          protocolHTML +=
            '<select id="' +
            step.id +
            '-select" onchange="autoPopulateFromDropdown(\'' +
            step.id +
            "'); validatePostButton('" +
            step.id +
            '\')" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
            '<option value="">Select outcome</option>';

          // Action-based dropdown options (instead of step-number-based)
          console.log("Step ID:", step.id, "Step Action:", step.action); // ADD THIS

          if (step.action === "call-device") {
            protocolHTML +=
              // GROUP 1: RESOLUTION OUTCOMES (User confirmed okay)
              '<option value="confirmed-ok">Spoke with ' +
              userConfig.name +
              ". Confirmed they are okay. Resolving alert.</option>" +
              '<option value="user-callback">User called in. Confirmed they are okay</option>' +
              // GROUP 2: CONTINUE PROTOCOL OUTCOMES (Keep trying next steps)
              '<option value="no-answer">No answer.</option>' +
              '<option value="unable-to-call">Unable to call, device offline.</option>';
          } else if (step.action === "message-device") {
            protocolHTML +=
              '<option value="no-response">No response</option>' +
              '<option value="unable-to-send">Unable to send text message, device offline</option>' +
              '<option value="device-no">Received "No" - User confirmed okayay</option>' +
              '<option value="issue-resolved">Received "Issue resolved" - User confirmed okay</option>' +
              '<option value="false-alarm">Received "False alarm" - User confirmed okay</option>' +
              '<option value="understood">Received "Understood" - User confirmed okay</option>' +
              '<option value="device-yes">Received "Yes" - User confirmed okay</option>' +
              '<option value="send-help">Received "Send help" - Immediate assistance requested</option>';
          } else if (step.action === "call-user") {
            console.log("Generating Call User dropdown for:", step.id);
            protocolHTML +=
              // GROUP 1: RESOLUTION OUTCOMES (User confirmed okay)
              '<option value="confirmed-ok">Spoke with ' +
              userConfig.name +
              ", confirmed they are okay</option>" +
              '<option value="ec-callback">Emergency contact called in and confirmed user is okay</option>' +
              '<option value="user-callback">User called in. Confirmed they are okay</option>' +
              // GROUP 1.5: TIMER/WAITING OUTCOMES
              '<option value="ec-callback-30min">EC called in, will check on user and call back within 30 minutes</option>' +
              // GROUP 2: VOICEMAIL OUTCOMES (No answer but could leave message)
              '<option value="no-answer-voicemail">No answer. Left voicemail</option>' +
              '<option value="no-answer-already-left">No answer. Voicemail had already been left</option>' +
              // GROUP 3: VOICEMAIL ISSUES (No answer and couldn't leave message)
              '<option value="no-answer-mailbox-full">No answer. Unable to leave voicemail, mailbox full</option>' +
              '<option value="no-answer-unable-voicemail">No answer. Unable to leave voicemail</option>' +
              '<option value="no-answer-mailbox-not-setup">No answer. Unable to leave voicemail, mailbox not set up yet</option>' +
              // GROUP 4: CONNECTION/SYSTEM ISSUES
              '<option value="no-phone-number">Unable to call, user has no phone number assigned</option>' +
              '<option value="number-disconnected">Number has been changed, disconnected or no longer in service</option>' +
              '<option value="unable-to-connect">Unable to connect</option>';
          } else if (step.action === "call-emergency-contacts") {
            // This is handled separately by the EC generation code
            protocolHTML +=
              // GROUP 1: RESOLUTION OUTCOMES (User confirmed okay)
              '<option value="confirmed-ok">Emergency contact confirmed user is okay</option>' +
              '<option value="ec-callback">Emergency contact called in and confirmed user is okay</option>' +
              '<option value="user-callback">User called in. Confirmed they are okay</option>' +
              // GROUP 1.5: TIMER/WAITING OUTCOMES
              '<option value="ec-callback-30min">EC called in, will check on user and call back within 30 minutes</option>' +
              // GROUP 2: CONTINUE PROTOCOL OUTCOMES (Keep trying next steps)
              '<option value="no-answer">No answer from contacts</option>' +
              '<option value="completed">Contacted emergency contacts</option>';
          } else {
            // Default options for other actions
            protocolHTML +=
              '<option value="completed">Action completed</option>' +
              '<option value="no-answer">No answer</option>';
          }

          protocolHTML += "</select>";

          // Note textarea
          protocolHTML +=
            '<textarea id="' +
            step.id +
            '-note" placeholder="Document the result..." ' +
            'style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 8px; box-sizing: border-box;" ' +
            "oninput=\"validatePostButton('" +
            step.id +
            "')\"></textarea>";

          // Post Note button
          protocolHTML +=
            '<button class="btn btn-secondary" onclick="postNote(\'' +
            step.id +
            '\')" style="margin-top: 8px;" disabled id="' +
            step.id +
            '-post-btn">✅ Post Note</button>' +
            "</div>" +
            "</div>";
        });

        // Resolution Section
        protocolHTML +=
          '<div class="resolution-section">' +
          '<div class="step-header">' +
          "<h3>✅ RESOLUTION</h3>" +
          '<span class="status-badge" id="resolution-status">Pending</span>' +
          "</div>" +
          '<select id="resolution-reason" style="width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
          '<option value="">-- Select reason --</option>' +
          '<option value="false-alert-without-dispatch">False alert without dispatch</option>' +
          '<option value="false-alert-with-dispatch">False alert with dispatch</option>' +
          '<option value="incident-without-dispatch">Incident without dispatch</option>' +
          '<option value="incident-with-dispatch">Incident with dispatch</option>' +
          "</select>" +
          '<div class="resolution-buttons">' +
          '<button class="btn btn-danger" onclick="resolveAlert()">✅ Resolve Alert</button>' +
          '<button class="btn btn-secondary" onclick="cancelResolution()">❌ Cancel Resolution</button>' +
          "</div>" +
          "</div>";

        document.getElementById("protocol-content").innerHTML = protocolHTML;
      }

      function autoPopulateNote(contactStepId) {
        const select = document.getElementById(contactStepId + "-select");
        const note = document.getElementById(contactStepId + "-note");

        if (!select || !note) return;

        const selectedValue = select.value;
        if (!selectedValue) return;

        const ecIndex = parseInt(contactStepId.split("-")[2]) - 1;
        const userKey = currentAlert.user;
        const contact =
          AlertDataManager.usersData[userKey].emergencyContacts[ecIndex];

        let noteText = "";
        let shouldScrollToResolution = false;

        // GROUP 1: RESOLUTION OUTCOMES
        if (selectedValue === "confirmed-ok") {
          noteText =
            "Step 4." +
            (ecIndex + 1) +
            ": Confirmed user is okay and advised to resolve alert";
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback") {
          noteText =
            "Step 4." +
            (ecIndex + 1) +
            ": Emergency contact called in and confirmed user is okay";
          shouldScrollToResolution = true;
        } else if (selectedValue === "user-callback") {
          noteText =
            "Step 4." +
            (ecIndex + 1) +
            ": User called in. Confirmed they are okay";
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback-30min") {
          noteText =
            "Step 4." +
            (ecIndex + 1) +
            ": Emergency contact called in, will check on user and call back within 30 minutes.";
          // Should start 30-min timer

          // GROUP 2: CONTINUE PROTOCOL OUTCOMES
        } else if (selectedValue === "no-answer-voicemail") {
          noteText =
            "Step 4." +
            (ecIndex + 1) +
            ": Called " +
            contact.name +
            " at " +
            contact.phone +
            ". No answer, left voicemail";
        } else if (selectedValue === "no-answer-unable") {
          noteText =
            "Step 4." +
            (ecIndex + 1) +
            ": Called " +
            contact.name +
            " at " +
            contact.phone +
            ". No answer, unable to leave voicemail";
        } else if (selectedValue === "wrong-number") {
          noteText =
            "Step 4." +
            (ecIndex + 1) +
            ": Called " +
            contact.name +
            " at " +
            contact.phone +
            ". Wrong number";
        } else if (selectedValue === "unable-to-connect") {
          noteText =
            "Step 4." +
            (ecIndex + 1) +
            ": Called " +
            contact.name +
            " at " +
            contact.phone +
            ". Unable to connect";
        }

        if (noteText) {
          note.value = noteText;
          validatePostButton(contactStepId);
        }
      }

      function updateGasReadings(alertType) {
        const gasData = gasReadingsData[alertType] || gasReadingsData.default;

        Object.keys(gasData).forEach(function (gas) {
          const reading = gasData[gas];
          const valueElement = document.getElementById(gas + "-value");
          const statusElement = document.getElementById(gas + "-status");
          const readingElement = document.getElementById(gas + "-reading");

          const unit =
            gas === "o2" ? " %vol" : gas === "lel" ? " %LEL" : " ppm";

          if (valueElement) {
            valueElement.textContent = reading.value.toFixed(2) + unit;
          }

          if (statusElement) {
            statusElement.textContent = reading.status;
            statusElement.className =
              "gas-status " + reading.status.toLowerCase();
          }

          if (readingElement) {
            const icon = reading.status === "HIGH" ? "🔴" : "🟢";
            const gasLabel =
              gas === "h2s" ? "H₂S" : gas === "o2" ? "O₂" : gas.toUpperCase();
            readingElement.querySelector("span").innerHTML =
              icon +
              " " +
              gasLabel +
              ': <span class="gas-value">' +
              reading.value.toFixed(2) +
              unit +
              "</span>";
          }
        });

        if (alertType !== "default") {
          document.getElementById("triggeredBy").style.display = "block";
          document.getElementById("lastUpdated").style.display = "block";
          document.getElementById("gas-timestamp").textContent =
            new Date().toLocaleTimeString() + " MDT";
        }
      }

      function updateGasDisplay() {
        const timestamp = new Date().toLocaleTimeString("en-US", {
          hour12: false,
          timeZone: "America/Denver",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        });

        const timestampElement = document.getElementById("gas-timestamp");
        if (timestampElement) {
          timestampElement.textContent = timestamp + " MDT";
        }
      }

      function startGasMonitoring() {
        updateGasDisplay();
        gasUpdateInterval = setInterval(() => {
          updateGasDisplay();
        }, 5000);
      }

      // ═══════════════════════════════════════════════════════════════
      // 🔄 EVENT HANDLERS & DEMO FUNCTIONS
      // ═══════════════════════════════════════════════════════════════

      function toggleDemoPanel() {
        document.getElementById("demo-panel").classList.toggle("show");
      }

      function toggleDemoSection(sectionId) {
        const section = document.getElementById(sectionId);
        section.classList.toggle("collapsed");
      }

      function loadAlert(alertType) {
        const alertConfig = AlertDataManager.alertTypesData[alertType];
        if (!alertConfig) {
          console.error(`Alert type ${alertType} not found`);
          return;
        }

        const userConfig = AlertDataManager.usersData[alertConfig.user];
        const protocolConfig = ProtocolFactory.getProtocolConfig(alertType);

        currentAlert = alertConfig;
        currentUser = userConfig;

        // Clear existing logs
        const logContainer = document.getElementById("protocolLog");
        logContainer.innerHTML = "";

        // Initialize UI
        addAlertSequenceLogs(userConfig);
        updateAlertHeader(alertConfig, userConfig);
        updateGasReadings(alertConfig.gasType || alertType);
        loadProtocolSteps(protocolConfig, userConfig);
        initializeAlert(alertConfig, userConfig);

        document.getElementById("alert-header").classList.add("active");
        document.getElementById("demo-panel").classList.remove("show");

        // Handle test scenarios
        // handleTestScenario(alertConfig); // DISABLED for manual testing

        // After loading protocol, set Step 1 as Active
        setTimeout(() => {
          const step1 = document.getElementById("step-1");
          const step1Status = document.getElementById("step-1-status");

          if (step1) {
            step1.classList.add("active");
            step1.style.opacity = "1";
          }

          if (step1Status) {
            step1Status.textContent = "Active";
            step1Status.className = "status-badge active";
          }

          // Optional: Scroll Step 1 into view
          if (step1) {
            step1.scrollIntoView({
              behavior: "smooth",
              block: "center",
            });
          }

          // START DISPATCH MONITORING (after DOM is ready)
          initializeDispatchMonitoring();
        }, 100); // Small delay to ensure DOM is ready
      }

      function loadAlertFromJSON(alertId) {
        if (!alertsFromJSON) {
          alert("JSON data not loaded yet");
          return;
        }

        const alertData = alertsFromJSON.find((alert) => alert.id === alertId);
        if (!alertData) {
          console.error(`Alert ID ${alertId} not found in JSON`);
          return;
        }

        // Convert JSON to expected format and load
        currentAlert = convertJSONToAlertFormat(alertData);
        currentUser = convertJSONToUserFormat(alertData);

        // REMOVE THIS EXTRA CLOSING BRACE: }

        // Clear existing logs
        const logContainer = document.getElementById("protocolLog");
        logContainer.innerHTML = "";

        // Initialize UI
        addAlertSequenceLogs(currentUser);
        updateAlertHeader(currentAlert, currentUser);
        updateGasReadings(currentAlert.gasType || "default");
        const protocolConfig = protocolsData[currentAlert.protocolFile];
        loadProtocolSteps(protocolConfig, currentUser);
        initializeAlert(currentAlert, currentUser);

        document.getElementById("alert-header").classList.add("active");
        document.getElementById("demo-panel").classList.remove("show");

        // Handle test scenarios
        handleTestScenario(currentAlert);
      } // FUNCTION SHOULD CLOSE HERE

      function convertJSONToAlertFormat(alertData) {
        return {
          id: alertData.id,
          displayName: alertData.alert_subtype,
          user: alertData.user.toLowerCase().replace(" ", "-"),
          protocolFile: getProtocolFileFromType(alertData.type),
          gasType: alertData.is_gas_alert
            ? alertData.gas_type.toLowerCase() + "-high"
            : "default",
          testType: alertData.testType || "legacy",
        };
      }

      function convertJSONToUserFormat(alertData) {
        return {
          id: alertData.employee_id,
          name: alertData.user,
          device: alertData.device_type + "-" + alertData.device_id,
          mobile: alertData.mobile,
          company: alertData.organization,
          work: alertData.work,
          home: alertData.home,
          emergencyContacts: alertData.emergency_contacts.map((contact) => ({
            name: contact.name,
            phone: contact.phone,
            role: contact.role,
          })),
        };
      }

      function getProtocolFileFromType(alertType) {
        const typeMap = {
          "Gas Alert": "gas-emergency-protocol",
          "Fall Detection": "fall-detection-protocol",
          "SOS Alert": "sos-protocol",
          "No Motion": "no-motion-protocol",
          "Check-In Alert": "check-in-protocol",
          "Message Alert": "no-motion-protocol",
        };
        return typeMap[alertType] || "gas-emergency-protocol";
      }

      function handleTestScenario(alertConfig) {
        const gasMessages = [
          "False alarm",
          "Issue resolved",
          "I'm OK",
          "No",
          "Yes",
          "Understood",
        ];
        const nonGasMessages = [
          "Issue resolved",
          "False alarm",
          "I'm OK",
          "No",
          "Yes",
          "Send help",
        ];
        const helpMessages = ["Send help", "I am stranded", "Hazard in area"];

        if (alertConfig.testType === "spontaneous") {
          setTimeout(() => {
            let messagePool =
              alertConfig.protocolFile === "gas-emergency-protocol"
                ? gasMessages
                : nonGasMessages;
            const randomMessage =
              messagePool[Math.floor(Math.random() * messagePool.length)];
            simulateDeviceResponse(randomMessage, false);
          }, 3000);
        } else if (alertConfig.testType === "immediate-help") {
          setTimeout(() => {
            const helpMessage =
              helpMessages[Math.floor(Math.random() * helpMessages.length)];
            simulateDeviceResponse(helpMessage, false);
          }, 0);
        } else if (alertConfig.testType === "legacy") {
          if (alertConfig.id === "gas-high-threshold") {
            setTimeout(() => {
              const randomMessage =
                gasMessages[Math.floor(Math.random() * gasMessages.length)];
              simulateDeviceResponse(randomMessage, false);
            }, 3000);
          }
        }
      }

      function clearAlert() {
        currentAlert = null;
        currentUser = null;
        dispatchMade = false;

        document.getElementById("alert-header").classList.remove("active");
        updateGasReadings("default");
        document.getElementById("triggeredBy").style.display = "none";
        document.getElementById("lastUpdated").style.display = "none";
        document.getElementById("protocolLog").innerHTML =
          '<div class="log-placeholder">No alert loaded. Use demo controls to load an alert type and begin protocol.</div>';
        document.getElementById("protocol-content").innerHTML =
          '<div class="protocol-placeholder"><div class="protocol-frame"><div class="placeholder-text">No protocol loaded</div><div class="placeholder-subtitle">Alert type will load the relevant emergency response protocol</div></div></div>';
        document.getElementById("demo-panel").classList.remove("show");
      }

      function addManualNote() {
        const noteText = document.getElementById("manual-notes").value.trim();

        console.log("Adding note:", noteText);
        addLogEntry(noteText, "general");
        document.getElementById("manual-notes").value = "";

        // Re-disable button after posting (like other steps)
        const button = document.querySelector(
          'button[onclick="addManualNote()"]'
        );
        if (button) {
          button.disabled = true;
          button.classList.add("btn-secondary");
          button.classList.remove("btn-success");
        }
      }

      function sendManualMessage() {
        const messageInput = document.getElementById("manual-message-input");
        const charCounter = document.getElementById("charCounter");
        const sendBtn = document.getElementById("sendMessageBtn");

        const msg = messageInput.value.trim();
        if (msg.length === 0 || msg.length > 32) return;

        console.log("Manual message sent:", msg);

        messageInput.value = "";
        charCounter.textContent = "32 characters remaining";
        sendBtn.disabled = true;
      }

      function receiveMessageFromDevice(text) {
        const messageList = document.getElementById("receivedMessages");
        if (!messageList) return;

        const li = document.createElement("li");
        li.classList.add("unread");
        li.textContent = text;
        messageList.prepend(li);

        setTimeout(() => li.classList.remove("unread"), 5000);
      }

      function splitIntoTwoLines(text) {
        return text; // Simple implementation
      }

      function triggerImmediateDispatch() {
        dispatchMade = true;
      }

      // Demo functions for testing
      window.simulateDeviceResponse = function (
        responseText,
        isResponse = false
      ) {
        return; // DISABLED for manual testing - remove this line to re-enable
        if (protocolState.deviceMessageReceived) return;

        protocolState.deviceMessageReceived = true;
        receiveMessageFromDevice(responseText);

        const clearResolutionMessages = [
          "Issue resolved",
          "False alarm",
          "I'm OK",
        ];
        const ambiguousMessages = ["No", "Yes", "Understood"];

        if (currentAlert && currentAlert.id === "gas-high-threshold") {
          const gasReading = getCurrentGasReading();
          let messageType = isResponse ? "reply message" : "message";
          let shouldResolve =
            !isGasLevelHigh() && clearResolutionMessages.includes(responseText);
          let isAmbiguous = ambiguousMessages.includes(responseText);

          if (shouldResolve) {
            addLogEntry(
              `📱 Received ${messageType} '${responseText}', confirming the user is okay. Gas readings back to normal levels. Resolving alert.`,
              "step"
            );
            addLogEntry(`📤 Sent "Noted. Resolving alert." to device`, "step");
          } else if (isAmbiguous) {
            addLogEntry(
              `📱 Received ${messageType} '${responseText}'. Ambiguous response. Proceed with protocol escalation.`,
              "step"
            );
          } else {
            if (clearResolutionMessages.includes(responseText)) {
              addLogEntry(
                `📱 Received ${messageType} '${responseText}', confirming the user is okay. Gas levels remain elevated.`,
                "step"
              );
            } else {
              addLogEntry(
                `📱 Received ${messageType} '${responseText}'.`,
                "step"
              );
            }
          }
        } else {
          let messageType = isResponse ? "reply message" : "message";
          let shouldResolve = clearResolutionMessages.includes(responseText);
          let isAmbiguous = ambiguousMessages.includes(responseText);

          if (shouldResolve) {
            addLogEntry(
              `📱 Received ${messageType} '${responseText}', confirming the user is okay. Resolving alert.`,
              "step"
            );
            addLogEntry(`📤 Sent "Noted. Resolving alert." to device`, "step");
          } else if (isAmbiguous) {
            addLogEntry(
              `📱 Received ${messageType} '${responseText}'. Ambiguous response. Proceed with protocol escalation.`,
              "step"
            );
          } else {
            addLogEntry(
              `📱 Received ${messageType} '${responseText}'.`,
              "step"
            );
          }
        }

        if (responseText === "Send help") {
          addLogEntry(
            `📱 REceived 'Send help' message from device user. Escalating to dispatch or as required by protocol.`,
            "general"
          );
          triggerImmediateDispatch();
        }
      };

      window.setGasLevel = function (gas, value) {
        const gasData =
          gasReadingsData[
            currentAlert ? currentAlert.gasType || currentAlert.id : "default"
          ] || gasReadingsData.default;
        if (gasData[gas]) {
          gasData[gas].value = value;
          gasData[gas].status = value >= 10 ? "HIGH" : "NORMAL";
          updateGasReadings(
            currentAlert ? currentAlert.gasType || currentAlert.id : "default"
          );
          console.log("Set " + gas.toUpperCase() + " to " + value);
        }
      };

      // Demo functions for testing device connectivity
      window.setDeviceOffline = function (reason = "battery") {
        DeviceConnectivity.setDeviceOfflineScenario(reason);
        console.log(`Device set to OFFLINE (reason: ${reason})`);
        console.log("Current status:", DeviceConnectivity.currentStatus);
      };

      window.setDeviceOnline = function () {
        DeviceConnectivity.setDeviceOnlineScenario();
        console.log("Device set to ONLINE");
        console.log("Current status:", DeviceConnectivity.currentStatus);
      };

      window.testBatteryDead = function () {
        setDeviceOffline("battery");
      };
      window.testSignalLost = function () {
        setDeviceOffline("signal");
      };
      window.testCommunicationTimeout = function () {
        setDeviceOffline("communication");
      };

      window.checkDeviceStatus = function () {
        const status = DeviceConnectivity.currentStatus;
        const isOnline = DeviceConnectivity.isDeviceOnline();
        console.log("=== DEVICE STATUS CHECK ===");
        console.log("Last Communication:", status.lastCommunication);
        console.log("Battery:", status.battery + "%");
        console.log("Signal:", status.signal + "%");
        console.log(
          "BlackLine Online Status:",
          isOnline ? "🟢 ONLINE" : "🔴 OFFLINE"
        );
        return isOnline;
      };

      // ═══════════════════════════════════════════════════════════════
      // 🚑 ENHANCED DISPATCH STEP MANAGEMENT
      // ═══════════════════════════════════════════════════════════════

      function callDispatch() {
        // This function is called AFTER:
        // 1. "Call Dispatch" button clicked
        // 2. System evaluated conditions → "Yes"
        // 3. User selected services
        // 4. Now actually calling dispatch

        dispatchMade = true;

        // Get selected service from the correct dropdown ID
        const serviceDropdown = document.getElementById("dispatch");
        const selectedService = serviceDropdown ? serviceDropdown.value : "";

        // Remove popup alert - handle validation within UI
        if (!selectedService) {
          console.log(
            "No service selected, but proceeding with default service"
          );
          // Could add inline error message here instead of popup
        }

        // Use selected service or default to "Emergency services"
        const serviceToDispatch = selectedService || "Emergency services";

        // Create detailed dispatch log (this is the actual dispatch call)
        const now = new Date();
        const locationTime =
          now.toLocaleDateString("en-US", {
            year: "numeric",
            month: "short",
            day: "numeric",
            timeZone: "America/Chicago",
          }) +
          " at " +
          now.toLocaleTimeString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
            timeZone: "America/Chicago",
          }) +
          " CDT";

        // Get location data from connectivity panel
        const locationElement = document.getElementById("device-location");
        const coordinatesElement =
          document.getElementById("device-coordinates");
        const speedElement = document.getElementById("device-speed");
        const timestampElement = document.getElementById("location-timestamp");

        const location =
          locationElement?.textContent?.trim() || "[Location from device GPS]";
        const coordinates =
          coordinatesElement?.textContent?.trim() ||
          "[Coordinates from device]";
        const speed = speedElement?.textContent?.trim() || "0.0 km/h";
        const lastUpdate =
          timestampElement?.textContent?.trim() || locationTime;

        const detailedLog = `Called dispatch, spoke with ___. Requested ${serviceToDispatch} dispatch to the following location:
Last Location: ${lastUpdate}
Approximate Address: ${location}
Latitude / Longitude: ${coordinates}
Speed: ${speed}
Waiting 30 minutes.`;

        addLogEntry(detailedLog, "step");

        // Start 30-minute dispatch callback timer
        // Find current dispatch step dynamically
        const currentDispatchStep = document
          .querySelector('.step.active [onclick*="callDispatch"]')
          ?.closest(".step")?.id;
        startGlobalTimer(
          currentDispatchStep || "step-5", // Fallback to step-5 if not found
          "Dispatch Callback",
          "Emergency Services",
          1800
        );

        // Update UI to show dispatch completion
        updateDispatchUI();

        // Auto-update resolution
        const resolutionSelect = document.getElementById("resolution-reason");
        if (resolutionSelect && !resolutionSelect.value) {
          const resolutionType = determineResolutionType(currentAlert);
          resolutionSelect.value = resolutionType;
        }
      }

      function handleDispatchDecision(stepId) {
        const decisionElement = document.getElementById("dispatch-decision");
        const serviceContainer = document.getElementById(
          "service-type-container"
        );
        const skipContainer = document.getElementById("skip-reason-container");
        const notesArea = document.getElementById(stepId + "-note"); // ← Now dynamic

        // Safety check - only proceed if elements exist
        if (!decisionElement || !serviceContainer || !skipContainer) {
          return;
        }

        const decision = decisionElement.value;

        if (decision === "yes") {
          serviceContainer.style.display = "block";
          skipContainer.style.display = "none";
          if (notesArea)
            notesArea.placeholder =
              "Document dispatch details and service response...";
        } else if (decision === "no") {
          serviceContainer.style.display = "none";
          skipContainer.style.display = "block";
          if (notesArea)
            notesArea.placeholder = "Document why dispatch was not required...";
        } else {
          serviceContainer.style.display = "none";
          skipContainer.style.display = "none";
          if (notesArea) notesArea.placeholder = "Document the result...";
        }
      }
      function evaluateDispatchConditions() {
        const conditions = {
          shouldDispatch: false,
          passingConditions: [],
          failingReasons: [],
          primarySkipReason: null,
        };

        // Condition 1: No contact with user (check completed steps)
        const userContactAttempted = protocolState.completedSteps.some((step) =>
          ["step-1", "step-2", "step-3"].includes(step)
        );
        const userConfirmedOK = checkIfUserConfirmedOK();

        if (userContactAttempted && !userConfirmedOK) {
          conditions.passingConditions.push("No contact with user established");
        } else if (userConfirmedOK) {
          conditions.failingReasons.push("User confirmed they are okay");
          conditions.primarySkipReason = "user-confirmed-ok";
        } else {
          conditions.failingReasons.push("Contact attempts not completed");
        }

        // Condition 2: Emergency contact unsuccessful (check Step 4)
        const ecContactCompleted =
          protocolState.completedSteps.includes("step-4");
        const ecConfirmedOK = checkIfECConfirmedUserOK();

        if (ecContactCompleted && !ecConfirmedOK) {
          conditions.passingConditions.push("Emergency contact unsuccessful");
        } else if (ecConfirmedOK) {
          conditions.failingReasons.push(
            "Emergency contact confirmed user is okay"
          );
          if (!conditions.primarySkipReason) {
            conditions.primarySkipReason = "ec-confirmed-ok";
          }
        }

        // Condition 3: Gas levels remain HIGH (for gas alerts only)
        if (currentAlert && currentAlert.id === "gas-high-threshold") {
          if (isGasLevelHigh()) {
            conditions.passingConditions.push("Gas levels remain HIGH");
          } else {
            conditions.failingReasons.push("Gas levels returned to normal");
            if (!conditions.primarySkipReason) {
              conditions.primarySkipReason = "gas-levels-normal";
            }
          }
        }

        // Determine if dispatch should occur
        conditions.shouldDispatch =
          conditions.passingConditions.length > 0 &&
          !userConfirmedOK &&
          !ecConfirmedOK;

        return conditions;
      }

      function checkIfUserConfirmedOK() {
        // Check if any step had "confirmed OK" outcome
        return protocolState.completedSteps.some((stepId) => {
          const select = document.getElementById(stepId + "-select");
          return select && select.value === "confirmed-ok";
        });
      }

      function checkIfECConfirmedUserOK() {
        // Check Step 4 outcomes for EC confirmation
        const step4Select = document.getElementById("step-4-select");
        return step4Select && step4Select.value === "confirmed-ok";
      }

      function generateDispatchNotes(conditions) {
        let notes = "Dispatch: Decision Analysis\n\n";

        if (conditions.shouldDispatch) {
          notes += "DISPATCH REQUIRED:\n";
          conditions.passingConditions.forEach((condition) => {
            notes += "✓ " + condition + "\n";
          });
          notes += "\nDispatching emergency services per protocol.";
        } else {
          notes += "DISPATCH NOT REQUIRED:\n";
          conditions.failingReasons.forEach((reason) => {
            notes += "✗ " + reason + "\n";
          });
          notes += "\nNo emergency services dispatch needed.";
        }

        return notes;
      }

      function updateDispatchUI() {
        // Enhanced visual feedback for dispatch actions
        const serviceContainer = document.getElementById(
          "service-type-container"
        );
        const dispatchStatus = document.getElementById("dispatch-status");

        if (serviceContainer && dispatchMade) {
          serviceContainer.style.background = "#d4edda";
          serviceContainer.style.borderColor = "#28a745";

          // Disable the service dropdown after dispatch
          const serviceDropdown = document.getElementById("service-dropdown");
          if (serviceDropdown) {
            serviceDropdown.disabled = true;
            serviceDropdown.style.opacity = "0.7";
          }

          // Update dispatch button
          const dispatchBtn = serviceContainer.querySelector("button");
          if (dispatchBtn) {
            dispatchBtn.disabled = true;
            dispatchBtn.innerHTML = "✅ Dispatch Completed";
            dispatchBtn.classList.remove("btn-danger");
            dispatchBtn.classList.add("btn-success");
          }
        }

        if (dispatchStatus && dispatchMade) {
          dispatchStatus.style.display = "block";
        }
      }

      function enhanceStepVisual(stepId) {
        // Add special styling for dispatch step when active
        const step = document.getElementById(stepId);
        if (step) {
          step.style.background = "linear-gradient(135deg, #fff3cd, #ffeaa7)";
          step.style.border = "2px solid #ffc107";
        }
      }

      function validateDispatchDecision() {
        const decision = document.getElementById("dispatch-decision").value;

        // Find current dispatch step dynamically
        const currentDispatchStep = document
          .querySelector('.step.active [id="dispatch-decision"]')
          ?.closest(".step")?.id;
        const dispatchNote = document.getElementById(
          currentDispatchStep + "-note"
        );

        let isValid = false;

        if (decision === "yes") {
          // For YES: just check if service dropdown has a value and note has text
          const dispatchType = document.getElementById("service-dropdown");
          isValid =
            dispatchType &&
            dispatchType.value &&
            step5Note &&
            step5Note.value.trim().length > 0;
        } else if (decision === "no") {
          // For NO: check if skip reason is selected and note has text
          const skipReason = document.getElementById("skip-reason");
          isValid =
            skipReason &&
            skipReason.value &&
            step5Note &&
            step5Note.value.trim().length > 0;
        }

        return isValid;
      }

      function getSelectedServices() {
        const serviceDropdown = document.getElementById("service-dropdown");
        return serviceDropdown && serviceDropdown.value
          ? [serviceDropdown.value]
          : [];
      }

      function logDispatchDecision(stepId) {
        // ← Add stepId parameter
        // Comprehensive logging for dispatch decisions
        const decision = document.getElementById("dispatch-decision").value;
        const gasReading = getCurrentGasReading();

        if (decision === "yes") {
          const services = getSelectedServices();
          const servicesText =
            services.length > 0 ? services.join(", ") : "Emergency Services";

          let logMessage =
            getStepLabel(stepId) +
            ": Dispatch decision - YES. Services: " +
            servicesText;

          if (currentAlert && currentAlert.id === "gas-high-threshold") {
            logMessage +=
              ". Gas level: " +
              gasReading.status +
              " – Gas Reading: " +
              gasReading.type +
              ": " +
              gasReading.value +
              gasReading.unit;
          }

          addLogEntry(logMessage, "step");
        } else if (decision === "no") {
          const skipReason = document.getElementById("skip-reason");
          const reasonText = skipReason.options[skipReason.selectedIndex].text;

          let logMessage =
            getStepLabel(stepId) +
            ": Dispatch decision - NO. Reason: " +
            reasonText;

          if (currentAlert && currentAlert.id === "gas-high-threshold") {
            logMessage +=
              ". Gas level: " +
              gasReading.status +
              " – Gas Reading: " +
              gasReading.type +
              ": " +
              gasReading.value +
              gasReading.unit;
          }

          addLogEntry(logMessage, "step");
        }
      }

      // ═══════════════════════════════════════════════════════════════
      // 🚑 DISPATCH CONDITION CHECKER (UPDATED)
      // ═══════════════════════════════════════════════════════════════

      function checkDispatchConditions(stepId) {
        console.log("checkDispatchConditions called for:", stepId);

        // Add visual enhancement (make step-agnostic)
        enhanceStepVisual(stepId); // Remove "Step5" from function name

        // Get the actual dispatch conditions using connectivity data
        const result = evaluateDispatchConditionsFromConnectivity();

        const dispatchDropdown = document.getElementById("dispatch-decision");
        const outcomeSection = document.getElementById(stepId + "-outcome");

        console.log("Dispatch conditions result:", result);

        if (!dispatchDropdown || !outcomeSection) {
          console.error("Required elements not found");
          console.error(
            "Looking for:",
            stepId + "-outcome",
            "and dispatch-decision"
          );
          return;
        }

        // Show outcome section for any step
        outcomeSection.style.display = "block";

        // Auto-populate based on conditions
        if (result.canDispatch) {
          dispatchDropdown.value = "yes";
          // Auto-update resolution using centralized logic
          const resolutionSelect = document.getElementById("resolution-reason");
          if (resolutionSelect && !resolutionSelect.value) {
            const resolutionType = determineResolutionType(currentAlert);
            resolutionSelect.value = resolutionType;
          }
        } else {
          dispatchDropdown.value = "no";
          // Auto-update resolution using centralized logic
          const resolutionSelect = document.getElementById("resolution-reason");
          if (resolutionSelect && !resolutionSelect.value) {
            const resolutionType = determineResolutionType(currentAlert);
            resolutionSelect.value = resolutionType;
          }

          // Auto-select the first failed reason
          setTimeout(() => {
            const skipReasonSelect = document.getElementById("skip-reason");
            if (skipReasonSelect && result.failedReasons.length > 0) {
              const reason = result.failedReasons[0];
              if (
                reason.includes("Location unavailable") ||
                reason.includes("too old") ||
                reason.includes("location")
              ) {
                skipReasonSelect.value = "location-stale";
              } else if (
                reason.includes("Device offline") ||
                reason.includes("offline")
              ) {
                skipReasonSelect.value = "device-offline";
              } else if (
                reason.includes("Device moving") ||
                reason.includes("too fast") ||
                reason.includes("moving")
              ) {
                skipReasonSelect.value = "device-moving";
              }

              console.log("Auto-selected skip reason:", skipReasonSelect.value);
            }
          }, 100);
        }

        // Trigger the display logic
        handleDispatchDecision();

        // Auto-populate notes with evaluation summary (use dynamic stepId)
        setTimeout(() => {
          const notesArea = document.getElementById(stepId + "-note");
          if (notesArea && !notesArea.value.trim()) {
            notesArea.value = generateDispatchAnalysisNotes(result);
            validatePostButton(stepId);
          }
        }, 200);
      }

      function evaluateDispatchConditionsFromConnectivity() {
        const conditions = {
          deviceOnline: false,
          locationFresh: false,
          deviceStationary: false,
        };
        const failedReasons = [];
        const passedReasons = [];

        // Check if we have perfect conditions from currentAlert
        if (currentAlert && currentAlert.deviceConditions) {
          const dc = currentAlert.deviceConditions;

          // Condition 1: Device Online
          conditions.deviceOnline =
            dc.lastComm < 30 && dc.battery > 10 && dc.signal > 10;
          if (conditions.deviceOnline) {
            passedReasons.push("Device online");
          } else {
            failedReasons.push(
              "Device offline (last comm > 30 min, battery ≤ 10%, or signal ≤ 10%)"
            );
          }

          // Condition 2: Location Fresh (< 5 min old)
          conditions.locationFresh = dc.locationAge < 5;
          if (conditions.locationFresh) {
            passedReasons.push("Location fresh");
          } else {
            failedReasons.push("Location not valid or current");
          }

          // Condition 3: Device Stationary (< 5 km/h)
          conditions.deviceStationary = dc.deviceSpeed < 5;
          if (conditions.deviceStationary) {
            passedReasons.push("Device stationary");
          } else {
            failedReasons.push("Device not stationary (≥ 5 km/h)");
          }
        } else {
          // Fallback to old DOM-based checking
          failedReasons.push("Location not valid or current");
        }

        const allConditionsMet =
          conditions.deviceOnline &&
          conditions.locationFresh &&
          conditions.deviceStationary;

        return {
          canDispatch: allConditionsMet,
          conditions: conditions,
          passedReasons: passedReasons,
          failedReasons: failedReasons,
        };
      }

      function generateDispatchAnalysisNotes(result) {
        // Get location and communication data from connectivity panel
        const locationElement = document.getElementById("device-location");
        const lastCommElement = document.getElementById("last-comm-time");
        const location = locationElement
          ? locationElement.textContent
          : "Location unknown";
        const lastComm = lastCommElement
          ? lastCommElement.textContent
          : "Communication time unknown";

        if (result.canDispatch) {
          // Get current dispatch step dynamically
          const currentDispatchStep = document
            .querySelector('.step.active [onclick*="checkDispatchConditions"]')
            ?.closest(".step")?.id;
          const stepNumber = currentDispatchStep
            ? currentDispatchStep.replace("step-", "")
            : "5";

          // Get all connectivity data
          const locationTimestamp =
            document
              .getElementById("location-timestamp")
              ?.textContent?.trim() || "";
          const address =
            document.getElementById("device-location")?.textContent?.trim() ||
            "";
          const coordinates =
            document
              .getElementById("device-coordinates")
              ?.textContent?.trim() || "";
          const speed =
            document.getElementById("device-speed")?.textContent?.trim() || "";
          const lastCommTimestamp =
            document
              .querySelector('[id*="last-communication"]')
              ?.textContent?.trim() || "";
          const battery =
            document.querySelector('[id*="battery"]')?.textContent?.trim() ||
            "";

          // Get signal data based on device type
          const deviceType = currentUser?.device?.includes("G7x")
            ? "G7x"
            : "G7c";
          let signalInfo = "";

          if (deviceType === "G7x") {
            const deviceSignal =
              document
                .querySelector('[id*="device-signal"]')
                ?.textContent?.trim() || "";
            const bridgeSignal =
              document
                .querySelector('[id*="bridge-signal"]')
                ?.textContent?.trim() || "";
            signalInfo =
              "**Device Signal Strength** - " +
              deviceSignal +
              "\n" +
              "**Bridge Signal Strength** - " +
              bridgeSignal +
              "\n\n";
          } else {
            const signal =
              document.querySelector('[id*="signal"]')?.textContent?.trim() ||
              "";
            signalInfo = "**Signal Strength** - " + signal + "\n\n";
          }

          return (
            `Step ${stepNumber}: Called dispatch, spoke to ___. Dispatched [SELECTED_SERVICES] to following location:\n\n` +
            "**Last Location**\n" +
            locationTimestamp +
            "\n\n" +
            "**Approximate Address**\n" +
            address +
            "\n\n" +
            "**Latitude / Longitude**\n" +
            coordinates +
            "\n\n" +
            "**Speed** - " +
            speed +
            "\n\n" +
            "**Last Communication**\n" +
            lastCommTimestamp +
            "\n\n" +
            "**Battery** - " +
            battery +
            "\n" +
            signalInfo
          );
        } else {
          // Get specific failed condition with timestamp
          const failedCondition = result.failedReasons[0];
          const timestamp =
            new Date().toLocaleString("en-US", {
              timeZone: "America/Denver",
              year: "numeric",
              month: "short",
              day: "2-digit",
              hour: "2-digit",
              minute: "2-digit",
              hour12: false,
            }) + " MDT";

          return (
            "Dispatch: Unable to dispatch - " +
            failedCondition +
            " (checked at " +
            timestamp +
            ")"
          );
        }
      }

      function generateDispatchProtocolLog(
        decision,
        reason,
        selectedService,
        stepId
      ) {
        // Get all panel data
        const locationElement = document.getElementById("device-location");
        const coordinatesElement =
          document.getElementById("device-coordinates");
        const speedElement = document.getElementById("device-speed");
        const locationTimestamp = document.getElementById("location-timestamp");
        const lastCommElement = document.getElementById("last-comm-time");
        const batteryElement = document.getElementById("battery-level");
        const signalElement = document.getElementById("signal-strength");

        // Calculate time ago for location
        const getTimeAgo = (timestampText) => {
          const locationTime = new Date(
            timestampText.replace(" at ", " ").replace(" MDT", "")
          );
          const minutesAgo = Math.floor(
            (new Date() - locationTime) / (1000 * 60)
          );
          if (minutesAgo < 60) {
            return minutesAgo + " minutes old";
          } else {
            const hoursAgo = Math.floor(minutesAgo / 60);
            return hoursAgo + " hours old";
          }
        };

        let logEntry = "";

        if (decision === "yes") {
          logEntry =
            getStepLabel(stepId) +
            ": Called dispatch. Dispatched " +
            (selectedService || "Emergency Services") +
            " to the following location:";
        } else {
          logEntry =
            getStepLabel(stepId) + ": Unable to dispatch - " + reason + ".";
        }

        // Always add location data with proper spacing
        logEntry += "\n\nLast Known Location";
        if (locationElement)
          logEntry += "\nAddress: " + locationElement.textContent;
        if (coordinatesElement)
          logEntry += "\nCoordinates: " + coordinatesElement.textContent;
        if (speedElement) logEntry += "\nSpeed: " + speedElement.textContent;
        if (locationTimestamp) {
          if (decision === "no" && reason.includes("location")) {
            logEntry +=
              "\nLast Location Date/Time: " +
              locationTimestamp.textContent +
              " (" +
              getTimeAgo(locationTimestamp.textContent) +
              ")";
          } else {
            logEntry +=
              "\nLast Location Date/Time: " + locationTimestamp.textContent;
          }
        }

        // Add specific data based on decision/reason
        if (decision === "yes") {
          // For dispatch approved, add device status and timer note
          logEntry += "\n\nDevice Status";
          if (lastCommElement)
            logEntry += "\nLast Communication: " + lastCommElement.textContent;
          if (batteryElement)
            logEntry += "\nBattery: " + batteryElement.textContent;
          if (signalElement)
            logEntry += "\nSignal: " + signalElement.textContent;
          logEntry += "\n\nWaiting 30 minutes.";
        } else if (reason.includes("offline")) {
          // For device offline, add communication data
          logEntry +=
            "\n\nLast Communication: " +
            lastCommElement.textContent +
            " (" +
            getTimeAgo(lastCommElement.textContent) +
            ")";
          if (batteryElement)
            logEntry += "\nBattery Level: " + batteryElement.textContent;
          if (signalElement)
            logEntry += "\nSignal Strength: " + signalElement.textContent;
        }

        return logEntry;
      }

      // ═══════════════════════════════════════════════════════════════
      // 🚀 INITIALIZATION & STARTUP
      // ═══════════════════════════════════════════════════════════════

      document.addEventListener("DOMContentLoaded", function () {
        updateGasReadings("default");
        startGasMonitoring();

        // Initialize device connectivity
        DeviceConnectivity.updateConnectivityDisplay();

        // Update connectivity every 30 seconds
        setInterval(() => {
          DeviceConnectivity.updateConnectivityDisplay();
        }, 30000);

        const messageInput = document.getElementById("manual-message-input");
        const charCounter = document.getElementById("charCounter");
        const sendBtn = document.getElementById("sendMessageBtn");

        if (messageInput && charCounter && sendBtn) {
          messageInput.addEventListener("input", () => {
            const remaining = 32 - messageInput.value.length;
            charCounter.textContent = `${remaining} characters remaining`;
            sendBtn.disabled =
              remaining < 0 || messageInput.value.trim() === "";
          });
        }
      });

      document.addEventListener("click", function (event) {
        const demoPanel = document.getElementById("demo-panel");
        const demoGear = document.getElementById("demo-gear");

        if (
          demoPanel &&
          demoGear &&
          !demoPanel.contains(event.target) &&
          !demoGear.contains(event.target)
        ) {
          demoPanel.classList.remove("show");
        }
      });

      function triggerGasNormalization(alertConfig) {
        if (
          !alertConfig.gasNormalization ||
          !alertConfig.gasNormalization.enabled
        )
          return;

        const config = alertConfig.gasNormalization;

        // Store peak reading before updating
        let peakReading = "";

        // Update gas readings to target levels
        Object.keys(config.targetLevels).forEach((gasType) => {
          const target = config.targetLevels[gasType];
          const valueElement = document.getElementById(gasType + "-value");
          const statusElement = document.getElementById(gasType + "-status");
          const readingElement = document.getElementById(gasType + "-reading");

          if (valueElement && statusElement) {
            // Store peak reading before changing
            const currentValue = valueElement.textContent;
            peakReading = gasType.toUpperCase() + " " + currentValue;

            // Update display
            const unit =
              gasType === "o2" ? " %vol" : gasType === "lel" ? " %LEL" : " ppm";
            valueElement.textContent = target.value.toFixed(2) + unit;
            statusElement.textContent = target.status;
            statusElement.className =
              "gas-status " + target.status.toLowerCase();

            // Update icon
            if (readingElement) {
              const icon = target.status === "HIGH" ? "🔴" : "🟢";
              const gasLabel =
                gasType === "h2s" ? "H₂S" : gasType.toUpperCase();
              readingElement.querySelector("span").innerHTML =
                icon +
                " " +
                gasLabel +
                ': <span class="gas-value">' +
                target.value.toFixed(2) +
                unit +
                "</span>";
            }
          }
        });

        // System log with proper format
        const gasTypeLabel = Object.keys(config.targetLevels)[0].toUpperCase();
        const timestamp =
          new Date().toLocaleDateString("en-CA") +
          " " +
          new Date().toLocaleTimeString("en-US", {
            hour12: false,
            timeZone: "America/Denver",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
          }) +
          " MDT";

        addLogEntry(
          gasTypeLabel +
            " is no longer exceeding the high threshold. A peak reading of " +
            peakReading +
            " was reported.",
          "system",
          "*Sensor reading update*",
          timestamp
        );
      }

      function scrollToResolution() {
        const resolutionSection = document.querySelector(".resolution-section");
        if (resolutionSection) {
          resolutionSection.scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        }
      }

      function triggerResolutionFlow(
        fromStepId,
        reason = "User confirmed okay"
      ) {
        // 1. Mark current step complete
        if (fromStepId) {
          markStepComplete(fromStepId);
        }

        // 2. Block all remaining steps
        blockRemainingSteps(fromStepId, reason);

        // 3. Auto-populate resolution dropdown
        const resolutionSelect = document.getElementById("resolution-reason");
        if (resolutionSelect && !resolutionSelect.value) {
          const resolutionType = determineResolutionType(currentAlert);
          resolutionSelect.value = resolutionType;
        }

        // 4. Scroll to resolution panel
        setTimeout(() => {
          const resolutionSection = document.querySelector(
            ".resolution-section"
          );
          if (resolutionSection) {
            resolutionSection.scrollIntoView({
              behavior: "smooth",
              block: "center",
            });
          }
        }, 300);
      }

      function canStepTriggerResolution(stepId) {
        // Any step can potentially trigger resolution based on its outcome
        // Check if step has resolution-triggering actions
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const stepConfig = protocolConfig.steps.find(
          (step) => step.id === stepId
        );

        // Resolution can be triggered by: Call User, Send Message, Contact ECs, or Dispatch
        const resolutionActions = [
          "call-user",
          "message-device",
          "call-emergency-contacts",
          "dispatch",
        ];
        return stepConfig && resolutionActions.includes(stepConfig.action);
      }

      function enableNextStep(stepId) {
        // Get current protocol to determine next step
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const currentIndex = protocolConfig.steps.findIndex(
          (step) => step.id === stepId
        );

        // Check if there's a next step
        if (
          currentIndex >= 0 &&
          currentIndex < protocolConfig.steps.length - 1
        ) {
          const nextStep = protocolConfig.steps[currentIndex + 1];
          const nextStepId = nextStep.id;

          const nextStepElement = document.getElementById(nextStepId);
          const nextButton = nextStepElement?.querySelector(
            'button:not([onclick*="postNote"])'
          );

          if (nextStepElement) {
            nextStepElement.classList.add("active");
            nextStepElement.style.opacity = "1";
            nextStepElement.style.pointerEvents = "auto";

            // AUTO-SCROLL: Scroll the newly active step into view
            nextStepElement.scrollIntoView({
              behavior: "smooth",
              block: "center",
            });
          }

          if (nextButton) {
            nextButton.disabled = false;
            nextButton.classList.remove("btn-secondary");
            nextButton.classList.add("btn-primary");
          }

          // Update status badge
          const statusBadge = document.getElementById(nextStepId + "-status");
          if (statusBadge) {
            statusBadge.textContent = "Active";
            statusBadge.className = "status-badge active";
          }

          // Auto-evaluate dispatch conditions if next step is dispatch
          if (nextStep.action === "dispatch") {
            setTimeout(() => {
              checkDispatchConditions(nextStepId);
            }, 500);
          }
        }
      }

      // Silent background monitoring - NO LOGGING
      function initializeDispatchMonitoring() {
        // Initial silent evaluation
        silentlyUpdateDispatchConditions();

        // Background monitoring every 2 minutes
        setInterval(silentlyUpdateDispatchConditions, 120000);
      }

      function silentlyUpdateDispatchConditions() {
        // Skip if no dispatch step active
        const dispatchDropdown = document.getElementById("dispatch-decision");
        if (!dispatchDropdown) return;

        // Evaluate conditions (reuse existing function)
        const conditions = evaluateDispatchConditionsFromConnectivity();

        // Silently update dropdown if conditions changed
        const newValue = conditions.canDispatch ? "yes" : "no";
        if (dispatchDropdown.value !== newValue) {
          dispatchDropdown.value = newValue;

          // Silently update interface containers
          const serviceContainer = document.getElementById(
            "service-type-container"
          );
          const skipContainer = document.getElementById(
            "skip-reason-container"
          );

          if (newValue === "yes") {
            if (serviceContainer) serviceContainer.style.display = "block";
            if (skipContainer) skipContainer.style.display = "none";
          } else {
            if (serviceContainer) serviceContainer.style.display = "none";
            if (skipContainer) skipContainer.style.display = "block";
          }
        }

        // Color-code the dropdown
        if (dispatchDropdown.value === "yes") {
          dispatchDropdown.style.backgroundColor = "#d4edda";
          dispatchDropdown.style.borderColor = "#28a745";
          dispatchDropdown.style.color = "#155724";
          dispatchDropdown.style.borderWidth = "2px";
        } else if (dispatchDropdown.value === "no") {
          dispatchDropdown.style.backgroundColor = "#f8d7da";
          dispatchDropdown.style.borderColor = "#dc3545";
          dispatchDropdown.style.color = "#721c24";
          dispatchDropdown.style.borderWidth = "2px";
        } else {
          dispatchDropdown.style.backgroundColor = "#ffffff";
          dispatchDropdown.style.borderColor = "#ddd";
          dispatchDropdown.style.color = "#333";
          dispatchDropdown.style.borderWidth = "1px";
        }
      }

      function autoPopulateDispatchNote(stepId) {
        const serviceSelect = document.getElementById("dispatch");
        const textarea = document.getElementById(stepId + "-note");
        const selectedService = serviceSelect?.value;

        if (selectedService && textarea) {
          const stepNumber = stepId.replace("step-", "");

          // Get real connectivity data
          const location = document
            .getElementById("device-location")
            .textContent.trim();
          const coordinates = document
            .getElementById("device-coordinates")
            .textContent.trim();
          const speed = document
            .getElementById("device-speed")
            .textContent.trim();
          const lastComm = document
            .getElementById("last-comm-time")
            .textContent.trim();
          const battery = document
            .getElementById("battery-level")
            .textContent.trim();
          const signal = document
            .getElementById("signal-strength")
            .textContent.trim();

          // Generate today's timestamp for dispatch purposes
          const now = new Date();
          const todaysTimestamp =
            now.toLocaleDateString("en-US", {
              year: "numeric",
              month: "short",
              day: "2-digit",
            }) +
            " at " +
            now.toLocaleTimeString("en-US", {
              hour: "2-digit",
              minute: "2-digit",
              hour12: false,
            }) +
            " MDT";

          const dispatchNote = `Step ${stepNumber}: Called dispatch, spoke to ___. Dispatched ${selectedService} to the following location:

Last Location Date/Time: ${todaysTimestamp} (just now)

Approximate Address: ${location}

Latitude / Longitude: ${coordinates}

Speed: ${speed}

Last Communication: ${lastComm}

Battery: ${battery}

Signal Strength: ${signal}

Waiting 30 minutes.`;

          textarea.value = dispatchNote;
          validatePostButton(stepId);
        }
      }

      // Silent background monitoring - NO LOGGING
      function initializeDispatchMonitoring() {
        // Initial silent evaluation
        silentlyUpdateDispatchConditions();

        // Background monitoring every 2 minutes
        setInterval(silentlyUpdateDispatchConditions, 120000);
      }

      function silentlyUpdateDispatchConditions() {
        // Skip if no dispatch step active
        const dispatchDropdown = document.getElementById("dispatch-decision");
        const unmetConditionDropdown = document.getElementById("skip-reason");
        if (!dispatchDropdown) return;

        // Evaluate conditions using existing function
        const conditions = evaluateDispatchConditionsFromConnectivity();

        // Silently update dispatch dropdown if conditions changed
        const newValue = conditions.canDispatch ? "yes" : "no";
        if (dispatchDropdown.value !== newValue) {
          dispatchDropdown.value = newValue;

          // Update containers visibility
          const serviceContainer = document.getElementById(
            "service-type-container"
          );
          const skipContainer = document.getElementById(
            "skip-reason-container"
          );

          if (newValue === "yes") {
            if (serviceContainer) serviceContainer.style.display = "block";
            if (skipContainer) skipContainer.style.display = "none";
          } else {
            if (serviceContainer) serviceContainer.style.display = "none";
            if (skipContainer) skipContainer.style.display = "block";

            // Auto-populate unmet condition dropdown
            if (unmetConditionDropdown && conditions.failedReasons.length > 0) {
              const failedReason = conditions.failedReasons[0]; // Use first failed reason

              // Map failed reasons to dropdown values
              if (failedReason.includes("Device offline")) {
                unmetConditionDropdown.value = "device-offline";
              } else if (failedReason.includes("Location not valid")) {
                unmetConditionDropdown.value = "location-invalid";
              } else if (failedReason.includes("Device not stationary")) {
                unmetConditionDropdown.value = "device-moving";
              }
            }
          }
        }

        // Color-code the dispatch dropdown
        if (dispatchDropdown.value === "yes") {
          dispatchDropdown.style.backgroundColor = "#d4edda"; // Light green
          dispatchDropdown.style.borderColor = "#28a745"; // Green border
          dispatchDropdown.style.color = "#155724"; // Dark green text
          dispatchDropdown.style.borderWidth = "2px";
        } else if (dispatchDropdown.value === "no") {
          dispatchDropdown.style.backgroundColor = "#f8d7da"; // Light red
          dispatchDropdown.style.borderColor = "#dc3545"; // Red border
          dispatchDropdown.style.color = "#721c24"; // Dark red text
          dispatchDropdown.style.borderWidth = "2px";
        } else {
          dispatchDropdown.style.backgroundColor = "#ffffff"; // White
          dispatchDropdown.style.borderColor = "#ddd"; // Default border
          dispatchDropdown.style.color = "#333"; // Default text
          dispatchDropdown.style.borderWidth = "1px";
        }
      }

      // Enhanced enableNextStep with auto-scroll
      function enableNextStep(stepId) {
        // Get current protocol to determine next step
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const currentIndex = protocolConfig.steps.findIndex(
          (step) => step.id === stepId
        );

        // Check if there's a next step
        if (
          currentIndex >= 0 &&
          currentIndex < protocolConfig.steps.length - 1
        ) {
          const nextStep = protocolConfig.steps[currentIndex + 1];
          const nextStepId = nextStep.id;

          const nextStepElement = document.getElementById(nextStepId);
          const nextButton = nextStepElement?.querySelector(
            'button:not([onclick*="postNote"])'
          );

          if (nextStepElement) {
            nextStepElement.classList.add("active");
            nextStepElement.style.opacity = "1";
            nextStepElement.style.pointerEvents = "auto";

            // AUTO-SCROLL: Scroll the newly active step into view
            nextStepElement.scrollIntoView({
              behavior: "smooth",
              block: "center",
            });
          }

          if (nextButton) {
            nextButton.disabled = false;
            nextButton.classList.remove("btn-secondary");
            nextButton.classList.add("btn-primary");
          }

          // Update status badge
          const statusBadge = document.getElementById(nextStepId + "-status");
          if (statusBadge) {
            statusBadge.textContent = "Active";
            statusBadge.className = "status-badge active";
          }

          // Auto-evaluate dispatch conditions if next step is dispatch
          if (nextStep.action === "dispatch") {
            setTimeout(() => {
              checkDispatchConditions(nextStepId);
              silentlyUpdateDispatchConditions(); // Auto-evaluate dispatch conditions
            }, 500);
          }
        }
      }

      function determineResolutionType(alertData) {
        // Dimension 1: Alert Type - EXPANDABLE
        let alertCategory;

        if (isGasAlert(alertData)) {
          alertCategory = "incident";
        } else {
          alertCategory = "false-alert";
        }

        // Future expansion:
        // Demo/Training
        // System Test
        // Pre-alert
        // Multiple alert
        // System Maintenance

        // Dimension 2: Dispatch Status - CHECK SYSTEM STATE
        const hasDispatch = dispatchMade;

        // Build resolution string dynamically
        const dispatchSuffix = hasDispatch
          ? "with-dispatch"
          : "without-dispatch";
        return `${alertCategory}-${dispatchSuffix}`;
      }
    </script>
  </body>
</html>
