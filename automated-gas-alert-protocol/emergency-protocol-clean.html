<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Automated Emergency Response Platform</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #f8f9fa;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
      }

      .header {
        background: linear-gradient(135deg, #e3f2fd, #bbdefb);
        color: #1565c0;
        padding: 20px;
        margin-bottom: 20px;
        border-radius: 8px;
        border: 1px solid #90caf9;
        display: none;
      }

      .header.active {
        display: block;
      }

      .alert-title {
        margin: 0;
        font-size: 1.5em;
        font-weight: bold;
        margin-bottom: 15px;
      }

      .alert-details {
        background: white;
        border: 1px solid #90caf9;
        border-radius: 6px;
        padding: 15px;
        color: #333;
      }

      .alert-info {
        display: block;
        font-size: 0.9em;
      }
      .info-item {
        padding: 3px 0;
      }
      .info-item strong {
        color: #1565c0;
        font-weight: 600;
      }

      .container {
        display: grid;
        grid-template-columns: 1fr 200px 1fr 300px;
        gap: 15px;
        max-width: 1600px;
        margin: 0 auto;
        padding: 20px;
      }

      .right-column {
        display: flex;
        flex-direction: column;
        gap: 15px;
        grid-column: 4;
      }

      .protocol-log {
        background: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 20px;
      }

      .protocol-log h3 {
        margin-top: 0;
        color: #333;
        font-size: 1.1em;
      }

      .log-container {
        height: calc(100vh - 350px);
        min-height: 400px;
        overflow-y: auto;
        background: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        border: 1px solid #e9ecef;
        margin-bottom: 20px;
      }

      .log-entry {
        margin: 8px 0;
        padding: 12px;
        background: white;
        border-left: 4px solid #28a745;
        border-radius: 6px;
        font-size: 0.9em;
        line-height: 1.4;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .log-entry.step {
        border-left-color: #007bff;
      }
      .log-entry.timer {
        border-left-color: #ffc107;
      }
      .log-entry.resolution {
        border-left-color: #dc3545;
      }
      .log-entry.gas {
        border-left-color: #fd7e14;
      }
      .log-entry.system {
        border-left-color: #6c757d;
      }

      .log-placeholder {
        color: #6c757d;
        text-align: center;
        margin-top: 120px;
        font-style: normal;
        font-size: 0.9em;
        font-family: inherit;
      }

      .global-timer {
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
        border-radius: 8px;
        padding: 15px;
        text-align: center;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        position: sticky;
        top: 20px;
        height: fit-content;
        font-size: 0.9em;
      }

      .timer-controls {
        margin-top: 12px;
        display: flex;
        justify-content: center;
        padding: 0 10px; 
      }

      .timer-meta {
        margin-top: 8px;
        font-size: 0.7em;
        opacity: 0.8;
        line-height: 1.2;
        display: flex;
        justify-content: space-between;
      }

      .cancel-btn {
        background: #dc3545;
        color: white !important;
        border: none;
        padding: 8px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        font-size: 0.75em;
        transition: background 0.2s;
        width: calc(100% - 20px);
        margin: 0 10px;
        display: block;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        opacity: 1 !important;
      }

      .cancel-btn:hover:not(:disabled) {
        background: #c82333;
      }

      .cancel-btn:disabled,
      #cancelTimerBtn.cancel-btn:disabled {
        opacity: 1 !important;
        cursor: not-allowed;
        color: white !important;
        background: #dc3545 !important;
      }

      .steps-section {
        background: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 20px;
      }

      .steps-section h3 {
        margin-top: 0;
        color: #333;
        font-size: 1.1em;
      }

      .gas-readings-card {
        background: white;
        border: 2px solid #28a745;
        border-radius: 8px;
        padding: 20px;
        position: sticky;
        top: 20px;
        height: fit-content;
      }

      .gas-readings-card h3 {
        margin-top: 0;
        color: #333;
        font-size: 1.1em;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .gas-reading {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid #e9ecef;
        font-size: 0.9em;
      }

      .gas-reading:last-child {
        border-bottom: none;
      }
      .gas-value {
        font-weight: bold;
      }

      .gas-status {
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.8em;
        font-weight: bold;
      }

      .gas-status.high {
        background: #f8d7da;
        color: #721c24;
      }

      .gas-status.normal {
        background: #d4edda;
        color: #155724;
      }

      .triggered-by {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 4px;
        padding: 8px;
        margin-bottom: 15px;
        font-size: 0.85em;
        font-weight: bold;
        color: #856404;
      }

      .last-updated {
        font-size: 0.8em;
        color: #6c757d;
        text-align: center;
        margin-top: 10px;
        font-style: italic;
      }

      .connectivity-panel {
        background: white;
        border: 2px solid #6c757d;
        border-radius: 8px;
        padding: 20px;
        height: fit-content;
      }

      .connectivity-panel h3 {
        margin-top: 0;
        color: #333;
        font-size: 1em;
        margin-bottom: 15px;
      }

      .device-status,
      .last-comm {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        font-size: 0.9em;
      }

      .status-pill {
        padding: 4px 10px;
        border-radius: 20px;
        font-weight: bold;
        font-size: 0.85em;
      }

      .status-pill.online {
        background: #d4edda;
        color: #155724;
      }

      .status-pill.offline {
        background: #f8d7da;
        color: #721c24;
      }

      .status-pill.loading {
        background: #fff3cd;
        color: #856404;
      }

      .step {
        background: white;
        border: 2px solid #bbdefb; 
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
        position: relative;
      }

      .sub-step {
        background: #f8f9fa;
        border: 1px solid #e3f2fd; 
        border-radius: 6px;
        padding: 12px;
        margin: 10px 0;
        margin-left: 15px;
      }

      .step.completed {
        background: #d4edda;
        border-color: #c3e6cb;
      }

      .step.active {
        animation: pulse-border 1.5s infinite;
      }

      @keyframes pulse-border {
        0% {
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(0, 123, 255, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0);
        }
      }

      .step-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .step-title {
        font-weight: bold;
        color: #333;
        margin: 0;
        font-size: 0.95em;
      }

      .status-badge {
        background: #ffc107;
        color: #000;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.75em;
        font-weight: bold;
      }

      .status-badge.completed {
        background: #28a745;
        color: white;
      }

      .contact-info {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 4px;
        padding: 8px;
        margin: 8px 0;
        font-size: 0.85em;
      }

      .btn {
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
        font-size: 0.85em;
        transition: all 0.2s;
      }

      .btn-primary {
        background: #007bff;
        color: white;
      }

      .btn-primary:hover:not(:disabled) {
        background: #0056b3;
      }

      .btn-success {
        background: #28a745;
        color: white;
      }

      .btn-success:hover:not(:disabled) {
        background: #1e7e34;
      }

      .btn-secondary {
        background: #6c757d;
        color: white;
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .timer-inactive {
        opacity: 0.6;
        background: linear-gradient(135deg, #6c757d, #495057);
      }

      .manual-notes {
        width: 100%;
        height: 100px;
        border-radius: 5px;
        border: 1px solid #ddd;
        padding: 10px;
        box-sizing: border-box;
        resize: vertical;
        font-family: inherit;
        font-size: 0.9em;
      }

      .step-outcome {
        margin: 10px 0;
      }

      .step-outcome select {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.9em;
      }

      .step.skipped {
        background-color: #f8f9fa !important;
        opacity: 0.6;
        pointer-events: none;
      }

      .step.skipped .status-badge {
        background-color: #6c757d !important;
        color: white !important;
      }

      .step.skipped button {
        background-color: #6c757d !important;
        color: #dee2e6 !important;
        border-color: #6c757d !important;
      }

      .step-outcome textarea {
        width: 100%;
        height: 80px;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.9em;
        margin-top: 8px;
        box-sizing: border-box;
        resize: vertical;
      }

      .resolution-section {
        background: #fff;
        border: 2px solid #dc3545;
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
      }

      .resolution-section h3 {
        margin-top: 0;
        color: #dc3545;
      }

      .resolution-section select {
        width: 100%;
        padding: 10px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      .resolution-buttons {
        display: flex;
        gap: 10px;
        margin-top: 15px;
      }

      .btn-danger {
        background: #dc3545;
        color: white;
      }

      .btn-danger:hover:not(:disabled) {
        background: #c82333;
      }

      /* Production View Toggle */
      .production-toggle {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 0.8em;
        cursor: pointer;
        z-index: 2000;
        transition: all 0.3s;
      }

      .production-toggle:hover {
        background: rgba(0, 0, 0, 0.9);
      }

      .production-mode .demo-gear,
      .production-mode .demo-panel {
        display: none !important;
      }

      .production-mode .header {
        margin-top: 10px;
      }

      /* Demo Controls */
      .demo-gear {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
        background: #6c757d;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 1000;
        transition: all 0.3s;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      }

      .demo-gear:hover {
        background: #5a6268;
        transform: rotate(90deg);
      }

      .demo-gear::before {
        content: "⚙️";
        font-size: 20px;
      }

      .demo-panel {
        position: fixed;
        bottom: 70px;
        right: 20px;
        background: rgba(255, 255, 255, 0.98);
        border-radius: 8px;
        padding: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        border: 1px solid #e9ecef;
        z-index: 999;
        max-width: 280px;
        max-height: 70vh;
        overflow-y: auto;
        display: none;
      }

      .demo-panel.show {
        display: block;
        animation: slideUp 0.3s ease-out;
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .demo-panel h4 {
        margin: 8px 0 6px 0;
        color: #333;
        font-size: 0.85em;
        border-bottom: 1px solid #e9ecef;
        padding-bottom: 4px;
        font-weight: 600;
      }

      .demo-panel h4:first-child {
        margin-top: 0;
      }

      .demo-button-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 4px;
        margin-bottom: 8px;
      }

      .demo-button-single {
        display: grid;
        grid-template-columns: 1fr;
        gap: 4px;
        margin-bottom: 8px;
      }

      .demo-panel button {
        font-size: 0.7em;
        padding: 6px 8px;
        margin: 0;
        border-radius: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1.2;
        height: auto;
        min-height: 28px;
      }

      .demo-panel .btn-secondary {
        grid-column: 1 / -1;
        margin-top: 8px;
        font-weight: 600;
      }

      .demo-section {
        margin-bottom: 10px;
      }

      .demo-section:last-child {
        margin-bottom: 0;
      }

      /* Collapsible sections */
      .demo-section-header {
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        user-select: none;
      }

      .demo-section-header::after {
        content: "▼";
        font-size: 0.7em;
        color: #666;
        transition: transform 0.2s;
      }

      .demo-section.collapsed .demo-section-header::after {
        transform: rotate(-90deg);
      }

      .demo-section.collapsed .demo-section-content {
        display: none;
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .empty-state {
        text-align: center;
        color: #6c757d;
        padding: 100px 20px;
        font-size: 1.1em;
      }

      .empty-state h2 {
        color: #1565c0;
        margin-bottom: 15px;
      }

      .protocol-placeholder {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 300px;
        padding: 20px;
      }

      .protocol-frame {
        border: 2px solid #e9ecef;
        border-radius: 8px;
        padding: 40px 30px;
        text-align: center;
        background: #f8f9fa;
        width: 100%;
        max-width: 400px;
      }

      .placeholder-text {
        font-size: 1.1em;
        font-weight: 600;
        color: #6c757d;
        margin-bottom: 10px;
      }

      .placeholder-subtitle {
        font-size: 0.9em;
        color: #8d9499;
        line-height: 1.4;
      }

      .timer-active {
        opacity: 1;
        background: linear-gradient(135deg, #007bff, #0056b3);
      }

      .timer-alert {
        animation: flashRed 1s infinite;
      }

      @keyframes flashRed {
        0%,
        50% {
          background: linear-gradient(135deg, #dc3545, #c82333);
        }
        51%,
        100% {
          background: linear-gradient(135deg, #007bff, #0056b3);
        }
      }

      .container {
        display: grid;
        grid-template-columns: 1fr 200px 1fr 300px;
        gap: 15px;
        align-items: start; 
      }

      .panel-box {
        background: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 20px;
      }

      .messaging-section textarea.message-input {
        width: 100%;
        resize: none;
        padding: 8px;
        font-size: 14px;
        font-family: "Rubik", sans-serif;
        line-height: 1.4;
        border-radius: 6px;
        border: 1px solid #90caf9;
        background-color: #fff;
        box-sizing: border-box;
        height: 48px; 
        outline: none;
      }

      .messaging-section textarea.message-input:focus {
        border-color: #1565c0;
        box-shadow: 0 0 0 2px rgba(21, 101, 192, 0.2);
      }

      .char-counter {
        font-size: 12px;
        color: #666;
        margin-top: 4px;
        margin-bottom: 8px;
        font-family: "Rubik", sans-serif;
      }

      .message-history {
        margin-top: 20px;
      }

      .message-history h4 {
        font-size: 16px;
        color: #1565c0;
        margin-bottom: 10px;
        font-family: "Rubik", sans-serif;
      }

      .message-list {
        list-style: none;
        padding-left: 0;
        max-height: 160px;
        overflow-y: auto;
        border: 1px solid #90caf9;
        border-radius: 6px;
        padding: 8px;
        background: #f9f9f9;
      }

      .message-list li {
        font-size: 14px;
        margin-bottom: 8px;
        line-height: 1.3;
        white-space: pre-line;
        font-family: "Rubik", sans-serif;
      }

      .message-list li.unread {
        font-weight: bold;
      }

      /* 🔒 Style for fully disabled protocol steps after resolution */
      .disabled-step {
        opacity: 0.5;
        pointer-events: none;
        background-color: #f1f1f1;
      }

      .disabled-step button,
      .disabled-step textarea,
      .disabled-step select {
        cursor: not-allowed;
      }

      #globalTimer {
        opacity: 1 !important;
        background: linear-gradient(135deg, #007bff, #0056b3) !important;
        color: white; /* Ensures text inside shows up */
      }

      #timerDisplay {
        color: white;
        font-size: 2em;
        display: block;
        visibility: visible;
        font-family: "Courier New", monospace;
        font-weight: bold;
        margin: 8px 0;
      }

      #timerInfo {
        color: white;
        font-size: 0.8em;
        line-height: 1.3;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 8px;
        margin: 8px 0;
        display: block;
        visibility: visible;
      }

      .middle-column-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        height: calc(100vh - 120px);
        overflow-y: auto;
        padding: 10px 0;
      }

      .global-timer {
        position: static !important;
        flex-shrink: 0;
      }

      .messaging-section {
        flex: 1;
        min-height: 200px;
      }

      .log-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        padding-bottom: 4px;
        border-bottom: 1px solid #e9ecef;
      }

      .log-timestamp {
        font-weight: bold;
        color: #495057;
        font-family: "Courier New", monospace;
      }

      .log-operator {
        font-size: 0.8em;
        color: #6c757d;
        font-weight: 500;
      }

      .log-source {
        color: #1565c0;
        font-size: 0.85em;
      }

      .log-date {
        font-size: 0.8em;
        color: #6c757d;
        font-family: "Courier New", monospace;
      }

      .log-content {
        color: #333;
        line-height: 1.5;
      }

      /* Specialized Log Content Styles */
      .dispatch-summary {
        font-weight: bold;
        color: #dc3545;
        margin-bottom: 8px;
        padding: 4px 0;
      }

      .location-info,
      .coordinates,
      .device-status,
      .device-stats,
      .dispatch-detail {
        margin: 4px 0;
        padding: 2px 0;
        font-size: 0.85em;
      }

      .gas-reading-detail {
        background: #f8f9fa;
        padding: 4px 8px;
        border-radius: 3px;
        margin-top: 4px;
        font-family: "Courier New", monospace;
        font-size: 0.8em;
      }

      .timer-action {
        color: #fd7e14;
        font-weight: 500;
      }

      .step-action {
        color: #007bff;
      }

      /* Log Type Colors - Update existing ones */
      .log-entry.step {
        border-left-color: #007bff;
      }
      .log-entry.timer {
        border-left-color: #ffc107;
      }
      .log-entry.resolution {
        border-left-color: #dc3545;
      }
      .log-entry.gas {
        border-left-color: #fd7e14;
      }
      .log-entry.system {
        border-left-color: #6c757d;
      }

      /* Override Modal Styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        z-index: 2000;
      }

      .override-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border: 3px solid #dc3545;
        border-radius: 10px;
        padding: 30px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        z-index: 2001;
        max-width: 500px;
        display: none;
      }

      .override-modal h3 {
        color: #dc3545;
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.2em;
      }

      .override-modal .gas-reading-display {
        background: #f8d7da;
        border: 1px solid #f5c6cb;
        border-radius: 4px;
        padding: 12px;
        margin: 15px 0;
        color: #721c24;
        font-weight: bold;
        text-align: center;
      }

      .override-modal select {
        width: 100%;
        padding: 10px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.9em;
      }

      .override-modal .modal-buttons {
        display: flex;
        gap: 10px;
        margin-top: 20px;
        justify-content: flex-end;
      }

      .override-modal .btn {
        padding: 10px 20px;
        font-size: 0.9em;
      }

      .status-badge.active {
        background: #007bff;
        color: white;
        animation: pulse 1.5s infinite;
      }

      .status-badge.waiting {
        background: #ffc107;
        color: #000;
      }

      .status-badge.skipped {
        background: #6c757d;
        color: white;
      }

      /* Pulsing animation for active state */
      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.4);
        }
        70% {
          box-shadow: 0 0 0 6px rgba(0, 123, 255, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0);
        }
      }

      .step.dispatch-step {
        opacity: 1 !important;
      }

      #protocolLog .log-entry {
        white-space: pre-line;
      }

      /* Keep label + value together on the left; pill on the right */
      .gas-reading {
        display: flex;
        align-items: center;
        justify-content: flex-start; /* was space-between */
      }

      .gas-reading .gas-status {
        margin-left: auto; /* pushes pill to the right edge */
      }

      /* Consistent small gap after the colon; align digits neatly */
      .gas-reading .gas-value {
        display: inline-block;
        margin-left: 0.25rem;
        font-variant-numeric: tabular-nums;
        min-width: 7ch;
        text-align: right;
      }

      .offline-option {
        color: #dc3545 !important;
        font-weight: bold !important;
        background-color: #fff5f5 !important;
      }

      .offline-dropdown {
        border: 2px solid #dc3545 !important;
        background-color: #fff5f5 !important;
      }

      /* ═══════════════════════════════════════════════════════════════════════════════
   PRE-ALERT STYLING
   ═══════════════════════════════════════════════════════════════════════════════ */

      /* Disabled button styling for pre-alert condition */
      .disabled-pre-alert {
        opacity: 0.4 !important;
        cursor: not-allowed !important;
        pointer-events: none !important;
      }

      /* Disabled step container styling */
      .step-disabled-pre-alert {
        opacity: 0.6 !important;
        position: relative;
      }

      /* Pre-alert resolution section highlighting */
      [data-cy="resolution-section-pre-alert"] {
        border: 2px solid #ffc107 !important;
        background: rgba(255, 193, 7, 0.05) !important;
      }

      /* Animation for pre-alert resolution attention */
      @keyframes preAlertPulse {
        0%,
        100% {
          border-color: #ffc107;
          box-shadow: 0 2px 8px rgba(255, 193, 7, 0.3);
        }
        50% {
          border-color: #ff9800;
          box-shadow: 0 4px 16px rgba(255, 152, 0, 0.5);
        }
      }

      /* System log entries for pre-alert */
      .log-entry.system {
        border-left-color: #6c757d;
      }

      /* Ensure resolution controls remain functional in pre-alert mode */
      .resolution-section .btn-danger:not(.disabled-pre-alert),
      .resolution-section select:not(.disabled-pre-alert) {
        opacity: 1 !important;
        pointer-events: auto !important;
      }

      /* ADD THESE NEW CLASSES ONLY */
.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.connectivity-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px 16px;
  margin-bottom: 16px;
}

.connectivity-item-full {
  grid-column: 1 / -1;
}

.connectivity-item {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.connectivity-label {
  font-size: 0.8em;
  color: #6c757d;
  font-weight: 500;
}

/* Online/Offline color coding */
.connectivity-value.online {
  color: #28a745; /* Green - device online */
  font-weight: bold;
}

.connectivity-value.offline {
  color: #dc3545; /* Red - device offline */
  font-weight: bold;
}

.section-separator {
  height: 1px;
  background: linear-gradient(90deg, transparent, #dee2e6, transparent);
  margin: 16px 0;
}

.location-header {
  font-size: 0.9em;
  color: #495057;
  font-weight: 600;
  margin: 0 0 12px 0;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.location-section .connectivity-item {
  margin-bottom: 8px;
}

.location-section .connectivity-item:last-child {
  margin-bottom: 0;
}

/* Enhanced status pill - OVERWRITES existing */
.status-pill {
  padding: 6px 12px;
  border-radius: 16px;
  font-size: 0.85em;
  font-weight: bold;
  text-transform: uppercase;
}

.status-pill.online {
  background: linear-gradient(135deg, #28a745, #20c997);
  color: white;
}

.status-pill.offline {
  background: linear-gradient(135deg, #dc3545, #c82333);
  color: white;
}

/* Panel health indicators */
.connectivity-panel.warning {
  border-color: #ffc107;
}

.connectivity-panel.critical {
  border-color: #dc3545;
}

/* Responsive */
@media (max-width: 768px) {
  .connectivity-grid {
    grid-template-columns: 1fr;
    gap: 8px;
  }
  
  .panel-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
  }
}
.gas-status.depletion,
.gas-status.enrichment {
    background-color: #dc3545;
    color: white;
    border: 1px solid #dc3545;
}
    </style>
  </head>
  <body>
    <!-- Demo Controls -->
<div class="demo-gear" id="demo-gear" data-cy="demo-gear" onclick="toggleDemoPanel()"></div>
<div class="demo-panel" id="demo-panel" data-cy="demo-panel">
  <div class="demo-section" id="gas-section">
    <h4
      class="demo-section-header"
      onclick="toggleDemoSection('gas-section')"
    >
      Gas Alert Tests
    </h4>
    <div class="demo-section-content">
      <div class="demo-button-grid">
        <button
          class="btn btn-primary"
          onclick="loadAlert('h2s-response')"
          data-cy="h2s-override-test-btn"
          title="H₂S High - User confirms OK despite gas"
        >
          H₂S Override Test
        </button>
        <button
          class="btn btn-primary"
          onclick="loadAlert('co-spontaneous')"
          data-cy="co-normalization-test-btn"
          title="CO High - Gas normalizes after message"
        >
          CO Gas Normalization
        </button>
        <button
          class="btn btn-primary"
          onclick="loadAlert('gas-high-threshold')"
          data-cy="h2s-standard-flow-btn"
          title="H₂S High - Standard flow"
        >
          H₂S Standard Flow
        </button>
        <button
          class="btn btn-primary"
          onclick="loadAlert('o2-depletion-resolves')"
          data-cy="o2-depletion-test-btn"
          title="O₂ Depletion - Gas normalizes at 1min, auto-resolves after 2min"
        >
          O₂ Depletion Test
        </button>
        <button
          class="btn btn-primary"
          onclick="loadAlert('o2-enrichment-escalates')"
          data-cy="o2-enrichment-test-btn"
          title="O₂ Enrichment - Escalates to protocol steps after 2min"
        >
          O₂ Enrichment Test
        </button>
      </div>
    </div>
  </div>

  <div class="demo-section" id="nongas-section">
    <h4
      class="demo-section-header"
      onclick="toggleDemoSection('nongas-section')"
    >
      Non-Gas Tests
    </h4>
    <div class="demo-section-content">
      <div class="demo-button-grid">
        <button
          class="btn btn-primary"
          onclick="loadAlert('sos-immediate')"
          data-cy="sos-test-btn"
          title="SOS Alert"
        >
          SOS - Dispatch YES
        </button>
        <button
          class="btn btn-primary"
          onclick="loadAlert('fall-detection')"
          data-cy="fall-detection-test-btn"
          title="Fall Detection Protocol"
        >
          Fall - Protocol Cycle
        </button>
        <button
          class="btn btn-primary"
          onclick="loadAlert('no-motion')"
          data-cy="no-motion-test-btn"
          title="No Motion Standard"
        >
          No Motion - Standard
        </button>
        <button
          class="btn btn-primary"
          onclick="loadAlert('missed-check-in')"
          data-cy="missed-check-in-online-btn"
          title="Missed Check-In - Device Online"
        >
          Missed Check-In (Online)
        </button>
        <button
          class="btn btn-primary"
          onclick="loadAlert('missed-check-in-offline')"
          data-cy="missed-check-in-offline-btn"
          title="Missed Check-In - Device Offline"
        >
          Missed Check-In (Offline)
        </button>
        <button
          class="btn btn-primary"
          onclick="loadAlert('pre-alert-test')"
          data-cy="pre-alert-test-btn"
          title="Pre-Alert Test - Alert >24 hours old"
        >
          Pre-Alert (25h old)
        </button>
      </div>
    </div>
  </div>

  <div class="demo-button-single">
    <button class="btn btn-secondary" onclick="clearAlert()" data-cy="clear-alert-btn">
      Clear Alert
    </button>
  </div>
</div>

    <!-- Alert Information Header -->
    <div class="header" id="alert-header" data-cy="alert-header">
      <h1 class="alert-title" id="alert-title" data-cy="alert-title">
        🚨 Alert Management
      </h1>

      <div class="alert-details">
        <div class="alert-info">
          <div class="info-item">
            <strong>Alert ID:</strong>
            <span id="alert-id" data-cy="alert-id">--</span>
          </div>
          <div class="info-item">
            <strong>Employee:</strong>
            <span id="employee-details" data-cy="employee-details">--</span>
          </div>
          <div class="info-item">
            <strong>Device:</strong>
            <span id="device-details" data-cy="device-details">--</span>
          </div>
          <div class="info-item">
            <strong>Mobile:</strong>
            <span id="mobile-number" data-cy="mobile-number">--</span>
          </div>
          <div class="info-item">
            <strong>Alert Time:</strong>
            <span id="alert-time" data-cy="alert-time">--</span>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <!-- Column 1: Protocol Log + Add Note -->
      <div
        class="left-column"
        style="grid-column: 1; display: flex; flex-direction: column; gap: 15px"
      >
        <!-- Protocol Log -->
        <div class="protocol-log panel-box">
          <h3>📋 Protocol Log</h3>
          <div
            class="log-container"
            id="protocolLog"
            data-cy="protocol-log-container"
          >
            <div class="log-placeholder">
              No alert loaded. Use demo controls to load an alert type and begin
              protocol.
            </div>
          </div>
        </div>

        <!-- Add Note -->
        <div class="panel-box">
          <h3>📝 Add Note</h3>
          <textarea
            id="manual-notes"
            data-cy="manual-notes"
            class="manual-notes"
            placeholder="Add notes here..."
          ></textarea>
          <button
            class="btn btn-success"
            style="margin-top: 10px"
            onclick="addManualNote()"
            data-cy="post-note-btn"
          >
            Post Note
          </button>
        </div>
      </div>

      <!-- Column 2: Global Timer + Messaging -->
      <div class="middle-column-container" style="grid-column: 2">
        <!-- Global Timer -->
        <div
          class="global-timer timer-inactive panel-box"
          id="globalTimer"
          data-cy="global-timer"
        >
          <h3>⏰ Timer</h3>
          <div class="timer-display" id="timerDisplay" data-cy="timer-display">
            --:--
          </div>
          <div class="timer-info" id="timerInfo" data-cy="timer-info">
            <strong>No active timer</strong>
          </div>
          <div class="timer-controls">
            <button
              class="cancel-btn"
              id="cancelTimerBtn"
              data-cy="cancel-timer-btn"
              disabled
              onclick="cancelGlobalTimer()"
            >
              🛑 Cancel Timer
            </button>
          </div>
        </div>

        <!-- Messaging UI -->
        <div class="messaging-section panel-box">
          <h3>📨 This device supports messaging</h3>
          <textarea
            id="manual-message-input"
            data-cy="message-input"
            class="message-input"
            rows="2"
            placeholder="Enter message (2 lines, 16 chars each)"
          ></textarea>
          <div class="char-counter" id="charCounter" data-cy="char-counter">
            16/16 characters remaining
          </div>
          <button
            class="btn btn-primary"
            id="sendMessageBtn"
            data-cy="send-message-btn"
            onclick="sendManualMessage()"
            disabled
          >
            📤 Send
          </button>
          <div class="message-history" id="messageHistory">
            <h4>📬 Messages from Device</h4>
            <ul
              class="message-list"
              id="receivedMessages"
              data-cy="received-messages"
            ></ul>
          </div>
        </div>
      </div>

      <!-- Column 3: Emergency Steps -->
<div class="steps-section panel-box" style="grid-column: 3">
  <h3>🚨 Emergency Response Protocol</h3>
  <div id="protocol-content" data-cy="protocol-content">
    <div class="protocol-placeholder">
      <div class="protocol-frame">
        <div class="placeholder-text">No protocol loaded</div>
        <div class="placeholder-subtitle">
          Alert type will load the relevant emergency response protocol
        </div>
      </div>
    </div>
  </div>
</div>



<!-- Column 4: Gas Readings -->
<div
  class="right-column"
  style="grid-column: 4; display: flex; flex-direction: column; gap: 15px"
>
  <!-- Gas Readings -->
  <div class="panel-box" id="gasReadingsCard" data-cy="gas-readings-card">
    <h3>🔎 Gas Readings (Live)</h3>
    <div class="triggered-by" id="triggeredBy" style="display: none">
      Alert Type: <span id="alert-trigger" data-cy="alert-trigger">--</span>
    </div>
    <div class="gas-reading" id="h2s-reading" data-cy="h2s-reading">
      <span
        >🟢 H₂S:
        <span class="gas-value" id="h2s-value" data-cy="h2s-value">1.20 ppm</span></span
      >
      <span class="gas-status normal" id="h2s-status" data-cy="h2s-status">NORMAL</span>
    </div>
    <div class="gas-reading" id="co-reading" data-cy="co-reading">
      <span
        >🟢 CO:
        <span class="gas-value" id="co-value" data-cy="co-value">2.50 ppm</span></span
      >
      <span class="gas-status normal" id="co-status" data-cy="co-status">NORMAL</span>
    </div>
    <div class="gas-reading" id="o2-reading" data-cy="o2-reading">
      <span
        >🟢 O₂:
        <span class="gas-value" id="o2-value" data-cy="o2-value">20.90 %vol</span></span
      >
      <span class="gas-status normal" id="o2-status" data-cy="o2-status">NORMAL</span>
    </div>
    <div class="gas-reading" id="lel-reading" data-cy="lel-reading">
      <span
        >🟢 LEL:
        <span class="gas-value" id="lel-value" data-cy="lel-value">0.50 %LEL</span></span
      >
      <span class="gas-status normal" id="lel-status" data-cy="lel-status">NORMAL</span>
    </div>
    <div class="last-updated" id="lastUpdated" style="display: none">
      Last updated: <span id="gas-timestamp" data-cy="gas-timestamp">--</span>
    </div>
  </div>

  <!-- Device Connectivity Panel -->
<div class="connectivity-panel" id="connectivityPanel" data-cy="connectivity-panel">
  <div class="panel-header">
    <h3>📡 Device Connectivity</h3>
    <span class="status-pill online" id="device-online-status" data-cy="device-status">🟢 ONLINE</span>
  </div>
  
  <div class="connectivity-grid">
    <div class="connectivity-item">
      <span class="connectivity-label">Battery Level:</span>
      <span class="connectivity-value" id="battery-level" data-cy="battery-level">85%</span>
    </div>
    
    <div class="connectivity-item">
      <span class="connectivity-label">Signal Strength:</span>
      <span class="connectivity-value" id="signal-strength" data-cy="signal-strength">70%</span>
    </div>
    
    <div class="connectivity-item connectivity-item-full">
      <span class="connectivity-label">Last Comm:</span>
      <span class="connectivity-value" id="last-comm-time" data-cy="last-comm-time">Aug 02, 2025 at 17:11 MDT</span>
    </div>
  </div>

  <div class="section-separator"></div>
  
  <div class="location-section">
    <h4 class="location-header">📍 LOCATION DETAILS</h4>

    <div class="connectivity-item">
      <span class="connectivity-label">Last Location:</span>
      <span class="connectivity-value" id="location-timestamp" data-cy="location-timestamp">Aug 02, 2025 at 15:28 MDT</span>
    </div>

    <div class="connectivity-item">
      <span class="connectivity-label">Approximate Address:</span>
      <span class="connectivity-value" id="device-location" data-cy="device-location">144252 434 Ave E, Aldersyde, AB</span>
    </div>

    <div class="connectivity-item">
      <span class="connectivity-label">GPS Coord:</span>
      <span class="connectivity-value" id="device-coordinates" data-cy="device-coordinates">Latitude 50.660040, Longitude -113.768577</span>
    </div>

    <div class="connectivity-item">
      <span class="connectivity-label">Speed:</span>
      <span class="connectivity-value" id="device-speed" data-cy="device-speed">0.0 km/h</span>
    </div>
  </div>
</div>
</div>

    <!-- Gas Override Modal -->
<div class="modal-overlay" id="modalOverlay" data-cy="override-modal-overlay"></div>
<div class="override-modal" id="overrideModal" data-cy="override-modal">
  <h3>Gas levels are still elevated</h3>
  <p>Are you sure you want to resolve this alert?</p>
  <div class="gas-reading-display" id="overrideGasReading" data-cy="override-gas-reading">
    Current Gas Reading: H₂S: 17.90 ppm (HIGH)
  </div>
  <label for="override-reason">
    <strong>Please confirm the reason for override:</strong>
  </label>
  <select id="override-reason" data-cy="override-reason">
    <option value="">-- Select override reason --</option>
    <option value="sensor-error">Sensor error</option>
    <option value="user-confirmed-safety">User confirmed they are okay</option>
    <option value="ec-confirmed-safety">Emergency contact confirmed user is okay</option>
    <option value="bump-test">Bump Test/Calibration in progress</option>
    <option value="other">Other</option>
  </select>
  <div class="modal-buttons">
    <button
      class="btn btn-danger"
      id="confirmOverrideBtn"
      data-cy="confirm-override"
      disabled
      onclick="confirmOverride()"
    >
      Resolve Alert
    </button>
    <button 
      class="btn btn-secondary" 
      data-cy="cancel-override"
      onclick="cancelOverride()"
    >
      Cancel
    </button>
  </div>
</div>
    <script>
      // ═══════════════════════════════════════════════════════════════
      // 📊 GLOBAL STATE & DATA
      // ═══════════════════════════════════════════════════════════════

      // ── Centralized timezones ───────────────────────────────
      const TIMEZONES = {
        MOUNTAIN: "America/Denver", // Matches your current logs (MDT)
        EASTERN: "America/Toronto",
      };

      // ── Centralized formatters ──────────────────────────────
      const FORMATTERS = {
        // Full timestamp [YYYY-MM-DD HH:mm:ss MDT]
        timestampMST: (date) => {
          return (
            new Intl.DateTimeFormat("en-US", {
              timeZone: TIMEZONES.MOUNTAIN,
              year: "numeric",
              month: "2-digit",
              day: "2-digit",
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
              hour12: false,
            }).format(date) + " MDT"
          );
        },

        // Time only [HH:mm:ss MDT]
        timeOnlyMST: (date) => {
          return (
            new Intl.DateTimeFormat("en-US", {
              timeZone: TIMEZONES.MOUNTAIN,
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
              hour12: false,
            }).format(date) + " MDT"
          );
        },
      };

      // ═══════════════════════════════════════════════════════════════════════════════
      // PRE-ALERT DETECTION SYSTEM
      // ═══════════════════════════════════════════════════════════════════════════════

      const PRE_ALERT_THRESHOLD = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

      /**
       * Comprehensive pre-alert detection with data integrity validation
       * Only runs at alert initialization - not during runtime
       */
       function isPreAlert(alertData) {
    try {
        if (!alertData) {
            return false;
        }

        // Method 1: Check for explicit alertAge field (for test scenarios)
        if (alertData.alertAge && typeof alertData.alertAge === 'number') {
            const ageHours = alertData.alertAge;
            const isOld = ageHours > 24;
            
            // Only log if it's actually a pre-alert
            if (isOld) {
                addLogEntry(
                    `[PreAlert] Alert age validation: ${ageHours}h old, threshold: 24h, isPreAlert: true`,
                    "system"
                );
            }
            return isOld;
        }

        // Method 2: Check deviceConditions for alertTriggeredTime
        if (alertData.deviceConditions?.alertTriggeredTime) {
            const alertDate = new Date(alertData.deviceConditions.alertTriggeredTime);
            if (!isNaN(alertDate.getTime())) {
                const now = new Date();
                const ageMs = now.getTime() - alertDate.getTime();
                const ageHours = Math.round(ageMs / (1000 * 60 * 60));
                const isOld = ageMs > PRE_ALERT_THRESHOLD;

                // Only log if it's actually a pre-alert
                if (isOld) {
                    addLogEntry(
                        `[PreAlert] Alert age validation: ${ageHours}h old, threshold: 24h, isPreAlert: true`,
                        "system"
                    );
                }
                return isOld;
            }
        }

        // Method 3: Try standard date fields (fallback for other alert formats)
        const dateField =
            alertData.alert_date ||
            alertData.alertDate ||
            alertData.date ||
            alertData.timestamp ||
            alertData.createdAt;
            
        if (dateField) {
            const alertDate = new Date(dateField);
            if (!isNaN(alertDate.getTime())) {
                const now = new Date();
                
                // Data integrity check - reject future dates
                if (alertDate > now) {
                    addLogEntry(
                        `[PreAlert] Data integrity error - alert date is in the future: ${alertDate.toISOString()}`,
                        "system"
                    );
                    return false;
                }

                const ageMs = now.getTime() - alertDate.getTime();
                const ageHours = Math.round(ageMs / (1000 * 60 * 60));
                const isOld = ageMs > PRE_ALERT_THRESHOLD;

                // Only log if it's actually a pre-alert
                if (isOld) {
                    addLogEntry(
                        `[PreAlert] Alert age validation: ${ageHours}h old, threshold: 24h, isPreAlert: true`,
                        "system"
                    );
                }
                return isOld;
            }
        }

        // No date information found - silently assume current alert
        return false;

    } catch (error) {
        addLogEntry(`[PreAlert] Detection error: ${error.message}`, "system");
        return false;
    }
}

      // Data Management System
      class AlertDataManager {
        static usersData = {
          "zach-sowell": {
            id: "373595",
            name: "Zach Sowell",
            device: "G7x-3571031421",
            mobile: "+1 470-505-6195",
            company: "WM - Corporate",
            work: "+1 470-505-6195",
            home: "+1 208-995-4975",
            emergencyContacts: [
              {
                name: "Daniel Reyes",
                phone: "+1-587-333-9271",
                role: "Site Supervisor",
              },
              {
                name: "Vanessa Liu",
                phone: "+1-780-452-1189",
                role: "Control Room Operator",
              },
            ],
          },
          "marcus-rodriguez": {
            id: "428756",
            name: "Marcus Rodriguez",
            device: "G7x-2947182653",
            mobile: "+1 403-555-0167",
            company: "Enbridge Pipelines",
            work: "+1 403-555-0167",
            home: "+1 403-555-0168",
            emergencyContacts: [
              {
                name: "Mike Chen",
                phone: "+1-403-555-0123",
                role: "Site Supervisor",
              },
              {
                name: "Sarah Kim",
                phone: "+1-403-555-0124",
                role: "Safety Coordinator",
              },
            ],
          },
          "test-user": {
            id: "TEST001",
            name: "Test User",
            device: "G7x-12345",
            mobile: "+1-555-0123",
            company: "Demo Company",
            work: "+1-555-0124",
            home: "+1-555-0125",
            emergencyContacts: [
              {
                name: "Emergency Contact",
                phone: "+1-555-0456",
                role: "Primary Contact",
              },
            ],
          },
        };

        static alertTypesData = {
          "h2s-spontaneous": {
            id: "h2s-spontaneous",
            displayName:
              "High threshold detected (H₂S) - Spontaneous - No Dispatch",
            user: "zach-sowell",
            deviceType: "G7c",
            protocolFile: "gas-emergency-protocol",
            gasType: "h2s-high",
            testType: "spontaneous",
            gasNormalization: { enabled: false },
            deviceConditions: {
              lastComm: 5,
              battery: 85,
              signal: 70,
              locationAge: 4320, // 3 days old (BAD - stale location)
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
          },
          "h2s-response": {
            id: "h2s-response",
            displayName:
              "High threshold detected (H₂S) - Response - No Dispatch",
            user: "zach-sowell",
            deviceType: "G7c",
            protocolFile: "gas-emergency-protocol",
            gasType: "h2s-high",
            testType: "response",
            gasNormalization: { enabled: false },
            deviceConditions: {
              lastComm: 5,
              battery: 85,
              signal: 70,
              locationAge: 2,
              deviceSpeed: 95, // 95 km/h (BAD - moving too fast)
              deviceStatus: "Online",
            },
          },
          "co-spontaneous": {
            id: "co-spontaneous",
            displayName: "High threshold detected (CO) - Dispatch",
            user: "marcus-rodriguez",
            deviceType: "G7x",
            protocolFile: "gas-emergency-protocol",
            gasType: "co-high",
            testType: "spontaneous",
            deviceConditions: {
              lastComm: 3,
              battery: 78,
              signal: 85,
              locationAge: 1,
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
            gasNormalization: {
              enabled: true,
              triggerAfterStep: "step-1", // Trigger after Step 1 completes
              targetLevels: {
                co: {
                  value: 0.5,
                  status: "NORMAL",
                },
              },
            },
          },
          // O₂ Test Alerts for 2-Minute Monitoring
          "o2-depletion-resolves": {
            id: "o2-depletion-resolves",
            displayName: "O₂ Depletion - Auto-Resolution Demo",
            user: "zach-sowell",
            deviceType: "G7x",
            protocolFile: "gas-monitoring-protocol",
            gasType: "o2-low",
            testType: "monitoring",
            requiresMonitoring: true,
            monitoringDuration: 120,
            deviceConditions: {
              lastComm: 2,
              battery: 90,
              signal: 85,
              locationAge: 1,
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
            gasNormalization: {
              enabled: true,
              triggerAfterStep: "monitoring-start",
              delay: 60000, // 1 minute - normalizes quickly
              targetLevels: {
                o2: {
                  value: 20.9,
                  status: "NORMAL",
                },
              },
            },
          },
          "o2-enrichment-escalates": {
            id: "o2-enrichment-escalates",
            displayName: "O₂ Enrichment - Escalation Demo",
            user: "marcus-rodriguez",
            deviceType: "G7c",
            protocolFile: "gas-monitoring-protocol",
            gasType: "o2-high",
            testType: "monitoring",
            requiresMonitoring: true,
            monitoringDuration: 120,
            deviceConditions: {
              lastComm: 3,
              battery: 85,
              signal: 75,
              locationAge: 2,
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
            gasNormalization: { enabled: false }, // Stays dangerous
          },
          "fall-spontaneous": {
            id: "fall-spontaneous",
            displayName: "Fall detection - Spontaneous - No Dispatch",
            user: "marcus-rodriguez",
            deviceType: "G7x",
            protocolFile: "fall-detection-protocol",
            gasType: "default",
            testType: "spontaneous",
            deviceConditions: {
              lastComm: 1, // 1 minute ago (GOOD - online)
              battery: 85, // 85% (GOOD - high battery)
              signal: 70, // 70% (GOOD - strong signal)
              locationAge: 2880, // 2 days old (BAD - stale location)
              deviceSpeed: 0.0, // Stationary (GOOD)
              deviceStatus: "Online",
            },
          },
          "fall-detection": {
            id: "fall-detection",
            displayName: "Fall detection detected - Dispatch",
            user: "marcus-rodriguez",
            deviceType: "G7c",
            protocolFile: "fall-detection-protocol",
            gasType: "default",
            testType: "legacy",
            deviceConditions: {
              lastComm: 1,
              battery: 92,
              signal: 95,
              locationAge: 0.5,
              deviceSpeed: 2.1,
              deviceStatus: "Online",
            },
          },
          "sos-immediate": {
            id: "sos-immediate",
            displayName: "SOS alert - Immediate Help - Dispatch",
            user: "zach-sowell",
            deviceType: "G7x",
            protocolFile: "sos-protocol",
            gasType: "default",
            testType: "immediate-help",
            deviceConditions: {
              lastComm: 2,
              battery: 95,
              signal: 98,
              locationAge: 1,
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
          },
          "no-motion": {
            id: "no-motion",
            displayName: "No motion detected - No Dispatch",
            user: "marcus-rodriguez",
            deviceType: "G7c",
            protocolFile: "no-motion-protocol",
            gasType: "default",
            testType: "legacy",
            deviceConditions: {
              lastComm: 8,
              battery: 25,
              signal: 45,
              locationAge: 180, // 3 hours old (BAD - stale location)
              deviceSpeed: 0.0,
              deviceStatus: "Online",
            },
          },
          "gas-high-threshold": {
            id: "gas-high-threshold",
            displayName: "High threshold detected (H₂S) - Dispatch",
            user: "zach-sowell",
            deviceType: "G7c",
            protocolFile: "gas-emergency-protocol",
            gasType: "h2s-high",
            testType: "legacy",
            deviceConditions: {
              lastComm: 4,
              battery: 88,
              signal: 82,
              locationAge: 2,
              deviceSpeed: 1.2,
              deviceStatus: "Online",
            },
          },
          "message-test": {
            id: "message-test",
            displayName: "Device Message Test - Dispatch",
            user: "marcus-rodriguez",
            deviceType: "G7x",
            protocolFile: "no-motion-protocol",
            gasType: "default",
            testType: "response",
            deviceConditions: {
              lastComm: 1,
              battery: 75,
              signal: 88,
              locationAge: 3,
              deviceSpeed: 0.5,
              deviceStatus: "Online",
            },
          },
          "missed-check-in": {
            id: "missed-check-in",
            displayName: "Missed check-in - Device Online",
            user: "zach-sowell",
            deviceType: "G7x",
            protocolFile: "missed-check-in-protocol",
            gasType: "default",
            testType: "response",
            deviceConditions: {
              lastComm: 12,
              battery: 35,
              signal: 22,
              locationAge: 3,
              deviceSpeed: 95.7,
              deviceStatus: "Online",
              lastCheckInTime: new Date(Date.now() - 135 * 60 * 1000),
              checkInReminderTime: new Date(Date.now() - 15 * 60 * 1000),
              alertTriggeredTime: new Date(),
              checkInInterval: 120,
              pendingInterval: 15,
            },
          },
          "missed-check-in-offline": {
            id: "missed-check-in-offline",
            displayName: "Missed check-in - Device Offline",
            user: "marcus-rodriguez",
            deviceType: "G7x",
            protocolFile: "missed-check-in-protocol",
            gasType: "default",
            testType: "response",
            deviceConditions: {
              lastComm: 47, // OFFLINE - exceeds 30 min
              battery: 8, // OFFLINE - below 10%
              signal: 3, // OFFLINE - below 10%
              locationAge: 52, // STALE
              deviceSpeed: 0,
              deviceStatus: "Offline",
              lastCheckInTime: new Date(Date.now() - 135 * 60 * 1000),
              checkInReminderTime: new Date(Date.now() - 15 * 60 * 1000),
              alertTriggeredTime: new Date(),
              checkInInterval: 120,
              pendingInterval: 15,
            },
          },
          "pre-alert-test": {
            id: "pre-alert-test",
            displayName: "PRE-ALERT: Fall Detection - 25 Hours Old",
            user: "test-user",
            deviceType: "G7x",
            protocolFile: "pre-alert-protocol",
            gasType: "default",
            testType: "pre-alert",
            alert_date: new Date(
              Date.now() - 25 * 60 * 60 * 1000
            ).toISOString(), // 25 hours ago
            alertDate: new Date(Date.now() - 25 * 60 * 60 * 1000).toISOString(), // fallback field
            deviceConditions: {
              lastComm: 25 * 60, // 25 hours ago in minutes (OFFLINE)
              battery: 15, // Low battery
              signal: 8, // Poor signal
              locationAge: 25 * 60, // 25 hours old location (STALE)
              deviceSpeed: 0.0,
              deviceStatus: "Offline",
            },
            isPreAlert: true, // Explicit flag for testing
          },
        };
      }

      /**
       * Generate standardized pre-alert log message using existing formatters
       */
      function createPreAlertLogMessage(alertData) {
        const alertDate = new Date(
          alertData.alert_date || alertData.alertDate || alertData.date
        );
        const hoursAgo = Math.floor(
          (Date.now() - alertDate.getTime()) / (1000 * 60 * 60)
        );

        // Use existing FORMATTERS for consistency with rest of system
        const formattedDate =
          typeof FORMATTERS?.timestampMST === "function"
            ? FORMATTERS.timestampMST(alertDate)
            : alertDate.toLocaleString("en-US", {
                timeZone: "America/Denver",
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                hour12: false,
              }) + " MDT";

        return `Pre-alert - alert triggered ${hoursAgo} hours ago. Resolving as per Blackline Safety policy.`;
      }

      // Add pre-alert log entry using the existing logging system
      function addPreAlertLogEntry(alertData) {
        const logMessage = createPreAlertLogMessage(alertData);
        addLogEntry(logMessage, "system");
      }

      // Setup pre-alert resolution (auto-select and highlight)
      function setupPreAlertResolution() {
        console.log("[PreAlert] Setting up resolution for pre-alert");

        const resolutionSelect = document.getElementById("resolution-reason");
        if (resolutionSelect) {
          // Auto-select pre-alert resolution type
          resolutionSelect.value = "pre-alert";

          // Mark current alert as pre-alert
          if (window.currentAlert) {
            window.currentAlert.isPreAlert = true;
          }
          if (typeof currentAlert !== "undefined" && currentAlert) {
            currentAlert.isPreAlert = true;
          }

          console.log('[PreAlert] Auto-selected "pre-alert" resolution reason');
        }

        // Use existing lockUIForResolution function if available
        if (typeof lockUIForResolution === "function") {
          lockUIForResolution();
          console.log("[PreAlert] Used existing lockUIForResolution function");
        }

        // Mark all steps as completed
        const allSteps = document.querySelectorAll('[id^="step-"]');
        allSteps.forEach((step) => {
          const statusBadge = step.querySelector(".status-badge");
          if (statusBadge) {
            statusBadge.textContent = "Completed";
            statusBadge.className = "status-badge completed";
            statusBadge.style.background = "#28a745";
            statusBadge.style.color = "white";
          }

          step.classList.add("completed");
          step.classList.remove("active");
        });

        // Subtle highlight for resolution section
        const resolutionSection =
          document.querySelector(".resolution-section") ||
          document.getElementById("resolution-section");
        if (resolutionSection) {
          resolutionSection.style.border = "2px solid #ffc107";
          resolutionSection.setAttribute(
            "data-cy",
            "resolution-section-pre-alert"
          );

          // Re-enable resolution controls after locking
          const resolveButton = resolutionSection.querySelector(".btn-danger");
          const resolutionDropdown = resolutionSection.querySelector("select");

          if (resolveButton) {
            resolveButton.disabled = false;
            resolveButton.style.opacity = "1";
          }
          if (resolutionDropdown) {
            resolutionDropdown.disabled = false;
            resolutionDropdown.style.opacity = "1";
          }

          console.log(
            "[PreAlert] Highlighted resolution section and enabled controls"
          );
        }
      }

      // Global state variables
      let currentAlert = null;
      let currentUser = null;
      let gasUpdateInterval = null;
      let dispatchMade = false;
      window.setDispatchMade = function() {
  dispatchMade = true;
  console.log("dispatchMade set to:", dispatchMade);
};
      let globalTimerInterval = null;
      let activeTimerData = null;
      let globalTimerEndTime = null;
      let tabFlashInterval = null;
      let localTimerInterval = null;
      let beepTimeouts = [];
      let originalTitle = "Enhanced Blackline Live - Alert Management";

      let alertStartTime = null;
      let alertTimeUpdateInterval = null;


      // Context tracking variables
      let lastPromptSent = null;
      let promptTimestamp = null;
      let messageTimer = null;
      let awaitingResponse = false;

      // SOS Protocol definitions
      const SOS_PROTOCOL_STEPS = {
        1: "Message device",
        2: "Call user",
        3: "Dispatch",
        4: "Call emergency contacts",
      };

      // Protocol state management
      let protocolState = {
        completedSteps: [],
        currentStep: 1,
        dispatchMade: false,
        alertResolved: false,
        deviceMessageReceived: false,
        currentProtocol: null,
        currentSOSStep: 1,
      };

      //
// ═══════════════════════════════════════════════════════════════════════════════
// GARBLED MESSAGE DETECTION SYSTEM - INTEGRATED VERSION
// ═══════════════════════════════════════════════════════════════════════════════
//

// Move constants to global scope for access by classification functions
const GARBLE_DETECT = {
  NON_ASCII: /[^\x20-\x7E]/,        // outside printable ASCII
  REPLACEMENT: /\uFFFD/,            // replacement glyph
  DISALLOWED_ASCII: /[^A-Za-z0-9\s.,!?'"-]/ // only allow letters, digits, space, . , ! ? ' " -
};

// Conservative token allow-list for device messages
const SAFE_TOKENS = new Set([
  // confirmations
  'ok','okay','fine','safe','confirm','confirmed','confirming',
  'yes','no','im','i','am','i\'m','im','imokay','imok',
  
  // help/sos  
  'help','send','need','emergency','sos','urgent','assist','assistance',
  
  // status/condition words
  'hurt','injured','stuck','trapped','lost','fallen','down','bleeding',
  'unconscious','breathing','awake','responsive',
  
  // protocol words / instructions
  'leave','area','understood','message','call','back','will','minutes','minute',
  'check','callback','ec','contact','phone','device','radio',
  
  // location/movement
  'here','there','location','moving','stopped','stationary','vehicle','equipment',
  'building','outside','inside','room','office','site','field',
  
  // gas/hazard specific
  'gas','leak','spill','smoke','fire','explosion','chemical','toxic','smell',
  'evacuate','evacuated','clear','cleared','detector','alarm','warning',
  
  // time references
  'now','soon','minutes','hours','later','done','finished','complete','over',
  
  // issues/problems
  'issue','problem','resolved','fixed','false','alarm','malfunction','error',
  'working','broken','dead','low','battery','signal',
  
  // common misspellings and abbreviations
  'halp','hlep','cant','wont','dont','isnt','wasnt','ur','u','r','thx','ty',
  
  // politeness/communication
  'thanks','thank','you','received','got','heard','copy','roger','10-4',
  
  // basic grammar words
  'the','to','on','and','in','of','for','with','at','but','or','not','all',
  'my','me','we','us','our','this','that','these','those','here','there'
]);

// Normalize token (lowercase; strip simple punctuation at ends)
const normalizeToken = (s) => (s || '').toLowerCase().replace(/^[^\w]+|[^\w]+$/g, '');

// Extract word-like tokens (letters/digits); ignore empty bits  
const tokenizeMessage = (text) => (String(text).match(/[A-Za-z0-9']+/g) || [])
  .map(normalizeToken)
  .filter(Boolean);

/**
 * Check if message contains unknown/suspicious words indicating garbling
 */
function hasUnknownWord(text) {
  const tokens = tokenizeMessage(text);
  
  for (const token of tokens) {
    // Skip very short tokens and pure numbers
    if (token.length <= 2 || /^\d+$/.test(token)) continue;
    
    // Check against safe token list
    if (!SAFE_TOKENS.has(token)) {
      // Additional validation for common English patterns
      if (isLikelyValidWord(token)) continue;
      
      console.log(`🚨 Unknown/suspicious word detected: "${token}" in message: "${text}"`);
      return true;
    }
  }
  
  return false;
}

/**
 * Validate words that might be legitimate but not in SAFE_TOKENS
 */
function isLikelyValidWord(word) {
  // Common English word patterns likely to be valid
  const validPatterns = [
    /^[a-z]+ing$/,    // -ing words (running, walking, checking)
    /^[a-z]+ed$/,     // -ed words (stopped, started, finished) 
    /^[a-z]+er$/,     // -er words (helper, worker, operator)
    /^[a-z]+ly$/,     // -ly words (quickly, safely, properly)
    /^un[a-z]+$/,     // un- prefix (unable, unsafe, unconscious)
    /^re[a-z]+$/,     // re- prefix (return, respond, repeat)
    /^[a-z]+s$/,      // plurals (calls, messages, contacts)
  ];
  
  return validPatterns.some(pattern => pattern.test(word));
}

/**
 * Main garbled message detection with enhanced safety checks
 */
function isGarbledMessage(text) {
  if (text == null) return false;
  const t = String(text).trim();
  if (!t) return false;
  
  // Quick validation for very short messages
  if (t.length <= 3) return false;
  
  // Check for character-level corruption
  if (GARBLE_DETECT.NON_ASCII.test(t)) {
    console.log(`Non-ASCII characters detected in: "${t}"`);
    return true;
  }
  
  if (GARBLE_DETECT.REPLACEMENT.test(t)) {
    console.log(`Replacement characters detected in: "${t}"`);
    return true;
  }
  
  if (GARBLE_DETECT.DISALLOWED_ASCII.test(t)) {
    console.log(`Disallowed ASCII characters detected in: "${t}"`);
    return true;
  }
  
  // Check for word-level issues
  if (hasUnknownWord(t)) {
    return true; // hasUnknownWord already logs details
  }
  
  return false;
}

// Enhanced classification with proper garbled detection integration
function classifyIncomingMessage(responseText, isResponse, promptContext) {
  // Handle explicit emergency requests first
  const emergencyMessages = ["Send help", "I am stranded", "Hazard in area"];
  if (emergencyMessages.includes(responseText)) {
    return { action: "SOS", reason: "Emergency request" };
  }

  // Garbled message detection for responses only (safety measure)
  if (isResponse && isGarbledMessage(responseText)) {
    // Add system log for audit trail
    addLogEntry(
      `⚠️ Garbled message received from device: "${responseText}". Treating as potential distress signal.`,
      "system"
    );
    return { 
      action: "SOS", 
      reason: "Garbled/invalid message - potential equipment malfunction or distress" 
    };
  }

  // Context-aware responses for prompted replies
  if (isResponse && promptContext) {
    const normalizedPrompt = promptContext.toLowerCase().trim();
    
    if (normalizedPrompt === "do you need help?") {
      if (responseText === "Yes") 
        return { action: "SOS", reason: "Confirmed help needed" };
      if (responseText === "No") 
        return { action: "RESOLUTION", reason: "No help needed" };
    } 
    else if (normalizedPrompt === "are you ok?" || normalizedPrompt === "are you okay?") {
      if (responseText === "Yes") 
        return { action: "RESOLUTION", reason: "Confirmed okay" };
      if (responseText === "No") 
        return { action: "SOS", reason: "Not okay" };
    } 
    else if (normalizedPrompt === "leave the area, understood?") {
      if (responseText === "Yes" || responseText === "Understood") {
        return { action: "CONTINUE", reason: "Acknowledged evacuation instruction" };
      }
      if (responseText === "No") 
        return { action: "SOS", reason: "Refused evacuation in dangerous environment" };
    }
  }

  // Spontaneous resolution messages (align with test scenarios)
  const resolutionMessages = ["Issue resolved", "False alarm", "I'm OK"];
  if (resolutionMessages.includes(responseText)) {
    return { action: "RESOLUTION", reason: "Status indicates resolution" };
  }

  I

  // Default: continue protocol
  return { action: "CONTINUE", reason: "Standard message" };
}

// Make functions globally available
window.isGarbledMessage = isGarbledMessage;
window.hasUnknownWord = hasUnknownWord;
window.classifyIncomingMessage = classifyIncomingMessage;


// ==================================================================================
// ENHANCED ADD NOTE SYSTEM - PHASE 1: PATTERN DETECTION
// ==================================================================================

      // Note type detection patterns
      const NOTE_PATTERNS = {
        resolution: {
          patterns: [
            /confirmed.*(?:they are|user is|he is|she is).*(?:ok|okay|safe|fine)/i,
            /alert.*(?:can be|should be).*resolved/i,
            /user.*(?:is safe|is ok|is okay|is fine)/i,
            /false.*alert/i,
            /no.*(?:emergency|incident)/i,
            /everything.*(?:is fine|is ok|is okay)/i,
            /issue.*resolved/i,
            /all.*clear/i,
            /equipment.*malfunction/i,
            /device.*error/i,
          ],
          action: "resolution",
          priority: "high",
        },

        callback: {
          patterns: [
            /(?:will|going to).*(?:call back|check.*back|get back)/i,
            /(?:calling|checking).*(?:back|in).*(\d+).*(?:min|minute)/i,
            /will.*(?:check on|contact).*(?:user|them)/i,
            /(?:call back|check back).*(?:in|within).*(\d+)/i,
          ],
          action: "timer",
          priority: "medium",
        },

        dispatch: {
          patterns: [
            /(?:request|need|send).*dispatch/i,
            /(?:emergency|ambulance|fire|police).*(?:needed|required)/i,
            /(?:send|need).*(?:help|assistance).*(?:immediately|urgent)/i,
            /cannot.*(?:reach|contact).*user/i,
          ],
          action: "dispatch",
          priority: "urgent",
        },

        sos: {
          patterns: [
            /(?:user said|user confirmed).*(?:help|emergency)/i,
            /(?:real|actual).*(?:emergency|incident)/i,
            /user.*(?:needs|requesting).*help/i,
          ],
          action: "sos",
          priority: "urgent",
        },
      };

      // Time extraction patterns
      const TIME_PATTERNS = {
        minutes: /(\d+).*(?:min|minute)/i,
        hours: /(\d+).*(?:hour|hr)/i,
        specific: /(?:in|within).*(\d+).*(?:min|hour)/i,
      };

      // ==================================================================================
      // ENHANCED ADD NOTE SYSTEM - PHASE 2: ANALYSIS FUNCTIONS
      // ==================================================================================

      // Analyze note content for patterns and intent
      function analyzeNote(noteText) {
        const analysis = {
          type: "general",
          actions: [],
          priority: "normal",
          timeframe: null,
          confidence: 0,
        };

        // Check each pattern category
        for (const [category, config] of Object.entries(NOTE_PATTERNS)) {
          for (const pattern of config.patterns) {
            if (pattern.test(noteText)) {
              analysis.type = category;
              analysis.actions.push(config.action);
              analysis.priority = config.priority;
              analysis.confidence = calculateConfidence(noteText, pattern);
              break;
            }
          }
          if (analysis.type !== "general") break;
        }

        // Extract timeframe if this is a callback note
        if (analysis.type === "callback") {
          analysis.timeframe = extractTimeframe(noteText);
        }

        return analysis;
      }

      // Extract timeframe from callback notes
      function extractTimeframe(noteText) {
        let minutes = 30; // default

        const minuteMatch = TIME_PATTERNS.minutes.exec(noteText);
        const hourMatch = TIME_PATTERNS.hours.exec(noteText);

        if (minuteMatch) {
          minutes = parseInt(minuteMatch[1]);
          // Enforce limits: 5 min minimum, 30 min maximum
          minutes = Math.max(5, Math.min(30, minutes));
        } else if (hourMatch) {
          minutes = parseInt(hourMatch[1]) * 60;
          // Convert hours but still enforce 30 min max
          minutes = Math.min(30, minutes);
        }

        return minutes;
      }

      // Extract contact name from note text
      function extractContactName(noteText) {
        // Look for common patterns: "EC John", "Sarah called", "Mike will check"
        const patterns = [
          /EC\s+([A-Za-z]+(?:\s+[A-Za-z]+)?)/i,
          /([A-Za-z]+(?:\s+[A-Za-z]+)?)\s+(?:called|will|is)/i,
          /(?:called|contacted)\s+([A-Za-z]+(?:\s+[A-Za-z]+)?)/i,
        ];

        for (const pattern of patterns) {
          const match = pattern.exec(noteText);
          if (match) {
            return match[1].trim();
          }
        }

        return null;
      }

      // Calculate confidence score for pattern matching
      function calculateConfidence(noteText, pattern) {
        const match = pattern.exec(noteText);
        if (!match) return 0;

        // Base confidence on match length and specific keywords
        let confidence = 0.6;

        // Higher confidence for specific keywords
        const highConfidenceWords = [
          "confirmed",
          "safe",
          "okay",
          "resolved",
          "false alert",
        ];
        const mediumConfidenceWords = ["fine", "ok", "good", "no emergency"];

        for (const word of highConfidenceWords) {
          if (noteText.toLowerCase().includes(word)) {
            confidence += 0.2;
            break;
          }
        }

        for (const word of mediumConfidenceWords) {
          if (noteText.toLowerCase().includes(word)) {
            confidence += 0.1;
            break;
          }
        }

        return Math.min(confidence, 1.0);
      }

      const gasReadingsData = {
        "h2s-high": {
          h2s: { value: 17.9, status: "HIGH" },
          co: { value: 2.5, status: "NORMAL" },
          o2: { value: 20.9, status: "NORMAL" },
          lel: { value: 4.0, status: "NORMAL" },
        },
        "co-high": {
          h2s: { value: 1.2, status: "NORMAL" },
          co: { value: 250.0, status: "HIGH" },
          o2: { value: 20.9, status: "NORMAL" },
          lel: { value: 0.5, status: "NORMAL" },
        },
        // ADD THESE THREE NEW ENTRIES:
        "o2-low": {
          h2s: { value: 1.2, status: "NORMAL" },
          co: { value: 2.5, status: "NORMAL" },
          o2: { value: 16.5, status: "O₂ Depletion" }, // Dangerous depletion
          lel: { value: 0.5, status: "NORMAL" },
        },
        "o2-high": {
          h2s: { value: 1.2, status: "NORMAL" },
          co: { value: 2.5, status: "NORMAL" },
          o2: { value: 25.2, status: "O₂ Enrichment" }, // Dangerous enrichment
          lel: { value: 0.5, status: "NORMAL" },
        },
        "gas-high-threshold": {
          h2s: { value: 17.9, status: "HIGH" },
          co: { value: 2.5, status: "NORMAL" },
          o2: { value: 20.9, status: "NORMAL" },
          lel: { value: 4.0, status: "NORMAL" },
        },
        default: {
          h2s: { value: 1.2, status: "NORMAL" },
          co: { value: 2.5, status: "NORMAL" },
          o2: { value: 20.9, status: "NORMAL" },
          lel: { value: 0.5, status: "NORMAL" },
        },
      };

      let alertsFromJSON = null;

      function isAnyGasDangerousNow() {
        const pills = document.querySelectorAll("[id$='-status']");
        for (const el of pills) {
          const id = (el.id || "").toLowerCase(); // e.g., 'h2s-status'
          const txt = (el.textContent || "").trim().toUpperCase(); // e.g., 'HIGH'
          if (id.startsWith("o2-")) {
            if (/ENRICHMENT|DEPLETION/.test(txt)) return true;
          } else if (/HIGH/.test(txt)) {
            return true; // h2s / co / lel / any future gas with HIGH
          }
        }
        return false; // all normal
      }

      // Load JSON data when page loads
      document.addEventListener("DOMContentLoaded", function () {
  // Load JSON alerts
  fetch("../cypress/fixtures/alertsData.json")
    .then((response) => response.json())
    .then((data) => {
      alertsFromJSON = data;
      
      // Handle the correct structure
      if (data && data.alertTypesData) {
        const alertCount = Object.keys(data.alertTypesData).length;
        console.log("Loaded alerts from JSON:", alertCount, "alerts");
        console.log("Alert IDs:", Object.keys(data.alertTypesData));
      }
      
      if (data && data.usersData) {
        const userCount = Object.keys(data.usersData).length;
        console.log("Loaded users from JSON:", userCount, "users");
      }
    })
    .catch((error) => {
      console.error("Failed to load JSON alerts:", error);
    });

        // Your existing initialization
        updateGasReadings("default");
        startGasMonitoring();

        

        // ==================================================================================
        // ENHANCED MANUAL NOTES VALIDATION WITH PREVIEW:
        // ==================================================================================
        const manualNotesTextarea = document.getElementById("manual-notes");
        const manualNotesButton = document.querySelector(
          'button[onclick="addManualNote()"]'
        );

        if (manualNotesTextarea && manualNotesButton) {
          // Initially disable button
          manualNotesButton.disabled = true;
          manualNotesButton.classList.add("btn-secondary");
          manualNotesButton.classList.remove("btn-success");
          manualNotesButton.textContent = "Post Note";

          // Enhanced input validation with note type preview
          manualNotesTextarea.addEventListener("input", function () {
            const noteText = this.value.trim();

            if (noteText.length > 0) {
              // Enable button
              manualNotesButton.disabled = false;
              manualNotesButton.classList.remove("btn-secondary");
              manualNotesButton.classList.add("btn-success");

              // Analyze note for preview
              const analysis = analyzeNote(noteText);

              // Update button text and color based on note type
              let buttonText = "Post Note";
              manualNotesButton.classList.remove(
                "btn-success",
                "btn-warning",
                "btn-danger"
              );

              switch (analysis.type) {
                case "resolution":
                  buttonText = "✅ Post Resolution Note";
                  manualNotesButton.classList.add("btn-warning");
                  break;
                case "callback":
                  buttonText = `⏰ Post Note (${analysis.timeframe}min timer)`;
                  manualNotesButton.classList.add("btn-success");
                  break;
                case "dispatch":
                  buttonText = "🚨 Post Dispatch Note";
                  manualNotesButton.classList.add("btn-danger");
                  break;
                case "sos":
                  buttonText = "🆘 Post SOS Note";
                  manualNotesButton.classList.add("btn-danger");
                  break;
                default:
                  buttonText = "Post Note";
                  manualNotesButton.classList.add("btn-success");
              }
              manualNotesButton.textContent = buttonText;
            } else {
              // Disable button and reset text
              manualNotesButton.disabled = true;
              manualNotesButton.classList.add("btn-secondary");
              manualNotesButton.classList.remove(
                "btn-success",
                "btn-warning",
                "btn-danger"
              );
              manualNotesButton.textContent = "Post Note";
            }
          });
        }
      });

      // Single source of truth for test alerts
      function resolveAlertById(id) {
        const map = AlertDataManager?.alertTypesData || {};
        const alert = map[id];
        if (!alert) {
          console.warn(`resolveAlertById: unknown alert id "${id}"`);
          return null;
        }
        // return a deep-ish clone so mutations don't affect fixtures
        return JSON.parse(JSON.stringify(alert));
      }

      // Optional: show what we actually have loaded
      console.log(
        `Loaded alert types: ${
          Object.keys(AlertDataManager.alertTypesData || {}).length
        } ids`,
        Object.keys(AlertDataManager.alertTypesData || {})
      );

      // Protocol Factory
      class ProtocolFactory {
        static protocolsData = {
          "gas-emergency-protocol": {
            name: "Gas Emergency Protocol",
            steps: [
              {
                id: "step-1",
                title: "Call Device and Validate Need for Assistance", // ← Removed "STEP 1:"
                action: "call-device", // ← Changed from "Call G7c Device"
              },
              {
  id: "step-2",
  title: "Send message to device based on gas levels: 'Do you need help?' (NORMAL) or 'Leave the area, understood?' (HIGH) and wait 2 minutes",
  action: "message-device",
  timer: 120,
},
              {
                id: "step-3",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-4",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-5",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "fall-detection-protocol": {
            name: "Fall Detection Protocol",
            steps: [
              {
                id: "step-1",
                title: "Call device and validate need for assistance",
                action: "combined-device-user-call",
                subSteps: [
                  {
                    action: "call-device",
                    title: "Call G7c Device",
                  },
                  {
                    action: "call-user",
                    title: "If no answer, call user phone",
                  },
                ],
              },
              {
                id: "step-2",
                title: "Send message 'Do you need help?' and wait 2 minutes",
                action: "message-device",
                timer: 120,
              },
              {
                id: "step-3",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-4",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "sos-protocol": {
            name: "SOS Emergency Protocol",
            steps: [
              {
                id: "step-1",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-2",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
              {
                id: "step-3",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
            ],
          },
          "no-motion-protocol": {
            name: "No Motion Detection Protocol",
            steps: [
              {
                id: "step-1",
                title: "Send message 'Do you need help?' and wait 5 minutes",
                action: "message-device",
                timer: 300,
              },
              {
                id: "step-2",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-3",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-4",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "missed-check-in-protocol": {
            name: "Missed Check-in Protocol",
            steps: [
              {
                id: "step-1",
                title: "Send message 'Do you need help?' and wait 2 minutes",
                action: "message-device",
                timer: 120,
              },
              {
                id: "step-2",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-3",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
                timer: 1800,
              },
              {
                id: "step-4",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, & 3 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "pre-alert-protocol": {
            name: "Pre-Alert Protocol",
            steps: [
              {
                id: "step-1",
                title: "Call Device and Validate Need for Assistance",
                action: "call-device",
              },
              {
                id: "step-2",
                title:
                  "Send message 'Do you need help?' to device and wait 2 minutes",
                action: "message-device",
                timer: 120,
              },
              {
                id: "step-3",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-4",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-5",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "gas-emergency-protocol-high": {
            name: "Gas Emergency Protocol (High Levels)",
            steps: [
              {
                id: "step-1",
                title:
                  "Send message 'Leave the area, understood?' to device and wait 5 minutes",
                action: "message-device",
                timer: 300,
              },
              {
                id: "step-2",
                title: "Call Device and Validate Need for Assistance",
                action: "call-device",
              },
              {
                id: "step-3",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-4",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-5",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "gas-emergency-protocol-normal": {
            name: "Gas Emergency Protocol (Normal Levels)",
            steps: [
              {
                id: "step-1",
                title:
                  "Send message 'Do you need help?' to device and wait 5 minutes",
                action: "message-device",
                timer: 300,
              },
              {
                id: "step-2",
                title: "Call Device and Validate Need for Assistance",
                action: "call-device",
              },
              {
                id: "step-3",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-4",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-5",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, 3 & 4 until contact made.",
                action: "dispatch",
              },
            ],
          },
          "gas-monitoring-protocol": {
            name: "Gas Monitoring Protocol (2-Minute)",
            monitoringPhase: {
              enabled: true,
              duration: 120,
              description:
                "MONITOR GAS LEVELS FOR 2 MINUTES. IF GAS LEVELS RETURN TO NORMAL RESOLVE AS 'INCIDENT WITHOUT DISPATCH'. IF GAS LEVELS ARE STILL HIGH, PROCEED TO STEP 1.",
              autoResolveReason: "incident-without-dispatch",
            },
            organizationPolicy: {
              dispatchPolicy: "conditional", // "conditional", "always", "no-dispatch"
              cycleActions: ["call-user", "call-emergency-contacts"], // Which actions to repeat
            },
            steps: [
              {
                id: "step-1",
                title:
                  "Send message 'Leave the area, understood?' to device and wait 2 minutes",
                action: "message-device",
                timer: 120,
              },
              {
                id: "step-2",
                title:
                  "Call the phone number assigned to the user and validate need for assistance",
                action: "call-user",
              },
              {
                id: "step-3",
                title:
                  "Contact emergency contacts in order of priority. Provide alert information and wait 30 minutes for follow-up.",
                action: "call-emergency-contacts",
              },
              {
                id: "step-4",
                title:
                  "Dispatch emergency services if valid location available, otherwise repeat steps 1, 2, & 3 until contact is made.",
                action: "dispatch",
              },
            ],
          },
        };

        static getProtocolConfig(alertType) {
          const alertConfig = AlertDataManager.alertTypesData[alertType];
          return this.protocolsData[alertConfig.protocolFile];
        }
      }

      // Device Connectivity System
class DeviceConnectivity {
  static currentStatus = {
    online: true,
    lastCommunication: new Date(),
    battery: 85,
    signal: 70,
    connectionType: "Cellular",
  };

  static isDeviceOnline() {
    const info = this.currentStatus;
    if (!info) return false;

    const lastComm = new Date(info.lastCommunication);
    const now = new Date();
    const diffMinutes = (now - lastComm) / (1000 * 60);
    if (diffMinutes > 30) return false; // Last communication ≤ 30 minutes ago
    if (info.battery <= 10) return false; // Battery > 10%
    if (info.signal <= 10) return false; // Signal strength > 10%

    return true;
  }

  static updateConnectivityDisplay() {
    const panel = document.getElementById("connectivityPanel");
    const statusElement = document.getElementById("device-online-status");
    const lastCommElement = document.getElementById("last-comm-time");
    const batteryElement = document.getElementById("battery-level");
    const signalElement = document.getElementById("signal-strength");

    if (!this.currentStatus) {
      if (panel) panel.style.display = "none";
      return;
    } else {
      if (panel) panel.style.display = "";
    }

    const isOnline = this.isDeviceOnline();

    // Status badge
    if (statusElement) {
      if (isOnline) {
        statusElement.textContent = "Online";
        statusElement.className = "status-pill online";
      } else {
        statusElement.textContent = "Offline";
        statusElement.className = "status-pill offline";
      }
    }

    // Battery with color coding
    if (batteryElement) {
      const battery = this.currentStatus.battery;
      batteryElement.textContent = battery + "%";
      const batteryClass = battery <= 10 ? 'offline' : 'online';
      batteryElement.className = `connectivity-value ${batteryClass}`;
    }

    // Signal strength
    if (signalElement) {
      const signal = this.currentStatus.signal;
      signalElement.textContent = signal + "%";
      const signalClass = signal <= 10 ? 'offline' : 'online';
      signalElement.className = `connectivity-value ${signalClass}`;
    }

    // Last communication time
    if (lastCommElement) {
      const lastComm = new Date(this.currentStatus.lastCommunication);
      const now = new Date();
      const diffMinutes = Math.floor((now - lastComm) / (1000 * 60));
      
      if (diffMinutes < 1) {
        lastCommElement.textContent = "Just now";
      } else if (diffMinutes === 1) {
        lastCommElement.textContent = "1 minute ago";
      } else {
        lastCommElement.textContent = `${diffMinutes} minutes ago`;
      }
    }
  }

  static setDeviceOfflineScenario(reason = "battery") {
    switch (reason) {
      case "battery":
        this.currentStatus.battery = 5; // Below 10% threshold
        break;
      case "signal":
        this.currentStatus.signal = 5; // Below 10% threshold
        break;
      case "communication":
        this.currentStatus.lastCommunication = new Date(Date.now() - 45 * 60 * 1000); // 45 min ago
        break;
      default:
        this.currentStatus.battery = 5;
    }
    this.updateConnectivityDisplay();
  }

  static setDeviceOnlineScenario() {
    this.currentStatus = {
      online: true,
      lastCommunication: new Date(),
      battery: 85,
      signal: 70,
      connectionType: "Cellular",
    };
    this.updateConnectivityDisplay();
  }
}

      function getEmergencyContactsStepId() {
        try {
          const cfg = ProtocolFactory.getProtocolConfig(currentAlert?.id);
          if (!cfg || !Array.isArray(cfg.steps)) return "step-3"; // safe fallback

          const ecStep = cfg.steps.find(
            (s) => s.action === "call-emergency-contacts"
          );
          return ecStep ? ecStep.id : "step-3"; // legacy default if not found
        } catch (e) {
          console.warn("getEmergencyContactsStepId fallback:", e);
          return "step-3";
        }
      }

      function confirmOverride() {
        const overrideReasonSelect = document.getElementById("override-reason");
        const overrideReason = overrideReasonSelect.value;

        if (!overrideReason) {
          alert("Please select an override reason");
          return;
        }

        // Get the display text BEFORE clearing anything
        const overrideText =
          overrideReasonSelect.options[overrideReasonSelect.selectedIndex].text;

        const reasonSelect = document.getElementById("resolution-reason");
        let reason = reasonSelect ? reasonSelect.value : "";

        // If no resolution reason was selected, set a default one
        if (!reason) {
          reason = determineResolutionType(currentAlert);
          if (reasonSelect) {
            reasonSelect.value = reason;
          }
        }

        // Close the override modal
        document.getElementById("modalOverlay").style.display = "none";
        document.getElementById("overrideModal").style.display = "none";
        document.getElementById("override-reason").value = ""; // This clears it
        document.getElementById("confirmOverrideBtn").disabled = true;

        lockUIForResolution();

        // Pass the display text, not the value
        completeResolution(reason, overrideText); // Pass the text, not the value
      }

      function startGlobalTimer(
        stepId,
        label,
        contactName = "",
        durationInSeconds = 1800,
        timerType = "step"
      ) {
        // Store the ORIGINAL step ID for resolution tracking
        let originalStepId = stepId;

        // If this is an EC callback timer, preserve the original step
        if (stepId === "ec-callback") {
          // Try to get the original step from activeTimerData before overwriting
          originalStepId = activeTimerData?.originalStepId || "message-device";
        }

        // SET activeTimerData with originalStepId tracking
        activeTimerData = {
          stepId,
          label,
          contactName,
          durationInSeconds,
          originalStepId: originalStepId, // Track which step started this timer chain
          timerType: timerType, // Add timer type tracking
        };

        const display = document.getElementById("timerDisplay");
        const info = document.getElementById("timerInfo");
        const globalTimer = document.getElementById("globalTimer");
        const startTime = new Date();

        // Set global end time for state tracking
        globalTimerEndTime = new Date(
          startTime.getTime() + durationInSeconds * 1000
        );

        // Update timer metadata
        const timerStart = document.getElementById("timerStart");
        const timerEnd = document.getElementById("timerEnd");
        if (timerStart)
          timerStart.textContent =
            startTime.toLocaleTimeString("en-US", {
              hour12: false,
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            }) + " hrs.";
        if (timerEnd)
          timerEnd.textContent =
            globalTimerEndTime.toLocaleTimeString("en-US", {
              hour12: false,
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            }) + " hrs.";

        // Update header
        info.innerHTML = contactName
          ? `<strong>${label}</strong><br>${contactName}`
          : `<strong>${label}</strong>`;

        // Build dropdown - hide for monitoring timers
        const controls = document.querySelector(".timer-controls");
        if (timerType === "monitoring") {
          // Hide cancel dropdown for monitoring timers
          controls.innerHTML = `
 <div style="padding: 12px 16px; font-size: 0.85em; color: white; text-align: center; font-weight: 500; background: rgba(255,255,255,0.15); border-radius: 4px; border: 1px solid rgba(255,255,255,0.2);">
   🔍 Automated gas monitoring in progress
 </div>
`;
} else {
          // FIXED: Get protocol-specific cancel options
          let cancelOptions = getTimerCancelOptions(stepId, label);
          
          controls.innerHTML = `
<select data-cy="global-cancel-dropdown" onchange="handleGlobalTimerCancellation(this.value)"
       class="btn btn-secondary"
       style="padding: 8px 16px; font-size: 0.8em; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: background 0.2s; width: 100%;"
       aria-label="Cancel response timer">
   <option value="">Cancel Timer</option>
   ${cancelOptions}
   <option value="custom">Type reason</option>
</select>
`;
      
        }

        // Start visual state
        globalTimer.classList.remove("timer-inactive");
        globalTimer.classList.add("timer-active");
        globalTimer.style.opacity = "1";
        globalTimer.style.display = "block";

        // Scroll timer into view when started
        globalTimer.scrollIntoView({ behavior: "smooth", block: "center" });

        // Log proper message for device communication timers
        if (stepId === "message-device" && durationInSeconds === 120) {
          // Only for initial 2-minute timer
          addLogEntry(
            'Step 2: Sent "Do you need help?" to device. Waiting 2 minutes for reply.',
            "step"
          );
        }

        function updateDisplay() {
          const now = new Date();
          const remaining = Math.max(
            0,
            Math.floor((globalTimerEndTime - now) / 1000)
          );
          const mins = String(Math.floor(remaining / 60)).padStart(2, "0");
          const secs = String(remaining % 60).padStart(2, "0");
          display.textContent = `${mins}:${secs}`;

          if (remaining <= 0) {
            clearInterval(globalTimerInterval);
            globalTimerInterval = null;
            globalTimerEndTime = null;

            // Reset to inactive state like cancelGlobalTimer
            display.textContent = "--:--";
            info.innerHTML = "<strong>No active timer</strong>";

            const timer = document.getElementById("globalTimer");
            if (timer) {
              timer.classList.remove("timer-active");
              timer.classList.add("timer-inactive");
            }

            // Disable cancel button
            const cancelBtn = document.getElementById("cancelTimerBtn");
            if (cancelBtn) {
              cancelBtn.disabled = true;
            }

            // 🔊 Optional audio
            try {
              const audioCtx = new (window.AudioContext ||
                window.webkitAudioContext)();
              const osc = audioCtx.createOscillator();
              const gain = audioCtx.createGain();
              osc.type = "sine";
              osc.frequency.setValueAtTime(800, audioCtx.currentTime);
              gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
              osc.connect(gain);
              gain.connect(audioCtx.destination);
              osc.start();
              osc.stop(audioCtx.currentTime + 0.5);
            } catch (e) {
              console.warn("🔇 Audio not supported.");
            }

            // 🚨 Visual alert - Tab flashing (if function exists)
            if (typeof startTabFlashing === "function") {
              startTabFlashing("🚨 TIMER EXPIRED");
            }

            // Clear dropdown after expiry
            const timerControls = document.querySelector(".timer-controls");
            if (timerControls) {
              timerControls.innerHTML = "";
            }

            if (activeTimerData && activeTimerData.stepId) {
              // Handle timer expiration based on type
              if (activeTimerData.stepId === "ec-callback") {
                // EC callback timer expired
                addLogEntry(
                  `⏰ Emergency contact callback timer expired. Proceeding to next step.`,
                  "step"
                );

                // Find and activate the emergency contacts step
                const ecStep = document.querySelector(
                  '[data-action="call-emergency-contacts"]'
                );
                if (ecStep) {
                  // Activate the step
                  ecStep.classList.add("active");
                  const statusBadge = ecStep.querySelector(".status-badge");
                  if (statusBadge) {
                    statusBadge.textContent = "Active";
                    statusBadge.className = "status-badge active";
                  }

                  // Visual highlighting
                  ecStep.style.border = "2px solid #ffc107";

                  addLogEntry("EC follow-up required", "system");
                }

                // Check if this step has dispatch action (dispatch steps don't have next steps)
                const protocolConfig = ProtocolFactory.getProtocolConfig(
                  currentAlert.id
                );
                const stepConfig = protocolConfig.steps.find(
                  (step) => step.id === activeTimerData.originalStepId
                );

                if (stepConfig && stepConfig.action !== "dispatch") {
                  enableNextStep(activeTimerData.originalStepId);
                }
              } else if (activeTimerData.stepId.startsWith("step-")) {
                // Regular step timer expired
                const stepNum = activeTimerData.stepId.replace("step-", "");
                addLogEntry(
                  `Step ${stepNum}: Timer expired. Proceeding to next step.`,
                  "step"
                );
                markStepCompleted(activeTimerData.stepId);

                // Check if this step has dispatch action (dispatch steps don't have next steps)
                const protocolConfig = ProtocolFactory.getProtocolConfig(
                  currentAlert.id
                );
                const stepConfig = protocolConfig.steps.find(
                  (step) => step.id === activeTimerData.stepId
                );

                if (stepConfig && stepConfig.action !== "dispatch") {
                  enableNextStep(activeTimerData.stepId);
                }
              }
            } else if (activeTimerData) {
              // Non-step timers - FIXED: Use description instead of label
              const label =
                activeTimerData.description ||
                activeTimerData.contactName ||
                "Unknown Timer";

              // Skip timer expired log for monitoring timers and system timers
              if (
                label !== "Gas Monitoring" &&
                label !== "Unknown Timer" &&
                label !== "System"
              ) {
                const expiredMessage = `⏰ TIMER EXPIRED: ${label}`;
                addLogEntry(expiredMessage, "timer");
              }
            }

            // Optional: Add gas reading log for gas alerts - only for matching gas type
            if (currentAlert && isGasAlert(currentAlert)) {
              const gasReading = getCurrentGasReading();
              const currentAlertGas =
                currentAlert?.gasType?.toLowerCase() || "";
              const readingGas = gasReading.type?.toLowerCase() || "";

              // Only log if the reading matches the current alert's gas type
              const isMatchingGas =
                (readingGas.includes("o2") && currentAlertGas.includes("o2")) ||
                (readingGas.includes("h2s") &&
                  currentAlertGas.includes("h2s")) ||
                (readingGas.includes("co") && currentAlertGas.includes("co")) ||
                (readingGas.includes("lel") && currentAlertGas.includes("lel"));

              if (isMatchingGas) {
                addLogEntry(
                  `Gas level: ${gasReading.status}\nGas Reading: ${gasReading.type}: ${gasReading.value}${gasReading.unit}`,
                  "timer"
                );
              }
            }

            // Clear activeTimerData to prevent further issues
            activeTimerData = null;
          }
        }
        updateDisplay(); // Initial display update
        globalTimerInterval = setInterval(updateDisplay, 1000); // Start the timer interval
      }

      function cancelGlobalTimer() {
        if (!globalTimerInterval) return;

        clearInterval(globalTimerInterval);
        globalTimerInterval = null;
        globalTimerEndTime = null;

        const display = document.getElementById("timerDisplay");
        const info = document.getElementById("timerInfo");
        const timer = document.getElementById("globalTimer");
        const cancelBtn = document.getElementById("cancelTimerBtn");

        display.textContent = "--:--";
        info.innerHTML = "<strong>No active timer</strong>";
        timer.classList.remove("timer-active");
        timer.classList.add("timer-inactive");

        // Disable the cancel button after cancelling
        if (cancelBtn) {
          cancelBtn.disabled = true;
        }

        // addLogEntry("Timer cancelled", "timer");

        // ===== ADD THESE LINES TO STOP SOUNDS =====
        // Stop tab flashing
        if (window.tabFlashInterval) {
          clearInterval(window.tabFlashInterval);
          window.tabFlashInterval = null;
          document.title =
            window.originalTitle ||
            "Enhanced Blackline Live - Alert Management";
        }

        // Stop beeping sounds
        if (window.beepTimeouts && Array.isArray(window.beepTimeouts)) {
          window.beepTimeouts.forEach((timeout) => clearTimeout(timeout));
          window.beepTimeouts = [];
        }
        // ===== END SOUND STOPPING =====
      }

      // ═══════════════════════════════════════════════════════════════
      // 🚨 PROTOCOL CONTROL FUNCTIONS
      // ═══════════════════════════════════════════════════════════════

      function initializeAlert(alertConfig, userConfig) {
        // NEW: Check for pre-alert condition FIRST (for direct calls)
        if (alertConfig && isPreAlert(alertConfig)) {
          addPreAlertLogEntry(alertConfig);
          setupPreAlertResolution();
          console.log(
            "[PreAlert] Alert is >24h old, skipping protocol state setup"
          );
          return; // Skip protocol setup
        }

        protocolState = {
          completedSteps: [],
          currentStep: 1,
          dispatchMade: false,
          alertResolved: false,
          deviceMessageReceived: false,
          currentProtocol: alertConfig.protocolFile,
        };
      }

      function getStepTimer(stepId) {
        if (!currentAlert) return null;

        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const stepConfig = protocolConfig.steps.find(
          (step) => step.id === stepId
        );

        return stepConfig ? stepConfig.timer : null;
      }

      function startStep(stepId) {
  console.log("startStep called with:", stepId);

  // ── Idempotency guard setup ─────────────────────────────────────────
  if (!window.protocolState) window.protocolState = {};
  if (!protocolState.startedSteps) protocolState.startedSteps = new Set();

  // Small helper: (re)enable controls for this step's outcome section
  function enableOutcomeControls(id) {
    // dropdown
    const dropdown = document.getElementById(id + "-select");
    if (dropdown) {
      dropdown.disabled = false;
      dropdown.style.pointerEvents = "auto";
    }
    // textarea
    const note = document.getElementById(id + "-note");
    if (note) {
      note.disabled = false;
      note.style.pointerEvents = "auto";
    }
    // Post Note button (keep your legacy inline onclick selector)
    const postBtn = document.querySelector(
      `#${id} button[onclick*="postNote"]`
    );
    if (postBtn) {
      postBtn.disabled = false;
      postBtn.style.pointerEvents = "auto";
    }
  }

  // Always mark the clicked step/sub-step active (helps CSS show outcome)
  const stepEl = document.getElementById(stepId);
  if (stepEl && !stepEl.classList.contains("active")) {
    stepEl.classList.add("active");
  }

  // Resolve action from config
  const protocolConfig = ProtocolFactory.getProtocolConfig(
    currentAlert.id
  );
  const currentStep = protocolConfig.steps.find((s) => s.id === stepId);
  const action = currentStep ? currentStep.action : undefined;
  const isMessageDevice =
    action === "message-device" || (!action && stepId === "step-2"); // back-compat

  // If already started, just ensure outcome UI is shown & enabled (for non message-device)
  if (protocolState.startedSteps.has(stepId)) {
    if (!isMessageDevice) {
      const outcomeSection = document.getElementById(stepId + "-outcome");
      if (outcomeSection && outcomeSection.style.display !== "block") {
        outcomeSection.style.display = "block";
      }
      // 🔧 ensure inputs are usable even on re-entry
      enableOutcomeControls(stepId);
    }
    return;
  }
  protocolState.startedSteps.add(stepId);

  // ── Show/hide outcome section based on action ───────────────────────
  const outcomeSection = document.getElementById(stepId + "-outcome");
  if (isMessageDevice) {
    if (outcomeSection) outcomeSection.style.display = "none";
  } else {
    if (outcomeSection && outcomeSection.style.display !== "block") {
      outcomeSection.style.display = "block";
    }
    // 🔧 first-run: enable controls
    enableOutcomeControls(stepId);
  }

  // ── Start timer for message-device steps ────────────────────────────
  if (isMessageDevice) {
    const timerDuration =
      (typeof getStepTimer === "function" && getStepTimer(stepId)) ||
      (typeof getStepTimer === "function" && getStepTimer("step-2")) ||
      0;

    const alreadyRunningThisTimer =
      typeof window.activeTimerData === "object" &&
      window.activeTimerData &&
      window.activeTimerData.stepId === stepId &&
      window.activeTimerData.isRunning;

    if (timerDuration && !alreadyRunningThisTimer) {
      console.log("Timer duration found:", timerDuration);
      console.log("About to call startGlobalTimer");
      startGlobalTimer(
        stepId,
        "Waiting for device reply",
        "",
        timerDuration
      );
      console.log("startGlobalTimer call completed");

      // FIXED: Add logging for message-device actions with protocol-aware messaging
      const isGasAlert = window.isGasAlert?.(currentAlert) || false;
      const gasCurrentlyDangerous = isGasAlert && !isGasCurrentlyNormalized();
      
      // Dynamic messaging based on protocol and gas levels
      let messageText = "Do you need help?"; // Default message
      if (action === "message-device") {
        const protocolName = protocolConfig?.name || "";
        
        // Only apply gas-aware messaging for Gas Emergency protocols
        if (protocolName.includes("Gas Emergency")) {
          messageText = gasCurrentlyDangerous 
            ? "Leave the area, understood?" 
            : "Do you need help?";
        }
      }

      const stepNum = stepId.replace("step-", "");
      addLogEntry(
        `Step ${stepNum}: Sent "${messageText}" to device. Waiting ${Math.floor(
          timerDuration / 60
        )} minutes for reply.`,
        "step"
      );

      // Set context for message classification system
      lastPromptSent = messageText;
      promptTimestamp = Date.now();
      protocolState.deviceMessageReceived = false;
      awaitingResponse = true;

      // Start our message timer (separate from global timer)
      if (messageTimer) {
        clearTimeout(messageTimer);
      }
      messageTimer = setTimeout(() => {
        if (awaitingResponse) {
          addLogEntry(
            `No response received within ${Math.floor(
              timerDuration / 60
            )} minutes. Proceeding to next step.`,
            "timer"
          );
          awaitingResponse = false;
          lastPromptSent = null;
        }
      }, timerDuration * 1000);

      // Add status badge logic
      const statusBadge = document.getElementById(stepId + "-status");
      if (statusBadge) {
        statusBadge.textContent = "Waiting";
        statusBadge.className = "status-badge waiting";
        console.log("Step status set to Waiting");
      }
    } else {
      if (!timerDuration)
        console.log(`No timer duration found for ${stepId}`);
      if (alreadyRunningThisTimer)
        console.log(
          `Global timer for ${stepId} already running; skipping restart.`
        );
    }
  }
}

      function validatePostButton(stepId) {
        const stepEl = document.getElementById(stepId);
        if (!stepEl) return;

        // Prefer the actual Post Note button inside this step
        const button =
          stepEl.querySelector('button[onclick*="postNote"]') ||
          stepEl.querySelector(
            'button[class*="btn"]:not([onclick*="startStep"])'
          );
        if (!button) return;

        // Prefer the step-specific note box; fall back to any textarea inside the step
        let note =
          document.getElementById(stepId + "-note") ||
          stepEl.querySelector("textarea");
        const hasText = !!(note && note.value.trim().length > 0);

        let enable = false;

        // Check if this step contains dispatch action (action-based detection)
        const hasDispatchElements =
          stepEl.querySelector("#dispatch-decision") !== null;

        if (hasDispatchElements) {
          const decision = (
            document.getElementById("dispatch-decision")?.value || ""
          ).toLowerCase();
          const skip = (
            document.getElementById("skip-reason")?.value || ""
          ).toLowerCase();

          if (decision === "no") {
            // Enable if a skip reason is selected OR the note has content
            enable = !!skip || hasText;
          } else if (decision === "yes") {
            // Keep simple: allow posting notes when dispatching
            // (tighten here if you later require a selected service)
            enable = true;
          } else {
            // Unknown/blank decision → fall back to text requirement
            enable = hasText;
          }
        } else {
          // Default rule for all other steps: require note text
          enable = hasText;
        }

        // Apply state + visual style (preserve your existing classes)
        button.disabled = !enable;
        if (enable) {
          button.classList.remove("btn-secondary");
          button.classList.add("btn-success");
        } else {
          button.classList.remove("btn-success");
          button.classList.add("btn-secondary");
        }
      }

      // UNIVERSAL HELPER FUNCTIONS (add these at the top of the function)
function handleCallDeviceOutcome(
  selectedValue,
  currentUser,
  currentAlert
) {
  let noteText = "";
  let shouldScrollToResolution = false;

  if (selectedValue === "confirmed-ok") {
    noteText = `Called device. Spoke with ${
      currentUser?.name || "user"
    }. Confirmed they are okay. Resolving alert.`;
    shouldScrollToResolution = true;
  } else if (selectedValue === "user-callback") {
    noteText = `${
      currentUser?.name || "User"
    } called in. Confirmed they are okay. Resolving alert.`;
    shouldScrollToResolution = true;
  } else if (selectedValue === "no-answer") {
    noteText = `Called device. No answer`;
  } else if (selectedValue === "unable-to-call") {
    noteText = `Unable to call, device offline`;
  }

  return { noteText, shouldScrollToResolution };
}

      function handleCallUserOutcome(selectedValue, currentUser, currentAlert) {
        let noteText = "";
        let shouldScrollToResolution = false;

        if (selectedValue === "confirmed-ok") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }. Confirmed they are okay. Resolving alert.`.trim();
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback") {
          noteText = `Emergency contact called in and confirmed ${
            currentUser?.name || "user"
          } is okay. Resolving alert.`; // ✅ ADDED PERIOD
          shouldScrollToResolution = true;
        } else if (selectedValue === "user-callback") {
          noteText = `${
            currentUser?.name || "User"
          } called in. Confirmed they are okay. Resolving alert.`; // ✅ ADDED PERIOD
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback-30min") {
          noteText = `Emergency contact called in, will check on user and call back within 30 minutes`;
        } else if (selectedValue === "no-answer-voicemail") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }, no answer. Left voicemail`.trim();
        } else if (selectedValue === "no-answer-already-left") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }, no answer. Voicemail had already been left`.trim();
        } else if (selectedValue === "no-answer-mailbox-full") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }, no answer. Unable to leave voicemail, mailbox full`.trim();
        } else if (selectedValue === "no-answer-unable-voicemail") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }, no answer. Unable to leave voicemail`.trim();
        } else if (selectedValue === "no-answer-mailbox-not-setup") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }, no answer. Unable to leave voicemail, mailbox not set up yet`.trim();
        } else if (selectedValue === "no-phone-number") {
          noteText = `Unable to call, user has no phone number assigned`;
        } else if (selectedValue === "number-disconnected") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }. Number has been changed, disconnected or no longer in service`.trim();
        } else if (selectedValue === "unable-to-connect") {
          noteText = `Called ${currentUser?.name || "user"} at ${
            currentUser?.mobile || ""
          }. Unable to connect`.trim();
        }

        return { noteText, shouldScrollToResolution };
      }

      function handleCallEmergencyContactsOutcome(
        selectedValue,
        currentUser,
        currentAlert,
        ecIndex = 0
      ) {
        let noteText = "";
        let shouldScrollToResolution = false;

        // Get the specific emergency contact
        const userKey = currentAlert?.user;
        const contact =
          userKey &&
          AlertDataManager.usersData[userKey]?.emergencyContacts?.length >
            ecIndex
            ? AlertDataManager.usersData[userKey].emergencyContacts[ecIndex]
            : null;

        const contactName = contact ? contact.name : "Emergency Contact";
        const contactPhone = contact ? contact.phone : "";

        if (selectedValue === "confirmed-ok") {
          noteText = `Called ${contactName} at ${contactPhone}. Confirmed ${
            currentUser?.name || "user"
          } is okay. Resolving alert.`;
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback") {
          noteText = `Emergency contact called in and confirmed ${
            currentUser?.name || "user"
          } is okay. Resolving alert.`;
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback-30min-outbound") {
          noteText = `Called ${contactName} at ${contactPhone}. EC will check on ${
            currentUser?.name || "user"
          } and call back within 30 minutes`;
          shouldScrollToResolution = false;
        } else if (selectedValue === "no-answer-voicemail") {
          noteText = `Called ${contactName} at ${contactPhone}. No answer, left voicemail`;
        } else if (selectedValue === "no-answer-already-left") {
          noteText = `Called ${contactName} at ${contactPhone}. No answer, voicemail already left`;
        } else if (selectedValue === "no-answer-unable") {
          noteText = `Called ${contactName} at ${contactPhone}. No answer, unable to leave voicemail`;
        } else if (selectedValue === "no-answer-box-full") {
          noteText = `Called ${contactName} at ${contactPhone}. No answer, voicemail box full`;
        } else if (selectedValue === "no-answer-not-set") {
          noteText = `Called ${contactName} at ${contactPhone}. No answer, voicemail not set up`;
        } else if (selectedValue === "wrong-number") {
          noteText = `Called ${contactName} at ${contactPhone}. Wrong number`;
        } else if (selectedValue === "unable-to-connect") {
          noteText = `Called ${contactName} at ${contactPhone}. Unable to connect`;
        } else if (selectedValue === "number-invalid") {
          noteText = `Called ${contactName} at ${contactPhone}. Number invalid, changed, or out of service`;
        }

        return { noteText, shouldScrollToResolution };
      }

      function handleDispatchOutcome(selectedValue, currentUser, currentAlert) {
        let noteText = "";
        let shouldScrollToResolution = false;

        if (selectedValue === "user-callback") {
          noteText = `${
            currentUser?.name || "User"
          } called in. Confirmed they are okay. Resolving alert.`;
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback") {
          noteText = `Emergency contact called in and confirmed ${
            currentUser?.name || "user"
          } is okay. Resolving alert.`;
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback-cancel-dispatch") {
          noteText = `Emergency contact called in, advised to cancel dispatch. They confirmed ${
            currentUser?.name || "user"
          } is okay / will check on ${
            currentUser?.name || "user"
          }. Resolving alert.`;
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback-cancel-dispatch-30min") {
          noteText = `Emergency contact called in, advised to cancel dispatch. They will check on ${
            currentUser?.name || "user"
          } and call back within 30 minutes.`;
        } else if (selectedValue === "ec-callback-30min") {
          noteText = `Emergency contact called in, will check on ${
            currentUser?.name || "user"
          } and call back within 30 minutes.`;
        }

        return { noteText, shouldScrollToResolution };
      }

      function autoPopulateFromDropdown(stepId) {
        const select = document.getElementById(stepId + "-select");
        const note = document.getElementById(stepId + "-note");

        // Do not require currentUser just to populate generic notes
        if (!select || !note) return;

        const selectedValue = select.value;
        console.log(
          "DEBUG: selectedValue =",
          selectedValue,
          "for stepId =",
          stepId
        );
        if (!selectedValue) return;

        let noteText = "";
        let shouldScrollToResolution = false;

        // Get current step action for action-based handling
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        if (!protocolConfig) {
          console.warn("No protocol config found for alert:", currentAlert.id);
          return;
        }

        // Handle sub-step IDs (step-1-1, step-1-2, etc.)
        let actualStepId = stepId;
        let subStepAction = null;

        if (stepId.includes("-") && stepId.split("-").length === 3) {
          const parts = stepId.split("-"); // ["step","1","1"]
          const mainStepId = parts[0] + "-" + parts[1]; // "step-1"
          const subStepIndex = parseInt(parts[2], 10) - 1; // 0 for first

          const mainStep = protocolConfig.steps.find(
            (s) => s.id === mainStepId
          );
          if (
            mainStep &&
            Array.isArray(mainStep.subSteps) &&
            mainStep.subSteps[subStepIndex]
          ) {
            subStepAction = mainStep.subSteps[subStepIndex].action;
            actualStepId = mainStepId; // use main step for user data if needed
          }
        }

        const currentStep =
          protocolConfig.steps.find((s) => s.id === stepId) ||
          protocolConfig.steps.find((s) => s.id === actualStepId);
        const stepAction = subStepAction || currentStep?.action;

        console.log("DEBUG: stepId =", stepId, "stepAction =", stepAction);

        // ═══════════════════════════════════════════════════════════
        // ACTION-BASED LOGIC (Primary approach)
        // ═══════════════════════════════════════════════════════════
        if (stepAction === "call-device") {
          const result = handleCallDeviceOutcome(
            selectedValue,
            currentUser,
            currentAlert
          );
          noteText = result.noteText;
          shouldScrollToResolution = result.shouldScrollToResolution;
        } else if (stepAction === "message-device") {
          const result = handleMessageDeviceOutcome(
            selectedValue,
            currentUser,
            currentAlert
          );
          noteText = result.noteText;
          shouldScrollToResolution = result.shouldScrollToResolution;
        } else if (stepAction === "call-user") {
          const result = handleCallUserOutcome(
            selectedValue,
            currentUser,
            currentAlert
          );
          noteText = result.noteText;
          shouldScrollToResolution = result.shouldScrollToResolution;
        } else if (
          stepAction === "call-emergency-contacts" ||
          stepId === getEmergencyContactsStepId() ||
          stepId.startsWith(getEmergencyContactsStepId() + "-")
        ) {
          // Extract EC index from stepId (e.g., "step-4-1" -> ecIndex = 0)
          let ecIndex = 0;
          if (stepId.includes("-")) {
            const parts = stepId.split("-");
            if (parts.length >= 3) {
              ecIndex = parseInt(parts[2]) - 1; // Convert 1-based to 0-based index
            }
          }

          const result = handleCallEmergencyContactsOutcome(
            selectedValue,
            currentUser,
            currentAlert,
            ecIndex
          );
          noteText = result.noteText;
          shouldScrollToResolution = result.shouldScrollToResolution;
          aFd;
        } else if (stepAction === "dispatch") {
          console.log(
            "DEBUG: Processing dispatch action in autoPopulate - NOT setting dispatchMade flag"
          );

          const result = handleDispatchOutcome(
            selectedValue,
            currentUser,
            currentAlert
          );
          noteText = result.noteText;
          shouldScrollToResolution = result.shouldScrollToResolution;
        }

        // ═══════════════════════════════════════════════════════════
        // STEP-BASED FALLBACKS (For protocols without proper actions)
        // ═══════════════════════════════════════════════════════════
        else if (stepId === "step-1" || actualStepId === "step-1") {
          if (selectedValue === "confirmed-ok") {
            noteText = `Spoke with ${
              currentUser?.name || "user"
            }. Confirmed they are okay`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "user-callback") {
            noteText = `${
              currentUser?.name || "User"
            } called in. Confirmed they are okay`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "no-answer") {
            noteText = `Called device. No answer`;
          } else if (selectedValue === "unable-to-call") {
            noteText = `Unable to call, device offline`;
          }
        } else if (stepId === "step-2" || actualStepId === "step-2") {
          if (selectedValue === "unable-to-send") {
            noteText = `Unable to send text message, device offline`;
          } else if (selectedValue === "no-response") {
            noteText = `Sent message "Do you need help?" to device. No response received`;
          } else if (selectedValue === "device-no") {
            noteText = `Received message "No" from device. User confirmed okay`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "issue-resolved") {
            noteText = `Received message "Issue resolved" from device. User confirmed okay`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "false-alarm") {
            noteText = `Received message "False alarm" from device. User confirmed okay`;
            shouldScrollToResolution = true;
          }
        } else if (stepId === "step-3" || actualStepId === "step-3") {
          if (selectedValue === "confirmed-ok") {
            noteText = `Called ${currentUser?.name || "user"} at ${
              currentUser?.mobile || ""
            }. Confirmed they are OK`.trim();
            shouldScrollToResolution = true;
          } else if (selectedValue === "ec-callback") {
            noteText = `Emergency contact called in and confirmed ${
              currentUser?.name || "user"
            } is okay`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "user-callback") {
            noteText = `User called in. Confirmed they are okay`;
            shouldScrollToResolution = true;
          } else if (selectedValue === "ec-callback-30min") {
            noteText = `Emergency contact called in, will check on user and call back within 30 minutes`;
          } else if (selectedValue === "no-answer-voicemail") {
            noteText = `Called ${currentUser?.name || "user"} at ${
              currentUser?.mobile || ""
            }, no answer. Left voicemail`.trim();
          } else if (selectedValue === "no-answer-already-left") {
            noteText = `Called ${currentUser?.name || "user"} at ${
              currentUser?.mobile || ""
            }, no answer. Voicemail had already been left`.trim();
          } else if (selectedValue === "no-answer-mailbox-full") {
            noteText = `Called ${currentUser?.name || "user"} at ${
              currentUser?.mobile || ""
            }, no answer. Unable to leave voicemail, mailbox full`.trim();
          } else if (selectedValue === "no-answer-unable-voicemail") {
            noteText = `Called ${currentUser?.name || "user"} at ${
              currentUser?.mobile || ""
            }, no answer. Unable to leave voicemail`.trim();
          } else if (selectedValue === "no-answer-mailbox-not-setup") {
            noteText = `Called ${currentUser?.name || "user"} at ${
              currentUser?.mobile || ""
            }, no answer. Unable to leave voicemail, mailbox not set up yet`.trim();
          } else if (selectedValue === "no-phone-number") {
            noteText = `Unable to call, user has no phone number assigned`;
          } else if (selectedValue === "number-disconnected") {
            noteText = `Number has been changed, disconnected or no longer in service`;
          } else if (selectedValue === "unable-to-connect") {
            noteText = `Unable to connect`;
          }
        }

        // ═══════════════════════════════════════════════════════════
        // FINAL FALLBACK: Use dropdown label if no noteText generated
        // ═══════════════════════════════════════════════════════════
        if (!noteText) {
          const label =
            select.options[select.selectedIndex]?.text || selectedValue;
          noteText = label;
          console.warn(
            "Using fallback noteText for stepId:",
            stepId,
            "action:",
            stepAction,
            "noteText:",
            noteText
          );
        }

        // ═══════════════════════════════════════════════════════════
        // GAS ALERT ENHANCEMENTS (Add gas data for resolving outcomes)
        // ═══════════════════════════════════════════════════════════
        console.log("DEBUG GAS CHECK:");
        console.log("- isGasAlert:", window.isGasAlert?.(currentAlert));
        console.log("- noteText:", noteText);
        console.log(
          "- confirmed regex test:",
          /confirmed.*okay/i.test(noteText) ||
            /confirmed user is okay/i.test(noteText)
        );
        console.log("- Gas Type test:", !/Gas Type:\s/i.test(noteText));

        if (
          window.isGasAlert?.(currentAlert) &&
          (/confirmed.*okay/i.test(noteText) ||
            /confirmed user is okay/i.test(noteText)) &&
          !/Gas Type:\s/i.test(noteText) &&
          !/Gas Reading:\s/i.test(noteText) &&
          !/⚠️ Gas levels still HIGH/i.test(noteText)
        ) {
          console.log("DEBUG GAS: Gas section triggered!");

          const gasBlockRaw =
            typeof getGasSnapshotFromPanel === "function"
              ? getGasSnapshotFromPanel()
              : "";

          console.log("DEBUG GAS: gasBlockRaw =", gasBlockRaw);

          if (gasBlockRaw) {
            const now = new Date();
            const ts =
              typeof FORMATTERS?.timestampMST === "function"
                ? FORMATTERS.timestampMST(now)
                : new Intl.DateTimeFormat("en-US", {
                    timeZone: "America/Denver",
                    year: "numeric",
                    month: "2-digit",
                    day: "2-digit",
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit",
                    hour12: false,
                  }).format(now) + " MDT";

            const gasBlockWithTs = gasBlockRaw.replace(
              /(Gas Reading:\s*[^\n]+)/i,
              `$1 (${ts})`
            );

            const gasStillHigh =
              typeof isAnyGasDangerousNow === "function"
                ? isAnyGasDangerousNow()
                : !isGasCurrentlyNormalized();

                if (gasStillHigh) {
  const warningText = "⚠️ Gas levels still HIGH.";
  console.log("🔴 AUTOPOP: Adding HIGH gas warning to noteText");
  noteText += `\n\n${warningText}\n\n${gasBlockWithTs}`;
} else {
  // FIXED: Don't add "Gas readings back to normal." here at all - let postNote() handle it
  console.log("🔴 AUTOPOP: Adding NORMAL gas data to noteText");
  noteText += `\n\n${gasBlockWithTs}`;
}
} else {
  console.log("DEBUG GAS: No gasBlockRaw data!");
}
        }

        // ═══════════════════════════════════════════════════════════
        // SET NOTE VALUE AND VALIDATE
        // ═══════════════════════════════════════════════════════════
        note.value = noteText;
        console.log("Setting noteText:", noteText);

        // Re-run validator so the Post Note button enables
        if (typeof validatePostButton === "function") {
          validatePostButton(stepId);
        }

        // Optional: scroll to resolution if we set a resolving outcome
        if (
          shouldScrollToResolution &&
          typeof triggerResolutionFlow === "function"
        ) {
          // leave actual resolution to postNote; this is just UX affordance
        }
      }

      window.isGasAlert =
  window.isGasAlert ||
  function (alert) {
    if (!alert) return false;
    const id = String(alert.id || "");
    const type = String(alert.gasType || "");
    const GAS_KEYS = /(h2s|h₂s|co|o2|o₂|lel)\b/i;
    return (
      /(^gas-|(^|[^a-z])gas([^a-z]|$))/i.test(id) || // ids starting with/containing "gas"
      GAS_KEYS.test(id) || // Check for gas chemicals in ID
      GAS_KEYS.test(type) || // Check for gas chemicals in gasType
      /^(h2s|co|o2|lel)-/.test(id) // ← This line was missing! Catches "h2s-response", "co-spontaneous", etc.
    );
  };

      // Keep this as-is unless you introduce a distinct sink or styling for gas logs
      window.addGasLogEntry =
        window.addGasLogEntry ||
        function (msg, stepId) {
          addLogEntry(msg, "step"); // same sink as non-gas for now
        };

      // Standard cycle message used everywhere (no more "until contact made")
      const CYCLE_LINE =
        "🔄 Repeating STEPS 1, 2, 3 & 4 until someone is reached.";

      // Status helpers for gas
      function _gasStatus(id) {
        return (document.getElementById(id)?.textContent || "").toUpperCase();
      }
      function isGasCurrentlyNormalized() {
        const dangerO2 = /ENRICHED|DEPLETED/.test(_gasStatus("o2-status"));
        const dangerOthers =
          /\bHIGH\b/.test(_gasStatus("h2s-status")) ||
          /\bHIGH\b/.test(_gasStatus("co-status")) ||
          /\bHIGH\b/.test(_gasStatus("lel-status"));
        return !(dangerO2 || dangerOthers);
      }
      function buildGasSnapshotWithTs() {
        try {
          let block =
            typeof getGasSnapshotFromPanel === "function"
              ? getGasSnapshotFromPanel()
              : "";
          if (!block) return "";
          const now = new Date();
          const ts =
            typeof FORMATTERS?.timestampMST === "function"
              ? FORMATTERS.timestampMST(now)
              : new Intl.DateTimeFormat("en-US", {
                  timeZone: "America/Denver",
                  year: "numeric",
                  month: "2-digit",
                  day: "2-digit",
                  hour: "2-digit",
                  minute: "2-digit",
                  second: "2-digit",
                  hour12: false,
                }).format(now) + " MDT";
          return block.replace(/(Gas Reading:\s*[^\n]+)/i, `$1 (${ts})`);
        } catch {
          return "";
        }
      } // <-- END OF THE autoPopulateFromDropdown function

      function _squashResolveLine(s) {
        // Turn any preceding newline(s) before the canonical resolve text into a single space
        return String(s).replace(
          /\n{1,2}\s*Gas readings back to normal\. Resolving alert\./,
          " Gas readings back to normal. Resolving alert."
        );
      }

      function postNote(stepId) {
        // Ensure protocolState exists
        if (!window.protocolState) window.protocolState = {};
        if (!Array.isArray(protocolState.completedSteps))
          protocolState.completedSteps = [];

          
        // Element resolution helpers
        const resolveIO = (id) => {
          const tryBases = [id];
          let actionKey = "";

          try {
            const cfg = ProtocolFactory.getProtocolConfig(currentAlert.id);
            if (/^action-/.test(id)) {
              actionKey = id.replace(/^action-/, "");
            } else {
              const baseStepId = id.match(/^(step-\d+)/)?.[1] || id;
              const stepObj =
                cfg?.steps?.find((s) => s.id === id) ||
                cfg?.steps?.find((s) => s.id === baseStepId);
              if (stepObj?.action) actionKey = stepObj.action;
            }
          } catch {}

          if (actionKey) tryBases.unshift(`action-${actionKey}`);

          const m = id.match(/^(step-\d+)-\d+$/);
          if (m) tryBases.push(m[1]);

          let note = null,
            select = null;

          for (const base of tryBases) {
            note = note || document.getElementById(base + "-note");
            select = select || document.getElementById(base + "-select");
          }

          if (!note || !select) {
            const container =
              (actionKey &&
                document.querySelector(`[data-action="${actionKey}"]`)) ||
              document.getElementById(id);
            if (container) {
              const key =
                container.getAttribute?.("data-action") || actionKey || "";
              note =
                note ||
                container.querySelector(
                  `textarea[data-action="${key}"], textarea`
                );
              select =
                select ||
                container.querySelector(`select[data-action="${key}"], select`);
            }
          }

          return { note, select, actionKey };
        };

        let { note, select, actionKey } = resolveIO(stepId);

        // Auto-populate if empty
        if (
          note &&
          !note.value.trim() &&
          typeof autoPopulateFromDropdown === "function"
        ) {
          autoPopulateFromDropdown(stepId);
          ({ note, select, actionKey } = resolveIO(stepId));
        }

        if (!note || !note.value.trim()) {
          alert("Please enter text before posting note");
          return;
        }

        // Helper functions
        const stepLabel = (() => {
          const raw = String(stepId).replace(/^step-/, "");
          const parts = raw.split("-").filter(Boolean);
          return /^step-/.test(stepId) ? "Step " + parts.join(".") : "";
        })();

        const stripLeadingStepPrefix = (text) =>
          String(text)
            .replace(/^Step\s+\d+(?:\.\d+)?:\s*/i, "")
            .trim();

        const selectedOutcome = select ? select.value : "";
        const rawMessage = note.value.trim();
        const actionText = stripLeadingStepPrefix(rawMessage);
        const actionLabel =
          (actionKey &&
            (window.ACTION_LABELS?.[actionKey] ||
              actionKey.replace(/-/g, " "))) ||
          "";

        // Get protocol config
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const currentStep =
          protocolConfig.steps.find((s) => s.id === stepId) ||
          protocolConfig.steps.find(
            (s) => s.id === stepId.split("-").slice(0, 2).join("-")
          ) ||
          protocolConfig.steps.find((s) => s.action === actionKey);

        // Check if gas alert
        const isGas = window.isGasAlert?.(currentAlert) || false;

        // Unified logger (gas data already appended by autoPopulateFromDropdown)
const logStep = (text) => {
  // Check if CURRENT alert is actually a gas alert
  const isCurrentlyGasAlert = window.isGasAlert?.(currentAlert) || false;
  
  if (
    isCurrentlyGasAlert &&  // ← Add this check
    typeof addGasLogEntry === "function" &&
    !/Gas levels still HIGH/i.test(text)
  ) {
    console.log("Gas logging from: postNote -> addGasLogEntry");
    addGasLogEntry(text, stepId);
    return; // Exit here - don't call anything else
  }
  console.log("Gas logging from: postNote -> addLogEntry");
  addLogEntry(text, "step");
};

        const CYCLE_TEXT =
          typeof CYCLE_LINE === "string"
            ? CYCLE_LINE
            : "🔄 Repeating STEPS 1, 2, 3 & 4 until someone is reached.";

        // Mark step as completed - HELPER FUNCTION INSIDE postNote (uses closure)
        const markStepCompleted = (targetStepId = stepId) => {
          const stepEl = document.getElementById(targetStepId); // ← Use parameter
          const statusBadge = document.getElementById(targetStepId + "-status"); // ← Use parameter

          if (stepEl) {
            stepEl.classList.remove("active");
            stepEl.classList.add("completed");
            stepEl.style.opacity = "0.8";
            const actionButton = stepEl.querySelector(
              'button:not([onclick*="postNote"])'
            );
            if (actionButton) {
              actionButton.disabled = true;
              actionButton.classList.remove("btn-primary");
              actionButton.classList.add("btn-secondary");
            }
            stepEl
              .querySelectorAll("select")
              .forEach((sel) => (sel.disabled = true));
          }

          if (statusBadge) {
            statusBadge.textContent = "Completed";
            statusBadge.className = "status-badge completed";
          }

          if (typeof stopTabFlashing === "function") stopTabFlashing();
          protocolState.completedSteps.push(targetStepId); // ← Use parameter
        };

        // Reset form inputs - HELPER FUNCTION
        const resetFormInputs = () => {
          note.value = "";
          if (select) select.value = "";
          note.disabled = false;

          // Clear dispatch dropdowns if this was a dispatch step
          const dispatchDropdown = document.getElementById("dispatch-decision");
          if (dispatchDropdown) {
            dispatchDropdown.value = "";
          }

          const serviceDropdown = document.getElementById("service-type");
          if (serviceDropdown) {
            serviceDropdown.value = "";
          }

          // Update dispatch UI visibility
          const serviceContainer = document.getElementById(
            "service-type-container"
          );
          if (serviceContainer) {
            serviceContainer.style.display = "none";
          }

          const skipContainer = document.getElementById(
            "skip-reason-container"
          );
          if (skipContainer) {
            skipContainer.style.display = "block";
          }

          if (typeof validatePostButton === "function")
            validatePostButton(stepId);
        };

        // DISPATCH HANDLING
        if (currentStep && currentStep.action === "dispatch") {
          const decisionEl = document.getElementById("dispatch-decision");
          const dispatchDecision = decisionEl ? decisionEl.value : "";

          if (dispatchDecision === "no") {
            const skipReasonEl = document.getElementById("skip-reason");
            const reasonText = skipReasonEl
              ? (
                  skipReasonEl.options[skipReasonEl.selectedIndex]?.text ||
                  "conditions not met"
                ).trim()
              : "conditions not met";
            const svcEl = document.getElementById("dispatch");
            const selectedService = svcEl ? (svcEl.value || "").trim() : "";

            let msg;
            try {
              if (typeof generateDispatchProtocolLog === "function") {
                msg = generateDispatchProtocolLog(
                  "no",
                  reasonText,
                  selectedService,
                  stepId
                );
              } else {
                throw new Error("generateDispatchProtocolLog not available");
              }
            } catch (e) {
              const lastTxt =
                document.getElementById("last-comm-time")?.textContent || "";
              const battTxt =
                document.getElementById("battery-level")?.textContent || "";
              const sigTxt =
                document.getElementById("signal-strength")?.textContent || "";

              const parts = [];
              const parseMins = (t) => {
                const s = String(t).toLowerCase();
                const m = s.match(/(\d+)\s*min/);
                if (m) return +m[1];
                const h = s.match(/(\d+)\s*hour/);
                if (h) return +h[1] * 60;
                const a = s.match(/(\d+).*ago/);
                return a ? +a[1] : NaN;
              };
              const num = (s) => {
                const m = String(s).match(/-?\d+(\.\d+)?/);
                return m ? Number(m[0]) : NaN;
              };

              const mins = parseMins(lastTxt);
              const b = num(battTxt);
              const sg = num(sigTxt);

              if (!Number.isNaN(mins)) parts.push(`last comm ${mins} min ago`);
              if (!Number.isNaN(b)) parts.push(`battery ${b}%`);
              if (!Number.isNaN(sg)) parts.push(`signal ${sg}%`);

              const finalReason =
                /offline/i.test(reasonText) && parts.length
                  ? `device offline (${parts.join(", ")})`
                  : reasonText;
              msg = `${stepLabel}${
                actionLabel ? ` (${actionLabel})` : ""
              }: Unable to dispatch - ${finalReason}.`;
            }

            if (!msg.endsWith(".")) msg += ".";

            // Gas normalized check for dispatch skip
            if (isGas) {
              const skipReasonVal = (
                document.getElementById("skip-reason")?.value || ""
              ).toLowerCase();
              const looksGasNormalized =
                skipReasonVal === "gas-normalized" ||
                /gas level(s)?\s*(have\s*)?(returned|back)\s*to\s*normal|gas .*normal/i.test(
                  reasonText
                );

              if (looksGasNormalized && !/Gas Type:\s/i.test(msg)) {
                let block = "";
                try {
                  block =
                    typeof getGasSnapshotFromPanel === "function"
                      ? getGasSnapshotFromPanel()
                      : "";
                  if (block) {
                    const now = new Date();
                    const ts =
                      typeof FORMATTERS?.timestampMST === "function"
                        ? FORMATTERS.timestampMST(now)
                        : new Intl.DateTimeFormat("en-US", {
                            timeZone: "America/Denver",
                            year: "numeric",
                            month: "2-digit",
                            day: "2-digit",
                            hour: "2-digit",
                            minute: "2-digit",
                            second: "2-digit",
                            hour12: false,
                          }).format(now) + " MDT";
                    block = block.replace(
                      /(Gas Reading:\s*[^\n]+)/i,
                      `$1 (${ts})`
                    );
                    msg += `\n\n${block}`;
                  }
                } catch {}
              }
            }

            msg += `

            ${CYCLE_TEXT}`;

            const isCurrentlyGasAlert = window.isGasAlert?.(currentAlert) || false;
if (isCurrentlyGasAlert && typeof addGasLogEntry === "function") {
  addGasLogEntry(msg, stepId);
} else {
  addLogEntry(msg, "step");
}

            markStepCompleted(); // Uses closure - no parameter
            resetFormInputs();

            if (typeof silentlyUpdateDispatchConditions === "function") {
              silentlyUpdateDispatchConditions();
              requestAnimationFrame(silentlyUpdateDispatchConditions);
            }

            setTimeout(() => restartProtocolCycle(), 1000);
            return;
          }

          // ===== ADD 30-MINUTE TIMER FOR DISPATCH "YES" =====
if (dispatchDecision === "yes") {
  console.log("DEBUG: Dispatch YES - Setting dispatchMade = true");
  dispatchMade = true;
  window.dispatchMade = true;
  if (window.protocolState) {
    window.protocolState.dispatchMade = true;
  }
  
  const serviceDropdown = document.getElementById("service-type");
  const serviceName = serviceDropdown
    ? serviceDropdown.options[serviceDropdown.selectedIndex]?.text ||
      "Emergency Services"
    : "Emergency Services";

  // Start 30-minute dispatch follow-up timer
  if (typeof startGlobalTimer === "function") {
    startGlobalTimer(stepId, "Dispatch Follow-up", serviceName, 1800);
    addLogEntry(
      `⏰ Started 30-minute dispatch follow-up timer for ${serviceName}`,
      "timer"
    );

    // Disable only the Post Note button
    const postBtn = document.getElementById(stepId + "-post-btn");
    if (postBtn) {
      postBtn.disabled = true;
      postBtn.classList.remove("btn-success");
      postBtn.classList.add("btn-secondary");
    }

    // Set step status to "Waiting" after other processing completes
    setTimeout(() => {
      const statusBadge = document.getElementById(stepId + "-status");
      if (statusBadge) {
        statusBadge.textContent = "Waiting";
        statusBadge.className = "status-badge waiting";
        statusBadge.style.background = "#ffc107";
        statusBadge.style.color = "#000";
      }
    }, 200);

    // Scroll to timer
    setTimeout(() => {
      const timerElement = document.getElementById("globalTimer");
      if (timerElement) {
        timerElement.scrollIntoView({
          behavior: "smooth",
          block: "center",
        });
      }
    }, 100);

    // Ensure callback section stays active
    const callbackDropdown = document.querySelector(
      'select[data-cy="global-cancel-dropdown"]'
    );
    if (callbackDropdown) {
      callbackDropdown.disabled = false;
    }
  }
} else {
  // CRITICAL FIX: Explicitly set dispatch flags to false for "no" or empty decisions
  console.log("DEBUG: Dispatch NO/empty - Setting dispatchMade = false");
  dispatchMade = false;
  window.dispatchMade = false;
  if (window.protocolState) {
    window.protocolState.dispatchMade = false;
  }
}
          // Ensure callback section stays fully active
          setTimeout(() => {
            // Enable the callback dropdown
            const callbackDropdown = document.querySelector(
              'select[data-cy="global-cancel-dropdown"]'
            );
            if (callbackDropdown) {
              callbackDropdown.disabled = false;
              callbackDropdown.style.opacity = "1";
              callbackDropdown.style.pointerEvents = "auto";
            }

            // Also try alternative selectors in case the dropdown has a different structure
            const allSelects = document.querySelectorAll(
              "#" + stepId + " select"
            );
            allSelects.forEach((select) => {
              // Only enable selects that are NOT the dispatch decision or service type
              if (
                !select.id.includes("dispatch-decision") &&
                !select.id.includes("service-type")
              ) {
                select.disabled = false;
                select.style.opacity = "1";
                select.style.pointerEvents = "auto";
              }
            });
          }, 300); // Longer delay to ensure it runs after all other processing

          // Clear dispatch form fields AFTER timer starts
          setTimeout(() => {
            // Clear "Dispatch conditions met?" dropdown
            const dispatchDecision =
              document.getElementById("dispatch-decision");
            if (dispatchDecision) {
              dispatchDecision.value = "";
              dispatchDecision.disabled = true;
            }

            // Clear "Dispatch Service Type:" dropdown
            const serviceDropdown = document.getElementById("service-type");
            if (serviceDropdown) {
              serviceDropdown.value = "";
            }

            // Update UI visibility
            const serviceContainer = document.getElementById(
              "service-type-container"
            );
            if (serviceContainer) {
              serviceContainer.style.display = "none";
            }

            const skipContainer = document.getElementById(
              "skip-reason-container"
            );
            if (skipContainer) {
              skipContainer.style.display = "block";
            }
          }, 400); // After all other processing completes
        }

        // Legacy unable-to-dispatch outcome
        if (
          (currentStep && currentStep.action === "dispatch") ||
          (["step-4", "step-5"].includes(stepId) &&
            selectedOutcome === "unable-to-dispatch")
        ) {
          if (selectedOutcome === "unable-to-dispatch") {
            let msg;
            try {
              msg = generateDispatchProtocolLog("no", actionText, "", stepId);
            } catch (e) {
              msg = `${stepLabel}${
                actionLabel ? ` (${actionLabel})` : ""
              }: ${actionText}.`;
            }
            if (!msg.endsWith(".")) msg += ".";
            msg += `\n\n${CYCLE_TEXT}`;
            logStep(msg);

            markStepCompleted(); // Uses closure - no parameter
            resetFormInputs();

            if (typeof silentlyUpdateDispatchConditions === "function") {
              silentlyUpdateDispatchConditions();
              requestAnimationFrame(silentlyUpdateDispatchConditions);
            }

            setTimeout(() => restartProtocolCycle(), 1000);
            return;
          }
        }

        // NORMAL PROCESSING
        let body = (actionText || "").trim();

        // Special cases for "Unable to call" patterns
        if (/^unable to call\b/i.test(body)) {
          if (currentStep?.action === "call-device") {
            body = `Attempted to call device. ${body.replace(
              /^unable to call\s*[:,]?\s*/i,
              "Unable to call, "
            )}`;
          } else if (currentStep?.action === "call-user") {
            body = `Attempted to call user. ${body.replace(
              /^unable to call\s*[:,]?\s*/i,
              "Unable to call, "
            )}`;
          }
        }

        // Handle inbound callbacks
        const inboundCb =
          /^\s*(user called in|ec called in|emergency contact called in|callback received)\b/i.test(
            body
          );

        if (
          currentStep?.action === "call-device" &&
          !/^called device\b/i.test(body) &&
          !/^attempted to call device\b/i.test(body) &&
          !inboundCb
        ) {
          body = `Called device. ${body.charAt(0).toUpperCase()}${body.slice(
            1
          )}`;
        }

        // Emergency contact ordinal injection
        if (currentStep?.action === "call-emergency-contacts") {
          console.log("DEBUG EC TRANSFORM: Original body =", body);

          const ecOrdinal = (() => {
            if (Number.isInteger(currentStep?.meta?.ecIndex))
              return currentStep.meta.ecIndex;
            const el = document.getElementById(stepId);
            if (el && el.parentElement) {
              const cfg = ProtocolFactory.getProtocolConfig(currentAlert.id);
              const siblings = Array.from(
                el.parentElement.querySelectorAll('[id^="step-"]')
              ).filter(
                (n) =>
                  (cfg?.steps || []).find((xx) => xx.id === n.id)?.action ===
                  "call-emergency-contacts"
              );
              const idx = siblings.indexOf(el);
              if (idx >= 0) return idx + 1;
            }
            const m = String(stepId).match(/step-\d+-(\d+)/i);
            return m ? parseInt(m[1], 10) : 1;
          })();

          // Get emergency contact details
          const getECDetails = (index) => {
            if (
              currentUser?.emergencyContacts &&
              currentUser.emergencyContacts[index - 1]
            ) {
              const contact = currentUser.emergencyContacts[index - 1];
              return { name: contact.name, phone: contact.phone };
            }
            return { name: "emergency contact", phone: "" };
          };

          const ecDetails = getECDetails(ecOrdinal);
          console.log("DEBUG EC TRANSFORM: ecOrdinal =", ecOrdinal);
          console.log("DEBUG EC TRANSFORM: ecDetails =", ecDetails);

          // Check for inbound calls first - remove prefix and handle skipping
          if (/called in/i.test(body)) {
            // Remove "Emergency Contact X:" prefix for inbound calls
            body = body.replace(/^emergency contact \d+:\s*/i, "");

            // Handle resolution and skipping for confirmed okay inbound calls
            if (
              /emergency contact called in and confirmed.*is okay/i.test(body)
            ) {
              const mainStepId = stepId.split("-").slice(0, 2).join("-"); // "step-4"
              const currentSubStep = parseInt(stepId.split("-")[2], 10); // 1

              // Skip remaining sub-steps
              for (let i = currentSubStep + 1; i <= 10; i++) {
                const nextSubStepId = `${mainStepId}-${i}`;
                const nextSubStep = document.getElementById(nextSubStepId);
                if (nextSubStep) {
                  nextSubStep.style.opacity = "0.5";
                  nextSubStep.style.pointerEvents = "none";
                  const statusBadge = document.getElementById(
                    nextSubStepId + "-status"
                  );
                  if (statusBadge) {
                    statusBadge.textContent = "Skipped";
                    statusBadge.className = "status-badge skipped";
                    statusBadge.style.background = "#6c757d";
                    statusBadge.style.color = "white";
                  }
                }
              }

              // Complete main step
              const mainStep = document.getElementById(mainStepId);
              if (mainStep) {
                const mainStatusBadge = document.getElementById(
                  mainStepId + "-status"
                );
                if (mainStatusBadge) {
                  mainStatusBadge.textContent = "Completed";
                  mainStatusBadge.className = "status-badge completed";
                }
              }

              // Skip subsequent main steps
              const currentMainStepNum = parseInt(mainStepId.split("-")[1], 10); // 4
              for (let i = currentMainStepNum + 1; i <= 10; i++) {
                const nextMainStepId = `step-${i}`;
                const nextMainStep = document.getElementById(nextMainStepId);
                if (nextMainStep) {
                  nextMainStep.style.opacity = "0.5";
                  nextMainStep.style.pointerEvents = "none";
                  const statusBadge = document.getElementById(
                    nextMainStepId + "-status"
                  );
                  if (statusBadge) {
                    statusBadge.textContent = "Skipped";
                    statusBadge.className = "status-badge skipped";
                    statusBadge.style.background = "#6c757d";
                    statusBadge.style.color = "white";
                  }
                }
              }
            }
          } else if (
            (/^called\s+emergency contact/i.test(body) ||
              /^emergency contact \d+:/i.test(body) ||
              /^called\s+[A-Za-z\s]+\s+at\s+\+/i.test(body)) && // NEW: Match "Called Name at +phone"
            !/^called\s+EC\d+\b/i.test(body) &&
            !/called in/i.test(body)
          ) {
            // Handle outbound calls - add EC details
            if (/^emergency contact \d+:/i.test(body)) {
              // Remove the prefix and any existing "Called [name] at [phone]" part
              body = body.replace(/^emergency contact \d+:\s*/i, "");
              body = body.replace(/^called\s+[^.]+at\s+\+[^.]+\.\s*/i, "");
              body = `Called EC${ecOrdinal} ${ecDetails.name} at ${ecDetails.phone}. ${body}`;
            } else if (/^called\s+[A-Za-z\s]+\s+at\s+\+/i.test(body)) {
              // NEW: Handle "Called Name at +phone" format
              body = body.replace(/^called\s+/i, `Called EC${ecOrdinal} `);
            } else {
              body = body.replace(
                /^called\s+/i,
                `Called EC${ecOrdinal} ${ecDetails.name} at ${ecDetails.phone}. `
              );
            }
            // Clean up any redundant text
            body = body.replace(/\s*emergency contact[.,]?\s*/gi, ". ");
            body = body.replace(/\.\s*\./g, ".");
          }
        }

        if (!/[.!?]$/.test(body)) body += ".";

        // Add gas data for emergency contact resolving outcomes
        if (
          window.isGasAlert?.(currentAlert) &&
          currentStep?.action === "call-emergency-contacts" &&
          (/confirmed.*okay/i.test(body) ||
            /confirmed user is okay/i.test(body)) &&
          !/Gas Type:\\s/i.test(body) &&
          !/Gas Reading:\\s/i.test(body) &&
          !/⚠️ Gas levels still HIGH/i.test(body)
        ) {
          console.log("🔵 POSTNOTE: Adding gas data to body");
          const gasBlockRaw =
            typeof getGasSnapshotFromPanel === "function"
              ? getGasSnapshotFromPanel()
              : "";

          if (gasBlockRaw) {
            const now = new Date();
            const ts =
              typeof FORMATTERS?.timestampMST === "function"
                ? FORMATTERS.timestampMST(now)
                : new Intl.DateTimeFormat("en-US", {
                    timeZone: "America/Denver",
                    year: "numeric",
                    month: "2-digit",
                    day: "2-digit",
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit",
                    hour12: false,
                  }).format(now) + " MDT";

            const gasBlockWithTs = gasBlockRaw.replace(
              /(Gas Reading:\s*[^\n]+)/i,
              `$1 (${ts})`
            );

            const gasStillHigh =
              typeof isAnyGasDangerousNow === "function"
                ? isAnyGasDangerousNow()
                : !isGasCurrentlyNormalized();

            if (gasStillHigh) {
              const warningText = "⚠️ Gas levels still HIGH.";
              body += `\n\n${warningText}\n\n${gasBlockWithTs}`;
            } else {
              // Insert "Gas readings back to normal." into the main sentence
if (!/Gas readings back to normal/i.test(body)) {
  body = body.replace(/resolving alert\./i, "Gas readings back to normal. Resolving alert.");
}
// Add gas data block separately without preface
body += `\n\n${gasBlockWithTs}`;
            }
          }
        }

        // Don't add step label for inbound calls
        const isDirectLog =
          /called in/i.test(body) ||
          /^received message.*from device/i.test(body) ||
          /^user called in/i.test(body) ||
          /^emergency contact called in/i.test(body);
        let msg = isDirectLog ? body : `${stepLabel}: ${body}`;

        // Resolving outcome handling
        const RESOLVING_OUTCOMES = new Set([
          "confirmed-ok",
          "user-callback",
          "ec-callback",
          "device-no",
          "issue-resolved",
          "false-alarm",
          "im-ok",
        ]);
        const isResolvingOutcome =
          RESOLVING_OUTCOMES.has(selectedOutcome) ||
          /emergency contact called in and confirmed.*is okay/i.test(body) ||
          /user called in.*confirmed they are okay/i.test(body);
        let suppressResolutionFlow = false;

        if (isResolvingOutcome) {
          if (isGas) {
            const U = (id) =>
              (document.getElementById(id)?.textContent || "").toUpperCase();
            const dangerO2 = /ENRICHED|ENRICHMENT|DEPLETED|DEPLETION/.test(
              U("o2-status")
            );
            const dangerOthers =
              /\bHIGH\b/.test(U("h2s-status")) ||
              /\bHIGH\b/.test(U("co-status")) ||
              /\bHIGH\b/.test(U("lel-status"));
            const normalized = !(dangerO2 || dangerOthers);
            console.log("DEBUG NORMALIZED dangerO2:", dangerO2);
            console.log("DEBUG NORMALIZED dangerOthers:", dangerOthers);
            console.log("DEBUG NORMALIZED normalized:", normalized);
            console.log("DEBUG NORMALIZED o2Status:", U("o2-status"));
            console.log("DEBUG NORMALIZED h2sStatus:", U("h2s-status"));
            if (normalized) {
  if (!/[.?!]$/.test(msg)) msg += ".";

  // Check textarea content for gas data instead of msg
  const noteValue =
    document.getElementById(stepId + "-note")?.value || "";
  if (!/Gas Type:|Gas Reading:/i.test(noteValue)) {
    let block = "";
    try {
      block =
        typeof getGasSnapshotFromPanel === "function"
          ? getGasSnapshotFromPanel()
          : "";
      if (block) {
        const now = new Date();
        const ts =
          typeof FORMATTERS?.timestampMST === "function"
            ? FORMATTERS.timestampMST(now)
            : new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Denver",
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                hour12: false,
              }).format(now) + " MDT";
        block = block.replace(
          /(Gas Reading:\s*[^\n]+)/i,
          `$1 (${ts})`
        );
      }
    } catch {}
    
    // Add gas normalization text before "Resolving alert."
    if (!/Gas readings back to normal/i.test(msg)) {
      const alreadyHasResolving = /resolving alert/i.test(msg);
      if (alreadyHasResolving) {
        // Insert "Gas readings back to normal." before existing "Resolving alert."
        msg = msg.replace(/(\s*)resolving alert\.?/i, " Gas readings back to normal. Resolving alert.");
      } else {
        // Add gas normalization text
        msg += " Gas readings back to normal.";
      }
    }

    // Add gas data block if available
    if (block) {
      msg += `\n\n${block}`;
    }
  } else {
    // Textarea already contains gas data, just add normalization text if needed
    if (!/Gas readings back to normal/i.test(msg)) {
      const alreadyHasResolving = /resolving alert/i.test(msg);
      if (alreadyHasResolving) {
        msg = msg.replace(/(\s*)resolving alert\.?/i, " Gas readings back to normal. Resolving alert.");
      } else {
        msg += " Gas readings back to normal.";
      }
    }
  }
} else {
  if (!/[.?!]$/.test(msg)) msg += ".";
  suppressResolutionFlow = true;

              const resSection =
                document.querySelector(".resolution-section") ||
                document.getElementById("resolution-section") ||
                document.querySelector('[data-cy="resolution-section"]');
              resSection?.scrollIntoView({
                behavior: "smooth",
                block: "start",
              });

              const resolutionSelect =
                document.getElementById("resolution-reason");
              if (resolutionSelect && !resolutionSelect.value) {
                resolutionSelect.value = "incident-without-dispatch";
              }

              const resolveBtn =
                document.getElementById("resolve-alert-btn") ||
                document.querySelector('[data-cy="resolve-alert-btn"]');
              if (resolveBtn) {
                resolveBtn.disabled = false;
                resolveBtn.focus();
              }

              if (
                currentAlert?.gasNormalization?.enabled &&
                currentAlert.gasNormalization.triggerAfterStep === stepId &&
                !currentAlert._norm
              ) {
                currentAlert._norm = 1;
                setTimeout(() => triggerGasNormalization(currentAlert), 3000);
              }

              msg = msg.replace(/\s*Resolving alert\.?/gi, "");
              if (typeof _squashResolveLine === "function")
                msg = _squashResolveLine(msg);

              logStep(msg);
              markStepCompleted(); // Uses closure - no parameter
              resetFormInputs();
              return;
            }
          } else {
            if (!/resolving alert/i.test(msg)) {
              if (!/[.?!]$/.test(msg)) msg += ".";
              msg += " Resolving alert.";
            }
          }
        }

        if (typeof _squashResolveLine === "function")
          msg = _squashResolveLine(msg);
        logStep(msg);

        // Timer logic for EC callback
        if (
          selectedOutcome === "ec-callback-30min" ||
          selectedOutcome === "ec-callback-30min-outbound"
        ) {
          if (typeof startGlobalTimer === "function") {
            startGlobalTimer(stepId, "EC Callback", "Emergency Contact", 1800);

            const statusBadge = document.getElementById(stepId + "-status");
            if (statusBadge) {
              statusBadge.textContent = "Waiting";
              statusBadge.className = "status-badge waiting";
            }

            resetFormInputs();
            return; // Exit early - don't mark completed
          }
        }

        markStepCompleted(); // Uses closure - no parameter
        resetFormInputs();

        const isConfirmedOK = isResolvingOutcome;
        if (isConfirmedOK && !suppressResolutionFlow) {
          triggerResolutionFlow(stepId, "User confirmed okay");
          if (typeof silentlyUpdateDispatchConditions === "function") {
            silentlyUpdateDispatchConditions();
            requestAnimationFrame(silentlyUpdateDispatchConditions);
          }
          return;
        }

        // Sub-step progression
        if (stepId.includes("-") && stepId.split("-").length === 3) {
          const parts = stepId.split("-");
          const mainStepId = `${parts[0]}-${parts[1]}`;
          const subStepNum = parseInt(parts[2], 10);

          const mainStep = protocolConfig.steps.find(
            (s) => s.id === mainStepId
          );
          if (mainStep && mainStep.action === "combined-device-user-call") {
            console.log("Combined step logic triggered");
            console.log("stepId:", stepId);
            console.log("mainStepId:", mainStepId);
            console.log("selectedOutcome:", selectedOutcome);

            if (
              selectedOutcome === "no-answer" ||
              selectedOutcome === "unable-to-call"
            ) {
              const nextSubStepId = `${mainStepId}-${subStepNum + 1}`;
              const nextSubStep = document.getElementById(nextSubStepId);
              console.log("nextSubStepId:", nextSubStepId);
              console.log("nextSubStep exists:", !!nextSubStep);

              if (nextSubStep) {
                const nextButton = nextSubStep.querySelector(
                  'button:not([onclick*="postNote"])'
                );
                if (nextButton) {
                  nextButton.disabled = false;
                  nextButton.classList.remove("btn-secondary");
                  nextButton.classList.add("btn-primary");
                }
                return;
              } else {
                console.log("No next substep, marking main step completed");
                markStepCompleted(mainStepId);
                enableNextStep(mainStepId);
                return;
              }
            }
            console.log("Non-no-answer outcome, marking main step completed");
            markStepCompleted(mainStepId);
            enableNextStep(mainStepId);
            return;
          } else if (
            mainStep &&
            mainStep.action === "call-emergency-contacts"
          ) {
            if (
              [
                "no-answer",
                "no-answer-voicemail",
                "no-answer-unable",
                "unable-to-connect",
                "wrong-number",
                "number-invalid",
              ].includes(selectedOutcome)
            ) {
              const nextSubStepId = `${mainStepId}-${subStepNum + 1}`;
              const nextSubStep = document.getElementById(nextSubStepId);
              if (nextSubStep) {
                const nextButton = nextSubStep.querySelector(
                  'button:not([onclick*="postNote"])'
                );
                if (nextButton) {
                  nextButton.disabled = false;
                  nextButton.classList.remove("btn-secondary");
                  nextButton.classList.add("btn-primary");
                }
                return;
              } else {
                markStepCompleted(mainStepId); // GLOBAL function call - needs parameter
                enableNextStep(mainStepId);
                return;
              }
            }
            markStepCompleted(mainStepId); // GLOBAL function call - needs parameter
            enableNextStep(mainStepId);
            return;
          }
        }

        // Normal progression
        enableNextStep(stepId);
        if (typeof silentlyUpdateDispatchConditions === "function") {
          silentlyUpdateDispatchConditions();
          requestAnimationFrame(silentlyUpdateDispatchConditions);
        }

        // Gas normalization trigger
        if (
          currentAlert?.gasNormalization?.enabled &&
          currentAlert.gasNormalization.triggerAfterStep === stepId &&
          !currentAlert._norm
        ) {
          currentAlert._norm = 1;
          setTimeout(() => triggerGasNormalization(currentAlert), 3000);
        }

        // ===== ADD 30-MINUTE TIMER FOR DISPATCH "YES" =====
        const decisionEl = document.getElementById("dispatch-decision");
        const dispatchDecision = decisionEl ? decisionEl.value : "";
      }

      function markStepCompleted(stepId) {
        const step = document.getElementById(stepId);
        const statusBadge = document.getElementById(stepId + "-status");

        if (step) {
          step.classList.add("completed");
          step.classList.remove("active");
          step.style.opacity = "0.8";

          const actionButton = step.querySelector(
            'button:not([onclick*="postNote"])'
          );
          if (actionButton) {
            actionButton.disabled = true;
            actionButton.classList.remove("btn-primary");
            actionButton.classList.add("btn-secondary");
          }

          step
            .querySelectorAll("select")
            .forEach((select) => (select.disabled = true));
        }

        // ✅ PROPER BADGE CLASS HANDLING - This fixes the yellow badge issue
        if (statusBadge) {
          statusBadge.textContent = "Completed";
          statusBadge.className = "status-badge completed"; // Clean replacement of all classes
        }

        if (!window.protocolState) window.protocolState = {};
        if (!Array.isArray(protocolState.completedSteps))
          protocolState.completedSteps = [];
        if (!protocolState.completedSteps.includes(stepId))
          protocolState.completedSteps.push(stepId);

        if (typeof enableNextStep === "function") {
          enableNextStep(stepId);
        }
      }

      function blockRemainingSteps(currentStepId, reason) {
        console.log(
          "=== blockRemainingSteps called with:",
          currentStepId,
          "reason:",
          reason
        );

        // Special handling for sub-steps (like step-3-1, step-4-1, etc.)
        if (
          currentStepId.includes("-") &&
          currentStepId.split("-").length === 3
        ) {
          console.log("=== Handling sub-step:", currentStepId);

          // Dynamically split any sub-step into parts
          const parts = currentStepId.split("-"); // ["step", "3", "1"] or ["step", "4", "1"]
          const mainStep = parts[0] + "-" + parts[1]; // "step-3" or "step-4"
          const subStep = parts[2]; // "1"

          console.log("mainStep:", mainStep, "subStep:", subStep);

          // Skip remaining sub-steps of the same main step
          const allSubSteps = document.querySelectorAll(`[id^="${mainStep}-"]`);
          console.log(
            "Found sub-steps:",
            Array.from(allSubSteps).map((el) => el.id)
          );

          allSubSteps.forEach((step) => {
            const stepParts = step.id.split("-");
            if (stepParts.length >= 3) {
              // Ensure it's actually a sub-step like step-3-2 or step-4-2
              const subStepNum = parseInt(stepParts[2]);
              const currentSubNum = parseInt(subStep);

              console.log(
                "Checking sub-step:",
                step.id,
                "subStepNum:",
                subStepNum,
                "vs currentSubNum:",
                currentSubNum
              );

              if (subStepNum > currentSubNum) {
                console.log("SKIPPING sub-step:", step.id);
                // Hide the dropdown for skipped steps
                const outcomeSection = document.getElementById(
                  step.id + "-outcome"
                );
                if (outcomeSection) {
                  outcomeSection.style.display = "none";
                }
                const status = document.getElementById(step.id + "-status");
                if (status) {
                  status.textContent = "Skipped. User confirmed OK.";
                  status.className = "status-badge";
                  status.style.background = "#6c757d";
                  status.style.color = "white";
                  status.style.animation = "none";
                  status.style.transition = "none";
                  status.classList.remove(
                    "completed",
                    "active",
                    "pulsing",
                    "timer-active",
                    "timer-alert"
                  );
                }
                step.style.opacity = "0.5";
                step.classList.remove("active");
              }
            }
          });

          // ALSO mark the main step as completed when resolving from a sub-step
          const mainStepId = mainStep; // Already calculated above

          console.log("Marking main step as completed:", mainStepId);

          const mainStepElement = document.getElementById(mainStepId);
          const mainStatus = document.getElementById(mainStepId + "-status");

          if (mainStepElement) {
            mainStepElement.classList.remove("active");
            mainStepElement.classList.add("completed");
          }

          if (mainStatus) {
            mainStatus.textContent = "Completed";
            mainStatus.className = "status-badge completed";
            mainStatus.style.animation = "none";
            mainStatus.style.transition = "none";
          }
        }

        // Get all steps after current one, including sub-steps
        const allSteps = document.querySelectorAll(".step");
        const currentIndex = parseInt(
          currentStepId.replace(/step-(\d+).*/, "$1")
        );

        console.log("currentIndex extracted:", currentIndex);

        allSteps.forEach((step) => {
          if (step.id && step.id.startsWith("step-")) {
            const stepIndex = parseInt(step.id.replace(/step-(\d+).*/, "$1"));

            console.log(
              "Processing step:",
              step.id,
              "stepIndex:",
              stepIndex,
              "vs currentIndex:",
              currentIndex
            );

            // Skip steps that come after the current step
            if (stepIndex > currentIndex) {
              console.log("SKIPPING main step:", step.id);
              // Hide the dropdown for skipped steps
              const outcomeSection = document.getElementById(
                step.id + "-outcome"
              );
              if (outcomeSection) {
                outcomeSection.style.display = "none";
              }
              const nextStatus = document.getElementById(step.id + "-status");

              step.style.opacity = "0.5";
              step.classList.remove("active");

              const nextButton = step.querySelector(
                'button:not([onclick*="postNote"])'
              );
              if (
                nextButton &&
                !nextButton.onclick.toString().includes("callDispatch")
              ) {
                nextButton.disabled = true;
                nextButton.classList.remove("btn-primary");
                nextButton.classList.add("btn-secondary");
                nextButton.style.pointerEvents = "none";
              }

              // Keep the textarea and post note button enabled
              const textarea = document.getElementById(step.id + "-note");
              const postBtn = document.getElementById(step.id + "-post-btn");

              if (textarea) {
                textarea.disabled = false;
                textarea.style.pointerEvents = "auto";
              }

              if (postBtn) {
                postBtn.style.pointerEvents = "auto";
                validatePostButton(step.id);
              }

              if (nextStatus) {
                nextStatus.textContent = "Skipped. User confirmed OK.";
                nextStatus.className = "status-badge";
                nextStatus.style.background = "#6c757d";
                nextStatus.style.color = "white";
                nextStatus.style.animation = "none";
                nextStatus.style.transition = "none";
                nextStatus.classList.remove(
                  "completed",
                  "active",
                  "pulsing",
                  "timer-active",
                  "timer-alert"
                );
              }
            }
          }
        });
      }

      function isGasLevelHigh() {
        const h2sStatus = document.getElementById("h2s-status");
        return h2sStatus && h2sStatus.textContent === "HIGH";
      }

      // ADD THIS NEW FUNCTION RIGHT HERE:
      function isGasAlert(alert) {
        if (!alert || !alert.id) return false;

        // Check for gas-related alert IDs
        const gasAlertIds = [
          "gas-high-threshold",
          "h2s-response",
          "h2s-high",
          "co-response",
          "co-high",
          "lel-response",
          "lel-high",
          "o2-response",
          "o2-high",
          "o2-low",
        ];

        return (
          gasAlertIds.includes(alert.id) ||
          alert.id.includes("gas") ||
          alert.id.includes("h2s") ||
          alert.id.includes("co") ||
          alert.id.includes("lel") ||
          alert.id.includes("o2")
        );
      }

      function getCurrentGasReading() {
        const gasTypes = [
          { id: "h2s", type: "H₂S", unit: " ppm" },
          { id: "co", type: "CO", unit: " ppm" },
          { id: "o2", type: "O₂", unit: " %vol" },
          { id: "lel", type: "LEL", unit: " %LEL" },
        ];

        // First try to get the alert-specific gas type
        if (currentAlert && currentAlert.gasType) {
          const alertGasType = currentAlert.gasType.toLowerCase();
          let targetGasId = "h2s"; // default

          if (alertGasType.includes("co")) targetGasId = "co";
          else if (alertGasType.includes("o2")) targetGasId = "o2";
          else if (alertGasType.includes("lel")) targetGasId = "lel";

          const valueElement = document.getElementById(`${targetGasId}-value`);
          const statusElement = document.getElementById(
            `${targetGasId}-status`
          );

          if (valueElement && statusElement) {
            const gasType = gasTypes.find((g) => g.id === targetGasId);
            return {
              type: gasType.type,
              value: valueElement.textContent.split(" ")[0],
              unit: gasType.unit,
              status: statusElement.textContent.trim(),
            };
          }
        }

        // Fallback: Check all gas types for dangerous readings
        for (const gas of gasTypes) {
          const valueElement = document.getElementById(`${gas.id}-value`);
          const statusElement = document.getElementById(`${gas.id}-status`);

          if (valueElement && statusElement) {
            const status = statusElement.textContent.trim();

            // Return data for any gas that's not NORMAL
            if (status !== "NORMAL") {
              const valueText = valueElement.textContent;
              const value = valueText.split(" ")[0]; // Extract number part

              return {
                type: gas.type,
                value: value,
                unit: gas.unit,
                status: status,
              };
            }
          }
        }

        // Fallback - return first available gas or default H₂S
        const h2sValueElement = document.getElementById("h2s-value");
        const h2sStatusElement = document.getElementById("h2s-status");

        if (h2sValueElement && h2sStatusElement) {
          const h2sReading = h2sValueElement.textContent;
          const h2sStatus = h2sStatusElement.textContent;

          return {
            type: "H₂S",
            value: h2sReading.split(" ")[0],
            unit: " ppm",
            status: h2sStatus,
          };
        }

        // Final fallback
        return {
          type: "H₂S",
          value: "17.90",
          unit: " ppm",
          status: "HIGH",
        };
      }

      function completeResolution(reason, overrideReason) {
        stopDynamicAlertTime();

        // Cancel any active timer when resolving alert
        cancelGlobalTimer();

        // Simple resolution log based on whether it's an override or normal
        if (overrideReason) {
          addLogEntry(
            "Alert resolved (Override: " + overrideReason + ")",
            "resolution"
          );
        } else {
          addLogEntry("Alert resolved.", "resolution");
        }

        // Mark resolution as complete
        const resolutionBadge = document.querySelector(
          ".resolution-section .status-badge"
        );
        if (resolutionBadge) {
          resolutionBadge.textContent = "Completed";
          resolutionBadge.classList.add("completed");
        }

        // Disable and update the resolve button
        const resolveButton = document.querySelector(
          ".resolution-section .btn-danger"
        );
        if (resolveButton) {
          resolveButton.disabled = true;
          resolveButton.classList.remove("btn-danger");
          resolveButton.classList.add("btn-secondary");
          resolveButton.textContent = "✅ Alert Resolved";
        }

        // Scroll to top to show the resolution log
        setTimeout(() => {
          window.scrollTo({
            top: 0,
            behavior: "smooth",
          });
        }, 100);
      }

      function resolveAlert(stepId) {
        stopDynamicAlertTime();

        // ⛔️ Guard first: Gas alert + any dangerous reading → force override modal
        if (
          typeof isGasAlert === "function" &&
          isGasAlert(currentAlert) &&
          (typeof isAnyGasDangerousNow === "function"
            ? isAnyGasDangerousNow()
            : typeof isGasLevelHigh === "function"
            ? isGasLevelHigh()
            : false)
        ) {
          // Prefer programmatic opener; fallback to button
          if (typeof openResolutionOverrideModal === "function") {
            openResolutionOverrideModal({ stepId, gas: "GAS HIGH" });
          } else if (typeof showOverrideModal === "function") {
            showOverrideModal();
          } else {
            (
              document.getElementById("override-resolution-btn") ||
              document.querySelector('[data-cy="override-resolution-btn"]')
            )?.click();
          }

          // Optional: focus the modal's reason select right away
          requestAnimationFrame(() => {
            (
              document.getElementById("override-reason") ||
              document.querySelector('[data-cy="override-reason"]')
            )?.focus();
          });
          return; // Modal will handle confirm → then call completeResolution(...)
        }

        // --- Existing logic (unchanged) ---
        const reasonSelect = document.querySelector(
          ".resolution-section select"
        );
        let reason = reasonSelect ? reasonSelect.value : "";

        // If no resolution reason selected, auto-determine it
        if (!reason) {
          reason =
            typeof determineResolutionType === "function"
              ? determineResolutionType(currentAlert)
              : "resolved";
          if (reasonSelect) {
            reasonSelect.value = reason;
          }
        }

        // LOCK UI: Disable and grey-out all elements except Cancel Resolution and Add Note
        lockUIForResolution();

        completeResolution(reason);
      }

      // REPLACE THE cancelResolution FUNCTION WITH THIS FIXED VERSION:
      function cancelResolution() {
        console.log("Cancel Resolution clicked");

        // Add log entry
        addLogEntry(`❌ Resolution cancelled by operator`, "general");

        // Reset resolution dropdown
        const resolutionSelect =
          document.getElementById("resolution-reason") ||
          document.querySelector(".resolution-section select");
        if (resolutionSelect) {
          resolutionSelect.value = "";
          resolutionSelect.disabled = false;
          resolutionSelect.style.opacity = "1";
        }

        // ALWAYS re-enable Resolve Alert button (this is the key fix)
        const resolveButton = document.querySelector(
          ".resolution-section .btn-danger"
        );
        if (resolveButton) {
          resolveButton.disabled = false;
          resolveButton.classList.remove("btn-secondary");
          resolveButton.classList.add("btn-danger");
          resolveButton.style.opacity = "1";
          resolveButton.textContent = "✅ Resolve Alert";
        }

        // Reset resolution status badge
        const resolutionBadge = document.querySelector(
          ".resolution-section .status-badge"
        );
        if (resolutionBadge) {
          resolutionBadge.textContent = "Pending";
          resolutionBadge.classList.remove("completed");
        }

        // Unlock UI that was locked by lockUIForResolution()
        unlockUIForResolution();

        // CRITICAL FIX: Ensure resolution section stays active after unlock
        const resolutionSection = document.querySelector(".resolution-section");
        if (resolutionSection) {
          resolutionSection.style.removeProperty("opacity");
          resolutionSection.style.removeProperty("pointer-events");
        }

        // FORCE resolution button to stay enabled (override any unlock logic)
        setTimeout(() => {
          const resolveBtn = document.querySelector(
            ".resolution-section .btn-danger"
          );
          if (resolveBtn) {
            resolveBtn.disabled = false;
            resolveBtn.style.opacity = "1";
          }
        }, 50);

        // Reset protocol state
        protocolState.alertResolved = false;
      }

      function unlockUIForResolution() {
        // Reset all step status badges to initial state
        const allStatusBadges = document.querySelectorAll(
          ".step .status-badge"
        );
        allStatusBadges.forEach((badge, index) => {
          const parentStep = badge.closest(".step");
          const stepId = parentStep ? parentStep.id : null;

          // Reset badge classes and styles
          badge.classList.remove("completed");
          badge.style.removeProperty("background");
          badge.style.removeProperty("color");

          // First step should be Active, dispatch step should be Active, rest Pending
          const isFirstStep = index === 0 || stepId === "step-1";
          const isDispatchStep =
            parentStep && parentStep.classList.contains("dispatch-step");

          if (isFirstStep || isDispatchStep) {
            badge.textContent = "Active";
            badge.classList.add("active");
            parentStep.classList.add("active");
            parentStep.classList.remove("completed");
          } else {
            badge.textContent = "Pending";
            badge.classList.remove("active");
            parentStep.classList.remove("active", "completed");
          }

          // Remove any animation
          parentStep.style.removeProperty("animation");
        });

        // Re-enable all PROTOCOL steps with initial state styling (EXCLUDE resolution section)
        const protocolSteps = document.querySelectorAll(
          ".step:not(.resolution-section)"
        );
        protocolSteps.forEach((step) => {
          step.style.removeProperty("opacity");
          step.style.removeProperty("pointer-events");

          // Re-enable buttons, selects, and textareas based on initial state
          const buttons = step.querySelectorAll("button");
          const selects = step.querySelectorAll("select");
          const textareas = step.querySelectorAll("textarea");

          // Only enable buttons in active steps
          const isActiveStep = step.classList.contains("active");

          buttons.forEach((btn) => {
            btn.disabled = !isActiveStep;
            if (isActiveStep) {
              btn.classList.remove("btn-secondary");
              btn.classList.add("btn-primary");
            }
          });

          selects.forEach((select) => {
            select.disabled = !isActiveStep;
            select.value = "";
          });

          textareas.forEach((textarea) => {
            textarea.disabled = !isActiveStep;
            textarea.value = "";
          });
        });

        // Re-enable timer controls
        const globalTimer = document.getElementById("globalTimer");
        if (globalTimer) {
          globalTimer.style.removeProperty("opacity");
          globalTimer.style.removeProperty("pointer-events");
          globalTimer.style.removeProperty("filter");
        }

        // Reset step outcome sections
        const stepOutcomes = document.querySelectorAll(".step-outcome");
        stepOutcomes.forEach((outcome) => {
          outcome.style.display = "none";
        });

        // CRITICAL: Resolution section stays completely untouched and active
        const resolutionSection = document.querySelector(".resolution-section");
        if (resolutionSection) {
          resolutionSection.style.removeProperty("opacity");
          resolutionSection.style.removeProperty("pointer-events");

          // Ensure resolution elements stay enabled
          const resolutionElements =
            resolutionSection.querySelectorAll("button, select");
          resolutionElements.forEach((element) => {
            element.disabled = false;
            element.style.opacity = "1";
          });
        }
      }

      function lockUIForResolution() {
        // Handle step statuses when alert is resolved
        const allStatusBadges = document.querySelectorAll(
          ".step .status-badge"
        );
        allStatusBadges.forEach((badge) => {
          if (badge.textContent === "Pending") {
            // Steps that were never started
            badge.textContent = "Skipped. User confirmed OK.";
            badge.classList.add("completed");
            badge.style.background = "#6c757d";
            badge.style.color = "white";

            const parentStep = badge.closest(".step");
            if (parentStep) {
              parentStep.classList.remove("active");
              parentStep.classList.add("completed");
            }
          } else if (badge.textContent === "Waiting") {
            // Steps with active timers that should be marked as completed
            badge.textContent = "Completed";
            badge.classList.add("completed");
            badge.style.background = "#28a745";
            badge.style.color = "white";

            const parentStep = badge.closest(".step");
            if (parentStep) {
              parentStep.classList.remove("active");
              parentStep.classList.add("completed");
              parentStep.style.animation = "none"; // Stop any pulsing
            }
          }
          // Leave 'Completed' steps unchanged - they're already done
        });

        // Disable and grey-out all steps
        const allSteps = document.querySelectorAll(".step");
        allSteps.forEach((step) => {
          // Grey out ALL steps (including completed ones) - use !important to override other styles
          step.style.setProperty("opacity", "0.5", "important");
          step.style.setProperty("pointer-events", "none", "important");

          // Disable all buttons in steps
          const buttons = step.querySelectorAll("button");
          buttons.forEach((btn) => (btn.disabled = true));

          // Disable all dropdowns in steps
          const selects = step.querySelectorAll("select");
          selects.forEach((select) => (select.disabled = true));

          // Disable all textareas in steps
          const textareas = step.querySelectorAll("textarea");
          textareas.forEach((textarea) => (textarea.disabled = true));
        });

        // Disable and grey-out timer controls MORE prominently
        const globalTimer = document.getElementById("globalTimer");
        if (globalTimer) {
          globalTimer.style.opacity = "0.3"; // More greyed out
          globalTimer.style.pointerEvents = "none";
          globalTimer.style.filter = "grayscale(50%)"; // Add grey filter

          const timerDropdown = globalTimer.querySelector("select");
          if (timerDropdown) timerDropdown.disabled = true;
        }

        // Disable resolution dropdown but keep buttons active
        const resolutionSelect = document.querySelector(
          ".resolution-section select"
        );
        if (resolutionSelect) {
          resolutionSelect.disabled = true;
          resolutionSelect.style.opacity = "0.5";
        }

        // Disable "Resolve Alert" button
        const resolveButton = document.querySelector(
          ".resolution-section .btn-danger"
        );
        if (resolveButton) {
          resolveButton.disabled = true;
          resolveButton.style.opacity = "0.5";
        }

        // KEEP ACTIVE: Cancel Resolution button and Add Note section
        const cancelButton = document.querySelector(
          ".resolution-section .btn-secondary"
        );
        if (cancelButton) {
          cancelButton.disabled = false;
          cancelButton.style.opacity = "1";
          cancelButton.style.pointerEvents = "auto";
        }

        // KEEP ACTIVE: Add Note section (but don't grey out Protocol Log section)
        const manualNotes = document.getElementById("manual-notes");
        const addNoteButton = document.querySelector(
          'button[onclick="addManualNote()"]'
        );
        if (manualNotes) {
          manualNotes.disabled = false;
          manualNotes.style.opacity = "1";
        }
        if (addNoteButton) {
          addNoteButton.disabled = false;
          addNoteButton.style.opacity = "1";
          addNoteButton.style.pointerEvents = "auto";
        }
      }

      function showOverrideModal() {
        const gasReading = getCurrentGasReading();
        document.getElementById("overrideGasReading").textContent =
          "Current Gas Reading: " +
          gasReading.type +
          ": " +
          gasReading.value +
          gasReading.unit +
          " (" +
          gasReading.status +
          ")";

        document.getElementById("modalOverlay").style.display = "block";
        document.getElementById("overrideModal").style.display = "block";

        // Enable/disable confirm button based on override reason selection
        const overrideReasonSelect = document.getElementById("override-reason");
        const confirmBtn = document.getElementById("confirmOverrideBtn");

        // Remove any existing event listeners to prevent duplicates
        const newOverrideReasonSelect = overrideReasonSelect.cloneNode(true);
        overrideReasonSelect.parentNode.replaceChild(
          newOverrideReasonSelect,
          overrideReasonSelect
        );

        // Add fresh event listener
        newOverrideReasonSelect.addEventListener("change", function () {
          document.getElementById("confirmOverrideBtn").disabled = !this.value;
        });

        // Reset the select and button state
        newOverrideReasonSelect.value = "";
        confirmBtn.disabled = true;
      }

      // Function 1: Enable button when dropdown changes
      function enableOverrideButton() {
        const overrideReason = document.getElementById("override-reason").value;
        const confirmBtn = document.getElementById("confirmOverrideBtn");

        confirmBtn.disabled = !overrideReason;
      }

      function cancelOverride() {
  // Hide the modal overlay and modal
  document.getElementById("modalOverlay").style.display = "none";
  document.getElementById("overrideModal").style.display = "none";
  
  // Reset the override reason dropdown to empty
  const overrideReasonSelect = document.getElementById("override-reason");
  if (overrideReasonSelect) {
    overrideReasonSelect.value = "";
  }
  
  // Disable the confirm override button
  const confirmBtn = document.getElementById("confirmOverrideBtn");
  if (confirmBtn) {
    confirmBtn.disabled = true;
  }
  
  // No logging - cancelled overrides should not create audit trails
  // The alert remains unresolved and all normal resolution controls stay enabled
  // Specialist can retry the override or continue with normal protocol
}

      // ═══════════════════════════════════════════════════════════════
      // 🎨 UI RENDERING & UPDATE FUNCTIONS
      // ═══════════════════════════════════════════════════════════════

      function updateAlertHeader(alertConfig, userConfig) {
        const alertId = Math.floor(Math.random() * 9000000) + 1000000;
        const alertTime = formatAlertTime(new Date());

        document.getElementById("alert-title").textContent =
          "🚨 Alert Management - " +
          userConfig.name +
          " (" +
          alertConfig.displayName +
          ")";
        document.getElementById("alert-id").textContent = alertId;
        document.getElementById("employee-details").textContent =
          userConfig.name + " (ID: " + userConfig.id + ")";
        document.getElementById("device-details").textContent =
          userConfig.device;
        document.getElementById("mobile-number").textContent =
          userConfig.mobile;
        document.getElementById("alert-time").textContent = alertTime;
        document.getElementById("alert-trigger").textContent =
          alertConfig.displayName;

          if (!window.currentAlert?.isPreAlert) {
          startDynamicAlertTime(new Date());
        }

      }

      function formatAlertTime(alertDate) {
        const now = new Date();
        const diffMinutes = Math.floor((now - alertDate) / 60000);
        const timeStr =
          alertDate.toLocaleDateString("en-US", {
            month: "2-digit",
            day: "2-digit",
            year: "numeric",
          }) +
          " " +
          alertDate.toLocaleTimeString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            hour12: false,
          }) +
          " MDT";
        let timeAgo = "";

        if (diffMinutes === 0) timeAgo = "(just now)";
        else if (diffMinutes === 1) timeAgo = "(1 minute ago)";
        else if (diffMinutes < 60) timeAgo = `(${diffMinutes} minutes ago)`;
        else if (diffMinutes < 1440)
          timeAgo = `(${Math.floor(diffMinutes / 60)} hours ago)`;
        else timeAgo = `(${Math.floor(diffMinutes / 1440)} days ago)`;

        // NEW: Set pre-alert flag if alert is older than 24 hours (1440 minutes)
        if (diffMinutes >= 1440) {
          if (window.currentAlert) {
            window.currentAlert.isPreAlert = true;
          }
        }

        return `${timeStr} ${timeAgo}`;
      }

      function startDynamicAlertTime(alertDate) {
    // Store the alert start time
    alertStartTime = alertDate || new Date();
    
    // Clear any existing interval
    if (alertTimeUpdateInterval) {
        clearInterval(alertTimeUpdateInterval);
    }
    
    // Function to update the display
    function updateAlertTimeDisplay() {
        const alertTimeElement = document.querySelector('[data-cy="alert-time"]');
        if (alertTimeElement && alertStartTime) {
            alertTimeElement.textContent = formatAlertTime(alertStartTime);
        }
    }
    
    // Update immediately
    updateAlertTimeDisplay();
    
    // Set interval to update every second
    alertTimeUpdateInterval = setInterval(updateAlertTimeDisplay, 1000);
}

function stopDynamicAlertTime() {
    if (alertTimeUpdateInterval) {
        clearInterval(alertTimeUpdateInterval);
        alertTimeUpdateInterval = null;
    }
}

      function addAlertSequenceLogs(userConfig) {
        const now = new Date();
        const ackTime = new Date(now.getTime() - 9000);
        const serverTime = new Date(now.getTime() - 18000);
        const deviceTime = new Date(now.getTime() - 18000);

        const formatEDT = function (date) {
          return (
            date.toLocaleTimeString("en-US", {
              hour12: false,
              timeZone: "America/New_York",
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            }) + " EDT"
          );
        };

        addLogEntry(
          "Alert triggered by device.",
          "system",
          "*" + userConfig.company + "*",
          formatEDT(deviceTime)
        );
        addLogEntry(
          "Alert received by server.",
          "system",
          "*" + userConfig.company + "*",
          formatEDT(serverTime)
        );
        addLogEntry(
          "Alert acknowledged.",
          "system",
          "*Blackline Safety Operations Centre*",
          formatEDT(ackTime)
        );
      }

      function addLogEntry(message, type, source, customTime) {
  // 1) Prevent duplicate gas logs within 3s (unchanged)
  if (message && message.includes("Gas Type:") && type === "step") {
    const nowMs = Date.now();
    if (window.lastGasLogTime && nowMs - window.lastGasLogTime < 3000) {
      console.log("DUPLICATE GAS LOG PREVENTED");
      return;
    }
    window.lastGasLogTime = nowMs;
  }

  // Auto-append gas snapshot for device resolution if missing (SAFETY-NET)
  try {
    if (
      type === "step" &&
      /Received '.*' from device, confirming user is okay/i.test(
        message
      ) &&
      !/Gas Type:/i.test(message) &&
      typeof getCurrentGasReading === "function" &&
      window.isGasAlert?.(window.currentAlert || currentAlert) // ← Check both global and local
    ) {
      const tz =
        (window.TIMEZONES && (TIMEZONES.MT || TIMEZONES.MOUNTAIN)) ||
        "America/Edmonton";
      const tOnly =
        window.FORMATTERS && typeof FORMATTERS.timeOnly === "function"
          ? FORMATTERS.timeOnly(new Date(), tz)
          : new Intl.DateTimeFormat("en-CA", {
              timeZone: tz,
              hour12: false,
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            }).format(new Date());
      const r = getCurrentGasReading(); // { type, status, value, unit }
      message += `\n\nGas Type: ${r.type}\nGas Level: ${r.status}\nGas Reading: ${r.type}: ${r.value}${r.unit} (${tOnly} MST)`;
    }
  } catch (e) {}

  // 2) Do not truncate in console; log full length + type
  const msgStr = String(message || "");
  console.log(
    "addLogEntry called (%d chars):",
    msgStr.length,
    msgStr,
    "type:",
    type
  );
  console.trace();

  const logContainer = document.getElementById("protocolLog");
  const placeholder = logContainer.querySelector(".log-placeholder");
  if (placeholder) placeholder.remove();

  const entry = document.createElement("div");
  entry.className = "log-entry " + (type || "general");

  // 3) Timestamp (prefer shared FORMATTERS/TIMEZONES; fallback to en-CA MT)
  const now = new Date();
  const tz = (window.TIMEZONES && TIMEZONES.MT) || "America/Edmonton";
  const timeStr =
    window.FORMATTERS && typeof FORMATTERS.timeOnly === "function"
      ? `${FORMATTERS.timeOnly(now, tz)} MST`
      : new Intl.DateTimeFormat("en-CA", {
          hour12: false,
          timeZone: tz,
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        }).format(now) + " MST";

  let timestamp, operator;
  if (customTime) {
    timestamp = customTime;
    operator = "";
  } else {
    timestamp = timeStr;
    operator = " | Op 417";
  }

  // Optional: unify "Gas readings back to normal. Resolving alert." spacing like postNote
  let safeMessage = msgStr;
  if (typeof _squashResolveLine === "function") {
    safeMessage = _squashResolveLine(safeMessage);
  }

  // 4) Render (formatLogMessage already handles dispatch blocks; pre-line shows newlines)
  if (source) {
    const ymd = new Intl.DateTimeFormat("en-CA", {
      timeZone: tz,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
    }).format(now); // e.g., 2025-08-25
    entry.innerHTML =
      "<div>" +
      '<div class="log-source"><strong>' +
      source +
      "</strong></div>" +
      '<div class="log-timestamp" style="font-weight: bold; color: #333; margin-bottom: 5px;">' +
      ymd +
      " " +
      timestamp +
      "</div>" +
      '<div class="log-content">' +
      formatLogMessage(safeMessage, type) +
      "</div>" +
      "</div>";
  } else {
    entry.innerHTML =
      '<div class="log-header">' +
      '<span class="log-timestamp">[' +
      timestamp +
      "]</span>" +
      '<div class="log-operator" style="font-size: 0.9em;">Op 417</div>' +
      "</div>" +
      '<div class="log-content">' +
      formatLogMessage(safeMessage, type) +
      "</div>";
  }

  logContainer.insertBefore(entry, logContainer.firstChild);
}

      function formatLogMessage(message, type) {
        const hasYesDispatchHeader =
          /Called dispatch(?:, spoke to)?/i.test(message) &&
          /Dispatched\s.+\s to the following location:/i.test(message);
        const hasOldDispatchedHeader =
          /Dispatched\s.+\s to the following location:/i.test(message);
        const noDispatch = /Unable to dispatch/i.test(message);

        const isCoords = (line) => /^(\bGPS\s+)?Coordinates:/i.test(line);

        // --- YES DISPATCH (new/old headers) ---
        if (hasYesDispatchHeader || hasOldDispatchedHeader) {
          const lines = message
            .split("\n")
            .map((l) => l.trim())
            .filter(Boolean);
          const mainLine = lines[0];

          let formatted = `<div class="dispatch-summary" style="font-weight: normal; color: inherit;">📍 ${mainLine}</div>`;

          lines.slice(1).forEach((line) => {
            if (!line) return;

            if (
              /^Last Known Location\b/i.test(line) ||
              /^Last Known Location:/i.test(line)
            )
              formatted += `<div class="location-info">📍 ${line}</div>`;
            else if (/^Address:/i.test(line))
              formatted += `<div class="location-info">📍 ${line}</div>`;
            else if (isCoords(line))
              formatted += `<div class="coordinates">🗺️ ${line}</div>`;
            else if (/^Speed:/i.test(line))
              formatted += `<div class="dispatch-detail">${line}</div>`;
            else if (/^Last Location Date\/Time:/i.test(line))
              formatted += `<div class="dispatch-detail">${line}</div>`;
            else if (/^Device Status\b/i.test(line))
              formatted += `<div class="device-status">📱 ${line}</div>`;
            else if (/^Last Communication:/i.test(line))
              formatted += `<div class="device-status">${line}</div>`;
            else if (/^Battery( Level)?:/i.test(line))
              formatted += `<div class="device-stats">🔋 ${line}</div>`;
            else if (/^Signal( Strength)?:/i.test(line))
              formatted += `<div class="device-stats">🔋 ${line}</div>`;
            else if (/Waiting/i.test(line))
              formatted += `<div class="dispatch-detail">⏰ ${line}</div>`;
            else formatted += `<div class="dispatch-detail">${line}</div>`;
          });

          return formatted;
        }

        // --- NO DISPATCH ---
        if (noDispatch) {
          const lines = message
            .split("\n")
            .map((l) => l.trim())
            .filter(Boolean);
          const mainLine = lines[0];

          let formatted = `<div class="dispatch-summary" style="color: #dc3545; font-weight: bold;">${mainLine}</div>`;

          lines.slice(1).forEach((line) => {
            if (!line) return;

            if (
              /^Last Known Location\b/i.test(line) ||
              /^Last Known Location:/i.test(line)
            )
              formatted += `<div class="location-info">📍 ${line}</div>`;
            else if (/^Address:/i.test(line))
              formatted += `<div class="location-info">📍 ${line}</div>`;
            else if (isCoords(line))
              formatted += `<div class="coordinates">🗺️ ${line}</div>`;
            else if (/^Speed:/i.test(line))
              formatted += `<div class="dispatch-detail">${line}</div>`;
            else if (/^Last Location Date\/Time:/i.test(line))
              formatted += `<div class="dispatch-detail">${line}</div>`;
            else if (/^Last Communication:/i.test(line))
              formatted += `<div class="device-status">${line}</div>`;
            else if (/^Battery( Level)?:/i.test(line))
              formatted += `<div class="device-stats">🔋 ${line}</div>`;
            else if (/^Signal( Strength)?:/i.test(line))
              formatted += `<div class="device-stats">🔋 ${line}</div>`;
            else if (/Repeating STEPS/i.test(line)) {
              const clean = line.replace(/^🔄\s*/, ""); // avoid double icon
              formatted += `<div class="protocol-reset" style="color: #856404; font-weight: bold;">🔄 ${clean}</div>`;
            } else if (/Waiting/i.test(line))
              formatted += `<div class="dispatch-detail">⏰ ${line}</div>`;
            else formatted += `<div class="dispatch-detail">${line}</div>`;
          });

          return formatted;
        }

        // --- OLD LONG DISPATCH (fallback, generalized) ---
        if (/Dispatched\s.+\s to the following location:/i.test(message)) {
          const parts = message.split(
            /(?=Last Known Location|Coordinates:|Speed:|Last Location|Device Status|Battery:|Signal:)/
          );
          let formatted =
            '<div class="dispatch-summary">📍 <strong>Emergency Services Dispatched</strong></div>';

          parts.forEach((part) => {
            const p = part.trim();
            if (!p) return;

            if (p.includes("Last Known Location"))
              formatted += `<div class="location-info">📍 ${p}</div>`;
            else if (/^(\bGPS\s+)?Coordinates:/i.test(p))
              formatted += `<div class="coordinates">🗺️ ${p}</div>`;
            else if (p.startsWith("Device Status"))
              formatted += `<div class="device-status">📱 ${p}</div>`;
            else if (p.startsWith("Battery:") || p.startsWith("Signal:"))
              formatted += `<div class="device-stats">🔋 ${p}</div>`;
            else formatted += `<div class="dispatch-detail">${p}</div>`;
          });
          return formatted;
        }

        // --- Timers ---
        if (message.toLowerCase().includes("timer")) {
          return '<div class="timer-action">⏰ ' + message + "</div>";
        }

        // --- Step messages ---
        if (/^Step\s/i.test(message)) {
          return message;
        }

        // --- Default ---
        return message;
      }

      function getActionIcon(action) {
        const icons = {
          "call-device": "📞",
          "message-device": "📱",
          "call-user": "📞",
          "call-emergency-contacts": "👥",
          dispatch: "🚑",
          "Dispatch EMS": "🚑",
          "call-device": "📞",
          "Immediate Dispatch": "🚨",
          "Conditional Dispatch": "⚠️",
        };
        return icons[action] || "▶️";
      }

      function formatButtonText() {
        const buttons = document.querySelectorAll("button");
        buttons.forEach((btn) => {
          if (btn.textContent.includes("call-device")) {
            btn.textContent = btn.textContent.replace(
              "call-device",
              "Call device"
            );
          }
          if (btn.textContent.includes("message-device")) {
            btn.textContent = btn.textContent.replace(
              "message-device",
              "Message device"
            );
          }
          if (btn.textContent.includes("call-user")) {
            btn.textContent = btn.textContent.replace("call-user", "Call user");
          }
        });
      }

      // Pulls Gas Type, Level, and the current reading from the Gas Readings (Live) panel
      function getGasSnapshotFromPanel() {
        console.log(
          "🟡 GAS CALL #" +
            (window.gasCallCount = (window.gasCallCount || 0) + 1)
        );
        console.log("🟡 Full stack trace:");
        console.trace();
        try {
          const panel =
            Array.from(document.querySelectorAll("*")).find((el) =>
              /Gas Readings\s*\(Live\)/i.test(el.textContent)
            ) || null;
          if (!panel) return "";

          const prettyGas = (s) => {
            if (!s) return "";
            const t = String(s).toLowerCase();
            if (t.includes("h2s") || t.includes("h₂s")) return "H₂S";
            if (t.includes("o2") || t.includes("o₂")) return "O₂";
            if (t.includes("co")) return "CO";
            if (t.includes("lel")) return "LEL";
            return s.toUpperCase();
          };

          const toKey = (p) =>
            String(p).toLowerCase().replace("₂", "2").replace(/\s+/g, "");

          // Prefer the gas chosen by normalization (if present)
          const normKey = (() => {
            try {
              const k = Object.keys(
                window.currentAlert?.gasNormalization?.targetLevels || {}
              )[0];
              return k ? k.toLowerCase().replace("₂", "2") : "";
            } catch {
              return "";
            }
          })();

          // Fix: Handle gas type mapping properly
          let primaryGas = "H₂S"; // default

          if (normKey && prettyGas(normKey)) {
            primaryGas = prettyGas(normKey);
          } else if (currentAlert?.gasType) {
            // Map gas types including variants like "o2-low"
            const gasType = currentAlert.gasType.toLowerCase();
            if (gasType.includes("o2")) primaryGas = "O₂";
            else if (gasType.includes("h2s")) primaryGas = "H₂S";
            else if (gasType.includes("co")) primaryGas = "CO";
            else if (gasType.includes("lel")) primaryGas = "LEL";
            else primaryGas = prettyGas(currentAlert.gasType);
          }

          // Look for the matching "gas-reading" (emoji-safe). Prefer one with a pill; else last match.
          const readings = Array.from(panel.querySelectorAll(".gas-reading"));
          const candidates = readings.filter((el) => {
            const txt = (el.textContent || "").trim().replace(/\s+/g, " ");
            // Escape special regex characters in primaryGas (like ₂ subscript)
            const escapedGas = primaryGas.replace(
              /[.*+?^${}()|[\]\\]/g,
              "\\$&"
            );
            return new RegExp(`^[^\\s]*\\s*${escapedGas}\\s*:`, "i").test(txt);
          });
          const rowEl =
            candidates.find((el) =>
              el.querySelector(".gas-status, .status-pill")
            ) ||
            candidates[candidates.length - 1] ||
            null;

          const key = toKey(primaryGas);
          const valEl = rowEl ? rowEl.querySelector(`#${key}-value`) : null;
          const pillEl = rowEl ? rowEl.querySelector(`#${key}-status`) : null;

          // Reading (value + unit)
          let readingStr = "";
          if (valEl) {
            const raw = (valEl.textContent || "").trim();
            const num = parseFloat(raw);
            const unitMatch = raw.match(/([%a-zA-Z₂/]+)\s*$/);
            const inferredUnit =
              key === "o2" ? " %vol" : key === "lel" ? " %LEL" : " ppm";
            const unit = unitMatch ? ` ${unitMatch[1]}` : inferredUnit;
            readingStr = isNaN(num)
              ? `${primaryGas}: —`
              : `${primaryGas}: ${num.toFixed(2)}${unit}`;
          } else if (rowEl) {
            const m = (rowEl.textContent || "").match(
              /:\s*([0-9.]+)\s*([%a-zA-Z₂/]+)\b/i
            );
            readingStr = m
              ? `${primaryGas}: ${Number(m[1]).toFixed(2)} ${m[2]}`
              : `${primaryGas}: —`;
          } else {
            readingStr = `${primaryGas}: —`;
          }

          // Level - Handle O₂ statuses properly
          const levelTokens = [
            "HIGH",
            "NORMAL",
            "LOW",
            "DEPLETION",
            "ENRICHMENT",
          ];
          const levelFromIds = (pillEl ? pillEl.textContent || "" : "")
            .trim()
            .toUpperCase();
          const levelInRow = rowEl
            ? levelTokens.find((tok) =>
                (rowEl.textContent || "").toUpperCase().includes(tok)
              ) || ""
            : "";

          let level = levelFromIds || levelInRow || "—";

          // Clean up O₂ statuses
          if (primaryGas === "O₂") {
            if (level.includes("DEPLETION")) level = "O₂ Depletion";
            else if (level.includes("ENRICHMENT")) level = "O₂ Enrichment";
            else if (level === "NORMAL") level = "Normal";
          }

          return `Gas Type: ${primaryGas}\nGas Level: ${level}\nGas Reading: ${readingStr}`;
        } catch (e) {
          console.warn("getGasSnapshotFromPanel failed:", e);
          return "";
        }
      }

      function getStepLabel(stepId) {
        const parts = stepId.split("-");
        if (parts.length === 2) {
          return `Step ${parts[1]}`; // "step-3" → "Step 3"
        } else if (parts.length === 3) {
          return `Step ${parts[1]}.${parts[2]}`; // "step-4-1" → "Step 4.1"
        }
        return stepId; // fallback
      }

      function loadProtocolSteps(protocolConfig, userConfig) {
  let protocolHTML =
    '<div style="margin-bottom: 20px;" data-cy="protocol-header"><h4 style="color: #1565c0; margin: 0 0 10px 0;" data-cy="protocol-name">📋 ' +
    protocolConfig.name +
    '</h4><p style="color: #666; font-size: 0.9em; margin: 0;" data-cy="protocol-description">Showing only relevant steps for this alert type</p></div>';

  // Add monitoring phase description if enabled
  if (
    protocolConfig.monitoringPhase &&
    protocolConfig.monitoringPhase.enabled
  ) {
    protocolHTML +=
      '<div style="margin-bottom: 20px; padding: 15px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; border-left: 4px solid #ffc107;" data-cy="monitoring-phase">' +
      '<h5 style="color: #856404; margin: 0 0 10px 0; font-weight: bold;" data-cy="monitoring-phase-title">⏱️ 2-Minute Monitoring Phase</h5>' +
      '<p style="color: #856404; margin: 0; font-weight: 500; line-height: 1.4;" data-cy="monitoring-phase-description">' +
      protocolConfig.monitoringPhase.description +
      "</p>" +
      "</div>";
  }

  protocolConfig.steps.forEach(function (step, index) {
    const isFirst = index === 0;
    const isDispatchStep = step.action === "dispatch";

    // Check if this is a monitoring protocol
    const isMonitoringProtocol =
      protocolConfig.monitoringPhase &&
      protocolConfig.monitoringPhase.enabled;

    // For monitoring protocols, Step 1 should start as Pending during monitoring phase
    const shouldBeActive = isMonitoringProtocol
      ? isDispatchStep // Only dispatch step active for monitoring protocols
      : isFirst || isDispatchStep; // Normal logic for non-monitoring protocols

    // Build step classes - add dispatch-step class for dispatch steps
    let stepClasses = "step";
    if (shouldBeActive) stepClasses += " active";
    if (isDispatchStep) stepClasses += " dispatch-step";

    // Open main step div
    protocolHTML +=
      '<div class="' +
      stepClasses +
      '" id="' +
      step.id +
      '" data-cy="' +
      step.id +
      '">' +
      '<div class="step-header">' +
      '<h4 class="step-title" data-cy="' +
      step.id +
      '-title">✅ STEP ' +
      (index + 1) +
      ": " +
      step.title +
      "</h4>" +
      '<span class="status-badge ' +
      (shouldBeActive ? "active" : "") +
      '" id="' +
      step.id +
      '-status" data-cy="' +
      step.id +
      '-status">' +
      (shouldBeActive ? "Active" : "Pending") +
      "</span>" +
      "</div>";

    // Add contact info for relevant steps
    if (step.id === "step-3" || step.id === "step-2") {
      // Only show user contact for "Call User" actions
      if (step.action === "call-user") {
        protocolHTML +=
          '<div class="contact-info" data-cy="' +
          step.id +
          '-contact-info">' +
          "<strong>👤 " +
          userConfig.name +
          "</strong> 📞 " +
          userConfig.mobile +
          "</div>";
      }
    }

    // Handle Emergency Contacts
    if (step.action === "call-emergency-contacts") {
      const userKey = currentAlert.user;
      const emergencyContacts = AlertDataManager.usersData[userKey]
        ? AlertDataManager.usersData[userKey].emergencyContacts
        : [];

      // Add individual EC sections as sub-steps
      emergencyContacts.forEach(function (contact, index) {
        const contactStepId = step.id + "-" + (index + 1);

        protocolHTML +=
          '<div class="sub-step" id="' +
          contactStepId +
          '" data-cy="' +
          contactStepId +
          '">' +
          '<div class="step-header">' +
          '<h5 class="step-title" data-cy="' +
          contactStepId +
          '-title">📞 Call ' +
          contact.name +
          " at " +
          contact.phone +
          "</h5>" +
          '<span class="status-badge" id="' +
          contactStepId +
          '-status" data-cy="' +
          contactStepId +
          '-status">Pending</span>' +
          "</div>" +
          '<div class="contact-info" data-cy="' +
          contactStepId +
          '-contact-info">' +
          "<strong>👤 " +
          contact.name +
          "</strong> 📞 " +
          contact.phone +
          " 🏷️ " +
          contact.role +
          "</div>" +
          '<button class="btn btn-primary" data-cy="' +
          contactStepId +
          '-button" onclick="startStep(\'' +
          contactStepId +
          "')\" disabled>" +
          "📞 Call Emergency Contact" +
          "</button>" +
          '<div class="step-outcome" id="' +
          contactStepId +
          '-outcome" data-cy="' +
          contactStepId +
          '-outcome" style="display: none; margin-top: 15px;">' +
          '<select id="' +
          contactStepId +
          '-select" data-cy="' +
          contactStepId +
          '-select" onchange="autoPopulateNote(\'' +
          contactStepId +
          '\')" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
          '<option value="">Select outcome</option>' +
          '<option value="confirmed-ok">Confirmed user is okay</option>' +
          '<option value="ec-callback">Emergency contact called in and confirmed user is okay</option>' +
          '<option value="user-callback">User called in. Confirmed they are okay</option>' +
          '<option value="ec-callback-30min-outbound">EC will check on user and call back within 30 minutes</option>' +
          '<option value="ec-callback-30min">EC called in, will check on user and call back within 30 minutes</option>' +
          '<option value="no-answer-voicemail">No answer, left voicemail</option>' +
          '<option value="no-answer-unable">No answer, unable to leave voicemail</option>' +
          '<option value="wrong-number">Wrong number</option>' +
          '<option value="unable-to-connect">Unable to connect</option>' +
          "</select>" +
          '<textarea id="' +
          contactStepId +
          '-note" data-cy="' +
          contactStepId +
          '-note" placeholder="Document the result..." style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 8px; box-sizing: border-box;" oninput="validatePostButton(\'' +
          contactStepId +
          "')\"></textarea>" +
          '<button class="btn btn-secondary" data-cy="' +
          contactStepId +
          '-post-btn" onclick="postNote(\'' +
          contactStepId +
          '\')" style="margin-top: 8px;" disabled id="' +
          contactStepId +
          '-post-btn">✅ Post Note</button>' +
          "</div>" +
          "</div>";
      });

      protocolHTML +=
        '<div style="margin: 15px 0; padding: 12px; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px; font-size: 0.9em; color: #1565c0; font-weight: 500;" data-cy="' +
        step.id +
        '-instruction">' +
        "📍 If valid location not available, repeat STEPS 1, 2, 3 & 4 until someone is reached." +
        "</div>";

      // Close main step div
      protocolHTML += "</div>";
      return;
    }

    // Handle Combined Device/User Call
    if (step.action === "combined-device-user-call") {
      // Add individual call sub-steps
      step.subSteps.forEach(function (subStep, index) {
        const subStepId = step.id + "-" + (index + 1);

        protocolHTML +=
          '<div class="sub-step" id="' +
          subStepId +
          '" data-cy="' +
          subStepId +
          '">' +
          '<div class="step-header">' +
          '<h5 class="step-title" data-cy="' +
          subStepId +
          '-title">📞 ' +
          subStep.title +
          "</h5>" +
          '<span class="status-badge" id="' +
          subStepId +
          '-status" data-cy="' +
          subStepId +
          '-status">Pending</span>' +
          "</div>" +
          '<button class="btn btn-primary" data-cy="' +
          subStepId +
          '-button" onclick="startStep(\'' +
          subStepId +
          "')\" " +
          (index === 0 ? "" : "disabled") +
          ">" +
          getActionIcon(subStep.action) +
          " " +
          subStep.action +
          "</button>" +
          '<div class="step-outcome" id="' +
          subStepId +
          '-outcome" data-cy="' +
          subStepId +
          '-outcome" style="display: none; margin-top: 15px;">';

        // Add appropriate dropdown based on sub-step action
        if (subStep.action === "call-device") {
          protocolHTML +=
            '<select id="' +
            subStepId +
            '-select" data-cy="' +
            subStepId +
            '-select" onchange="autoPopulateFromDropdown(\'' +
            subStepId +
            '\')" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
            '<option value="">Select outcome</option>' +
            '<option value="confirmed-ok">Spoke with ' +
            userConfig.name +
            ". Confirmed they are okay. Resolving alert.</option>" +
            '<option value="user-callback">User called in. Confirmed they are okay</option>' +
            '<option value="no-answer">No answer.</option>' +
            '<option value="unable-to-call">Unable to call, device offline.</option>' +
            "</select>";
        } else if (subStep.action === "call-user") {
          protocolHTML +=
            '<select id="' +
            subStepId +
            '-select" data-cy="' +
            subStepId +
            '-select" onchange="autoPopulateFromDropdown(\'' +
            subStepId +
            '\')" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
            '<option value="">Select outcome</option>' +
            '<option value="confirmed-ok">Spoke with ' +
            userConfig.name +
            ", confirmed they are okay</option>" +
            '<option value="no-answer-voicemail">No answer. Left voicemail</option>' +
            '<option value="no-answer-unable-voicemail">No answer. Unable to leave voicemail</option>' +
            '<option value="unable-to-connect">Unable to connect</option>' +
            "</select>";
        }

        protocolHTML +=
          '<textarea id="' +
          subStepId +
          '-note" data-cy="' +
          subStepId +
          '-note" placeholder="Document the result..." style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 8px; box-sizing: border-box;" oninput="validatePostButton(\'' +
          subStepId +
          "')\"></textarea>" +
          '<button class="btn btn-secondary" data-cy="' +
          subStepId +
          '-post-btn" onclick="postNote(\'' +
          subStepId +
          '\')" style="margin-top: 8px;" disabled id="' +
          subStepId +
          '-post-btn">✅ Post Note</button>' +
          "</div>" +
          "</div>";
      });

      // Close main step div
      protocolHTML += "</div>";
      return;
    }

    // Handle Dispatch Steps
    if (step.action === "dispatch") {
      protocolHTML +=
        '<div class="step-outcome" id="' +
        step.id +
        '-outcome" data-cy="' +
        step.id +
        '-outcome" style="display: block; margin-top: 15px;">' +
        '<label for="dispatch-decision" style="display: block; margin-bottom: 8px; font-weight: bold;">Dispatch conditions met?</label>' +
        '<select id="dispatch-decision" data-cy="dispatch-decision" onchange="handleDispatchDecision(\'' +
        step.id +
        '\')" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 15px;">' +
        '<option value="">-- System will evaluate --</option>' +
        '<option value="yes">Yes</option>' +
        '<option value="no">No</option>' +
        "</select>" +
        '<div id="service-type-container" data-cy="service-type-container" style="display: none; margin-bottom: 15px;">' +
        '<label for="dispatch" style="display: block; font-weight: bold; margin-bottom: 8px; color: #333;">Dispatch Service Type:</label>' +
        '<select id="dispatch" data-cy="dispatch-service-select" onchange="autoPopulateDispatchNote(\'' +
        step.id +
        '\')" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 12px; font-size: 0.9em;">' +
        '<option value="">-- Select Service --</option>' +
        '<option value="Emergency Medical Services (EMS)">Emergency Medical Services (EMS)</option>' +
        '<option value="Police">Police</option>' +
        '<option value="Fire Department">Fire Department</option>' +
        '<option value="EMS and Police">EMS and Police</option>' +
        '<option value="EMS and Fire">EMS and Fire</option>' +
        '<option value="Police and Fire">Police and Fire</option>' +
        '<option value="EMS, Police and Fire">EMS, Police and Fire</option>' +
        "</select>" +
        "</div>" +
        '<div id="skip-reason-container" data-cy="skip-reason-container" style="display: none; margin-bottom: 15px;">' +
        '<label for="skip-reason" style="display: block; font-weight: bold; margin-bottom: 8px; color: #856404;">Unmet Dispatch Condition:</label>' +
        '<select id="skip-reason" data-cy="skip-reason" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 8px;">' +
        '<option value="">-- System will determine --</option>' +
        '<option value="gas-normalized">Gas levels back to normal</option>' +
        '<option value="device-offline">Device offline (last comm > 30 min, battery ≤ 10%, or signal ≤ 10%)</option>' +
        '<option value="location-stale">Location not valid or current</option>' +
        '<option value="device-moving">Device not stationary (≥ 5 km/h)</option>' +
        "</select>" +
        "</div>" +
        '<textarea id="' +
        step.id +
        '-note" data-cy="' +
        step.id +
        '-note" placeholder="Document the dispatch decision..." style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 8px; box-sizing: border-box;" oninput="validatePostButton(\'' +
        step.id +
        "')\"></textarea>" +
        '<button class="btn btn-secondary" data-cy="' +
        step.id +
        '-post-btn" onclick="postNote(\'' +
        step.id +
        '\')" style="margin-top: 8px;" disabled id="' +
        step.id +
        '-post-btn">✅ Post Note</button>' +
        "</div>" +
        '<div style="margin: 15px 0; padding: 12px; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px; font-size: 0.9em; color: #1565c0; font-weight: 500;" data-cy="' +
        step.id +
        '-instruction">' +
        "📍 If valid location not available, repeat STEPS 1, 2, 3 & 4 until someone is reached." +
        "</div>";

      // Close main step div
      protocolHTML += "</div>";
      return;
    }

    // Standard processing for other steps
    protocolHTML +=
      '<button class="btn btn-primary" data-cy="' +
      step.id +
      '-button" onclick="startStep(\'' +
      step.id +
      "')\" " +
      (!isFirst ? "disabled" : "") +
      ">" +
      getActionIcon(step.action) +
      " " +
      step.action +
      "</button>";

    // Step outcome section
    protocolHTML +=
      '<div class="step-outcome" id="' +
      step.id +
      '-outcome" data-cy="' +
      step.id +
      '-outcome" style="display: none; margin-top: 15px;">';

    // Timer info
    if (step.timer) {
      protocolHTML +=
        '<div style="background: #fff3cd; padding: 8px; border-radius: 4px; margin: 10px 0; font-size: 0.85em;" data-cy="' +
        step.id +
        '-timer-info">' +
        "⏱️ Timer: " +
        Math.floor(step.timer / 60) +
        " minutes" +
        "</div>";
    }

    // Outcome dropdown
    protocolHTML +=
      '<select id="' +
      step.id +
      '-select" data-cy="' +
      step.id +
      '-select" onchange="autoPopulateFromDropdown(\'' +
      step.id +
      "'); validatePostButton('" +
      step.id +
      '\')" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
      '<option value="">Select outcome</option>';

    // Action-based dropdown options
    if (step.action === "call-device") {
      protocolHTML +=
        '<option value="confirmed-ok">Spoke with ' +
        userConfig.name +
        ". Confirmed they are okay. Resolving alert.</option>" +
        '<option value="user-callback">User called in. Confirmed they are okay</option>' +
        '<option value="no-answer">No answer.</option>' +
        '<option value="unable-to-call">Unable to call, device offline.</option>';
    } else if (step.action === "message-device") {
      protocolHTML +=
        '<option value="no-response">No response</option>' +
        '<option value="unable-to-send">Unable to send text message, device offline</option>' +
        '<option value="device-no">Received "No" - User confirmed okay</option>' +
        '<option value="issue-resolved">Received "Issue resolved" - User confirmed okay</option>' +
        '<option value="false-alarm">Received "False alarm" - User confirmed okay</option>' +
        '<option value="understood">Received "Understood" - User confirmed okay</option>' +
        '<option value="device-yes">Received "Yes" - User confirmed okay</option>' +
        '<option value="send-help">Received "Send help" - Immediate assistance requested</option>';
    } else if (step.action === "call-user") {
      protocolHTML +=
        '<option value="confirmed-ok">Spoke with ' +
        userConfig.name +
        ", confirmed they are okay</option>" +
        '<option value="ec-callback">Emergency contact called in and confirmed user is okay</option>' +
        '<option value="user-callback">User called in. Confirmed they are okay</option>' +
        '<option value="ec-callback-30min">EC called in, will check on user and call back within 30 minutes</option>' +
        '<option value="no-answer-voicemail">No answer. Left voicemail</option>' +
        '<option value="no-answer-already-left">No answer. Voicemail had already been left</option>' +
        '<option value="no-answer-mailbox-full">No answer. Unable to leave voicemail, mailbox full</option>' +
        '<option value="no-answer-unable-voicemail">No answer. Unable to leave voicemail</option>' +
        '<option value="no-answer-mailbox-not-setup">No answer. Unable to leave voicemail, mailbox not set up yet</option>' +
        '<option value="no-phone-number">Unable to call, user has no phone number assigned</option>' +
        '<option value="number-disconnected">Number has been changed, disconnected or no longer in service</option>' +
        '<option value="unable-to-connect">Unable to connect</option>';
    } else {
      protocolHTML +=
        '<option value="completed">Action completed</option>' +
        '<option value="no-answer">No answer</option>';
    }

    protocolHTML += "</select>";

    // Note textarea
    protocolHTML +=
      '<textarea id="' +
      step.id +
      '-note" data-cy="' +
      step.id +
      '-note" placeholder="Document the result..." ' +
      'style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 8px; box-sizing: border-box;" ' +
      "oninput=\"validatePostButton('" +
      step.id +
      "')\"></textarea>";

    // Post Note button
    protocolHTML +=
      '<button class="btn btn-secondary" data-cy="' +
      step.id +
      '-post-btn" onclick="postNote(\'' +
      step.id +
      '\')" style="margin-top: 8px;" disabled id="' +
      step.id +
      '-post-btn">✅ Post Note</button>' +
      "</div>";

    // Close main step div
    protocolHTML += "</div>";
  });

  // Resolution Section
  protocolHTML +=
    '<div class="resolution-section" data-cy="resolution-section">' +
    '<div class="step-header">' +
    '<h3 data-cy="resolution-title"> RESOLUTION</h3>' +
    '<span class="status-badge" id="resolution-status" data-cy="resolution-status">Pending</span>' +
    "</div>" +
    '<select id="resolution-reason" data-cy="resolution-reason" style="width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">' +
    '<option value="">-- Select reason --</option>' +
    '<option value="false-alert-without-dispatch">False alert without dispatch</option>' +
    '<option value="false-alert-with-dispatch">False alert with dispatch</option>' +
    '<option value="incident-without-dispatch">Incident without dispatch</option>' +
    '<option value="incident-with-dispatch">Incident with dispatch</option>' +
    '<option value="pre-alert">Pre-alert</option>' +
    "</select>" +
    '<div class="resolution-buttons" data-cy="resolution-buttons">' +
    '<button class="btn btn-danger" data-cy="resolve-alert-btn" onclick="resolveAlert()">✅ Resolve Alert</button>' +
    '<button class="btn btn-secondary" data-cy="cancel-resolution-btn" onclick="cancelResolution()">❌ Cancel Resolution</button>' +
    "</div>" +
    "</div>";

  document.getElementById("protocol-content").innerHTML = protocolHTML;
}

function autoPopulateNote(contactStepId) {
        const select = document.getElementById(contactStepId + "-select");
        const note = document.getElementById(contactStepId + "-note");

        if (!select || !note) return;

        const selectedValue = select.value;
        if (!selectedValue) return;

        const ecIndex = parseInt(contactStepId.split("-")[2]) - 1;
        const userKey = currentAlert.user;
        const contact =
          AlertDataManager.usersData[userKey].emergencyContacts[ecIndex];

        let noteText = "";
        let shouldScrollToResolution = false;

        // GROUP 1: RESOLUTION OUTCOMES
        if (selectedValue === "confirmed-ok") {
          noteText = `Called ${contact.name} at ${contact.phone}. Confirmed user is okay and advised to resolve alert`;
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback") {
          noteText = "Emergency contact called in and confirmed user is okay";
          shouldScrollToResolution = true;
        } else if (selectedValue === "user-callback") {
          noteText = "User called in. Confirmed they are okay";
          shouldScrollToResolution = true;
        } else if (selectedValue === "ec-callback-30min") {
          noteText =
            "Emergency contact called in, will check on user and call back within 30 minutes.";
          // Should start 30-min timer

          // GROUP 2: CONTINUE PROTOCOL OUTCOMES
        } else if (selectedValue === "no-answer-voicemail") {
          noteText = `Called ${contact.name} at ${contact.phone}. No answer, left voicemail`;
        } else if (selectedValue === "no-answer-unable") {
          noteText = `Called ${contact.name} at ${contact.phone}. No answer, unable to leave voicemail`;
        } else if (selectedValue === "wrong-number") {
          noteText = `Called ${contact.name} at ${contact.phone}. Wrong number`;
        } else if (selectedValue === "unable-to-connect") {
          noteText = `Called ${contact.name} at ${contact.phone}. Unable to connect`;
        } else if (selectedValue === "ec-callback-30min-outbound") {
          noteText = `Called ${contact.name} at ${contact.phone}. EC will check on user and call back within 30 minutes`;
        }

        if (noteText) {
          note.value = noteText;
          validatePostButton(contactStepId);
        }
      }

      function updateGasReadings(alertType) {
        const gasData = gasReadingsData[alertType] || gasReadingsData.default;

        Object.keys(gasData).forEach(function (gas) {
          const reading = gasData[gas];
          const valueElement = document.getElementById(gas + "-value");
          const statusElement = document.getElementById(gas + "-status");
          const readingElement = document.getElementById(gas + "-reading");

          const unit =
            gas === "o2" ? " %vol" : gas === "lel" ? " %LEL" : " ppm";

          if (valueElement) {
            valueElement.textContent = reading.value.toFixed(2) + unit;
          }

          if (statusElement) {
            statusElement.textContent = reading.status;
            statusElement.className =
              "gas-status " + reading.status.toLowerCase();
          }

          if (readingElement) {
            const gasLabel =
              gas === "h2s" ? "H₂S" : gas === "o2" ? "O₂" : gas.toUpperCase();
            readingElement.querySelector("span").innerHTML =
              gasLabel +
              ': <span class="gas-value">' +
              reading.value.toFixed(2) +
              unit +
              "</span>";
          }
        });

        if (alertType !== "default") {
          document.getElementById("triggeredBy").style.display = "block";
          document.getElementById("lastUpdated").style.display = "block";
          document.getElementById("gas-timestamp").textContent =
            new Date().toLocaleTimeString() + " MDT";
        }
      }

      // ═══════════════════════════════════════════════════════════════
      // 2-MINUTE ALERT MONITORING (Minimal Implementation)
      // ═══════════════════════════════════════════════════════════════

      function startTwoMinuteMonitoring(duration) {
        addLogEntry("Monitoring gas alert for 2 minutes", "system");
        startGlobalTimer(
          null,
          "Gas Monitoring",
          "System",
          duration,
          "monitoring"
        );

        // Use existing gas normalization system
        if (currentAlert?.gasNormalization?.enabled) {
          const delay = currentAlert.gasNormalization.delay || 60000;
          setTimeout(() => {
            triggerGasNormalization(currentAlert); // Use existing function!
          }, delay);
        }

        setTimeout(() => {
          const o2Status = document
            .getElementById("o2-status")
            ?.textContent?.trim();
          if (o2Status === "NORMAL" || o2Status === "Normal") {
            // Gas normalized - auto-resolve
            const gasData = getGasSnapshotFromPanel();
            let resolutionMessage =
              "Gas levels have remained or gone back to normal levels. Resolving alert as per protocol.";
            if (gasData && gasData.trim()) {
              resolutionMessage += `\n\n${gasData}`;
            }
            addLogEntry(resolutionMessage, "resolution");
            resolveAlert();
          } else {
            // Gas levels still dangerous - escalate to manual steps
            addLogEntry(
              "Gas levels are still high, proceeding to step 1.",
              "system"
            );

            // Activate Step 1 for manual intervention
            const step1 = document.getElementById("step-1");
            const step1Status = document.getElementById("step-1-status");

            if (step1) {
              step1.classList.add("active");
              step1.style.opacity = "1";

              // Enable the step button
              const step1Button = step1.querySelector(
                "button:not([onclick*='postNote'])"
              );
              if (step1Button) {
                step1Button.disabled = false;
                step1Button.classList.remove("btn-secondary");
                step1Button.classList.add("btn-primary");
              }
            }

            if (step1Status) {
              step1Status.textContent = "Active";
              step1Status.className = "status-badge active";
            }
          }
        }, duration * 1000);
      }

      function updateGasDisplay() {
        const timestamp = new Date().toLocaleTimeString("en-US", {
          hour12: false,
          timeZone: "America/Denver",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        });

        const timestampElement = document.getElementById("gas-timestamp");
        if (timestampElement) {
          timestampElement.textContent = timestamp + " MDT";
        }
      }

      function startGasMonitoring() {
        updateGasDisplay();
        gasUpdateInterval = setInterval(() => {
          updateGasDisplay();

          // Add continuous monitoring logic here
          if (currentAlert && isGasAlert(currentAlert)) {
            const wasHigh = window.lastGasState === "HIGH";
            const nowHigh = isGasLevelHigh();

            if (wasHigh && !nowHigh) {
              // Gas just normalized - could trigger notifications, enable buttons, etc.
              addLogEntry(
                "Gas levels normalized during active protocol.",
                "system"
              );
            }

            window.lastGasState = nowHigh ? "HIGH" : "NORMAL";
          }
        }, 5000);
      }

      // ═══════════════════════════════════════════════════════════════
      // 🔄 EVENT HANDLERS & DEMO FUNCTIONS
      // ═══════════════════════════════════════════════════════════════

      function toggleDemoPanel() {
        document.getElementById("demo-panel").classList.toggle("show");
      }

      function toggleDemoSection(sectionId) {
        const section = document.getElementById(sectionId);
        section.classList.toggle("collapsed");
      }

      function checkDeviceConnectivityForSteps() {
        console.log("=== CONNECTIVITY CHECK FUNCTION CALLED ===");

        if (!currentAlert || !DeviceConnectivity) {
          console.log(
            "Early exit: currentAlert=",
            currentAlert,
            "DeviceConnectivity=",
            DeviceConnectivity
          );
          return;
        }

        console.log("currentAlert:", currentAlert);
        console.log(
          "DeviceConnectivity.isDeviceOnline():",
          DeviceConnectivity.isDeviceOnline()
        );

        const isOffline = !DeviceConnectivity.isDeviceOnline();
        if (!isOffline) {
          console.log("Device is online, exiting");
          return;
        }

        console.log("Device is offline, proceeding...");

        const deviceSteps = document.querySelectorAll('[id$="-select"]');
        console.log("Found dropdowns:", deviceSteps.length);

        deviceSteps.forEach((select) => {
          const stepId = select.id.replace("-select", "");
          const step = document.getElementById(stepId);

          console.log(
            "Checking step:",
            stepId,
            "hasActiveClass:",
            step?.classList.contains("active")
          );

          if (!step || !step.classList.contains("active")) return;

          console.log("Step is active, checking options...");

          const hasCallOption = select.querySelector(
            'option[value="unable-to-call"]'
          );
          const hasMessageOption = select.querySelector(
            'option[value="unable-to-send"]'
          );

          console.log(
            "hasCallOption:",
            !!hasCallOption,
            "hasMessageOption:",
            !!hasMessageOption
          );

          if (hasCallOption) {
            console.log("Setting call option");
            select.value = "unable-to-call";
            select.className = "offline-dropdown";
            document.getElementById(stepId + "-outcome").style.display =
              "block";
            const note = document.getElementById(stepId + "-note");
            if (note) note.value = "Unable to call, device offline";
            if (typeof validatePostButton === "function")
              validatePostButton(stepId);
          } else if (hasMessageOption) {
            console.log("Setting message option");
            select.value = "unable-to-send";
            select.className = "offline-dropdown";
            document.getElementById(stepId + "-outcome").style.display =
              "block";
            const note = document.getElementById(stepId + "-note");
            if (note)
              note.value = "Unable to send text message, device offline";
            if (typeof validatePostButton === "function")
              validatePostButton(stepId);
          }
        });
      }

      function loadAlert(alertType) {
    // Reset dispatch state variables for new alert
    window.dispatchMade = false;
    if (window.protocolState) {
        window.protocolState.dispatchMade = false;
    }
    if (typeof dispatchMade !== 'undefined') {
        dispatchMade = false;
    }

    const alertConfig = AlertDataManager.alertTypesData[alertType];
    if (!alertConfig) {
        console.error(`Alert type ${alertType} not found`);
        return;
    }

        // NEW: Check for pre-alert condition FIRST
        if (isPreAlert(alertConfig)) {
          const userConfig = AlertDataManager.usersData[alertConfig.user];

          // Set global state
          currentAlert = alertConfig;
          currentUser = userConfig;

          // Clear existing logs
          const logContainer = document.getElementById("protocolLog");
          if (logContainer) logContainer.innerHTML = "";

          // Handle pre-alert: log, disable steps, setup resolution
          addPreAlertLogEntry(alertConfig);

          // Basic UI setup
          updateAlertHeader(alertConfig, userConfig);
          updateGasReadings(alertConfig.gasType || alertType);

          // Load protocol steps (they'll be marked completed by setupPreAlertResolution)
          const protocolConfig = ProtocolFactory.getProtocolConfig(alertType);
          loadProtocolSteps(protocolConfig, userConfig);

          // Setup pre-alert resolution
          setupPreAlertResolution();

          document.getElementById("alert-header")?.classList.add("active");
          document.getElementById("demo-panel")?.classList.remove("show");

          console.log(
            "[PreAlert] Alert is >24h old, completed pre-alert setup"
          );
          return; // Skip normal protocol loading
        }

        const userConfig = AlertDataManager.usersData[alertConfig.user];
        const protocolConfig = ProtocolFactory.getProtocolConfig(alertType);

        // Global state
        currentAlert = alertConfig;
        currentUser = userConfig;

        // Clear existing logs
        const logContainer = document.getElementById("protocolLog");
        if (logContainer) logContainer.innerHTML = "";

        // ---- Hydrate Connectivity Panel from deviceConditions (presence-safe) ----
        const dc = alertConfig.deviceConditions || {};
        const setText = (id, text) => {
          const el = document.getElementById(id);
          if (el && text != null) el.textContent = String(text);
        };

        // Battery, Signal, Speed — simple replacements
        if (typeof dc.battery === "number")
          setText("battery-level", `${dc.battery}%`);
        if (typeof dc.signal === "number")
          setText("signal-strength", `${dc.signal}%`);
        if (typeof dc.deviceSpeed === "number") {
          const v = Number.isFinite(dc.deviceSpeed) ? dc.deviceSpeed : 0;
          setText("device-speed", `${v.toFixed(1)} km/h`);
        }

        // Device status badge/text (if your DOM exposes one)
        const statusNode =
          document.querySelector("#device-connectivity-status") ||
          document.querySelector('[data-cy="connectivity-status"]');
        if (statusNode && dc.deviceStatus)
          statusNode.textContent = dc.deviceStatus;

        // Last Communication: keep any absolute time already in the DOM,
        // and replace/append the relative "(X min ago)" part from fixtures
        if (typeof dc.lastComm === "number") {
          const lastEl = document.getElementById("last-comm-time");
          if (lastEl) {
            const raw = (lastEl.textContent || "").trim();
            const rel = `${dc.lastComm} minutes ago`;

            // Remove any existing parenthetical and rebuild cleanly
            const cleanTime = raw.replace(/\s*\([^)]*\).*$/, "");
            lastEl.textContent = `${cleanTime} (${rel})`;
          }
        }

        // Location timestamp: calculate from locationAge
        if (typeof dc.locationAge === "number") {
          const locationEl = document.getElementById("location-timestamp");
          if (locationEl) {
            const now = new Date();
            const locationTime = new Date(
              now.getTime() - dc.locationAge * 60 * 1000
            );
            const formattedTime =
              locationTime.toLocaleDateString("en-US", {
                month: "short",
                day: "2-digit",
                year: "numeric",
              }) +
              " at " +
              locationTime.toLocaleTimeString("en-US", {
                hour: "2-digit",
                minute: "2-digit",
                hour12: false,
              }) +
              " MDT";
            locationEl.textContent = formattedTime;
          }
        }

        // ---- Sync deviceConditions with DeviceConnectivity system (all alerts) ----
        if (Object.keys(dc).length > 0) {
          // Store original state for restoration if needed
          if (!DeviceConnectivity._originalStatus) {
            DeviceConnectivity._originalStatus = {
              ...DeviceConnectivity.currentStatus,
            };
          }

          DeviceConnectivity.currentStatus = {
            online: dc.deviceStatus === "Online",
            lastCommunication: new Date(
              Date.now() - (dc.lastComm || 0) * 60 * 1000
            ),
            battery: dc.battery || 0,
            signal: dc.signal || 0,
            connectionType: "Cellular",
          };
          DeviceConnectivity.updateConnectivityDisplay();
        }

        // ---- Initialize UI ----
        addAlertSequenceLogs(userConfig);
        updateAlertHeader(alertConfig, userConfig);
        updateGasReadings(alertConfig.gasType || alertType);
        loadProtocolSteps(protocolConfig, userConfig);
        initializeAlert(alertConfig, userConfig);

        formatButtonText();

        // ---- 2-MINUTE MONITORING CHECK ----
        if (alertConfig.requiresMonitoring) {
          const duration = alertConfig.monitoringDuration || 120;
          startTwoMinuteMonitoring(duration);
        }

        document.getElementById("alert-header")?.classList.add("active");
        document.getElementById("demo-panel")?.classList.remove("show");

        // After loading protocol, set Step 1 as Active
        setTimeout(() => {
          const step1 = document.getElementById("step-1");
          const step1Status = document.getElementById("step-1-status");

          if (step1) {
            // Check if this is a monitoring protocol
            const protocolConfig = ProtocolFactory.getProtocolConfig(alertType);
            const isMonitoringProtocol =
              protocolConfig?.monitoringPhase?.enabled;

            if (!isMonitoringProtocol) {
              step1.classList.add("active");
            } else {
              // For monitoring protocols, disable the button during monitoring phase
              const step1Button = step1.querySelector(
                'button:not([onclick*="postNote"])'
              );
              if (step1Button) {
                step1Button.disabled = true;
              }
            }
            step1.style.opacity = "1";
            // Optional: Scroll Step 1 into view
            step1.scrollIntoView({ behavior: "smooth", block: "center" });
          }

          if (step1Status) {
            // Check if this is a monitoring protocol
            const protocolConfig = ProtocolFactory.getProtocolConfig(alertType);
            const isMonitoringProtocol =
              protocolConfig?.monitoringPhase?.enabled;

            if (!isMonitoringProtocol) {
              // Only set Step 1 as Active for non-monitoring protocols
              step1Status.textContent = "Active";
              step1Status.className = "status-badge active";
            }
            // For monitoring protocols, leave Step 1 as "Pending" (set by loadProtocolSteps)
          }

          // Start/refresh dispatch UI now that panel is hydrated
          if (typeof initializeDispatchMonitoring === "function") {
            initializeDispatchMonitoring();
          }
          if (typeof silentlyUpdateDispatchConditions === "function") {
            silentlyUpdateDispatchConditions();
          }
        }, 100);

        // ---- Auto-select offline options if device is offline ----
        setTimeout(() => {
          checkDeviceConnectivityForSteps();
        }, 200);
      }

      function loadAlertFromJSON(alertId) {
  if (!alertsFromJSON || !alertsFromJSON.alertTypesData) {
    alert("JSON data not loaded yet");
    return;
  }
  
  const alertData = alertsFromJSON.alertTypesData[alertId];  // Access as object property, not array
  if (!alertData) {
    console.error(`Alert ID ${alertId} not found in JSON`);
    return;
  }

        // Convert JSON to expected format and load
        currentAlert = convertJSONToAlertFormat(alertData);
        currentUser = convertJSONToUserFormat(alertData);

        // REMOVE THIS EXTRA CLOSING BRACE: }

        // Clear existing logs
        const logContainer = document.getElementById("protocolLog");
        logContainer.innerHTML = "";

        // NEW: Check for pre-alert condition FIRST
        if (isPreAlert(alertData)) {
          // Handle pre-alert: log, disable steps, setup resolution
          addPreAlertLogEntry(alertData);
          setupPreAlertResolution();

          // Basic UI setup only (no protocol loading)
          updateAlertHeader(currentAlert, currentUser);
          document.getElementById("alert-header").classList.add("active");
          document.getElementById("demo-panel").classList.remove("show");

          console.log(
            "[PreAlert] Alert is >24h old, skipping normal protocol loading"
          );
          return; // Skip normal protocol loading
        }

        // Continue with normal initialization for recent alerts
        addAlertSequenceLogs(currentUser);
        updateAlertHeader(currentAlert, currentUser);
        updateGasReadings(currentAlert.gasType || "default");
        const protocolConfig = protocolsData[currentAlert.protocolFile];
        loadProtocolSteps(protocolConfig, currentUser);
        initializeAlert(currentAlert, currentUser);
        document.getElementById("alert-header").classList.add("active");
        document.getElementById("demo-panel").classList.remove("show");

        // Handle test scenarios
        handleTestScenario(currentAlert);
        updateAlertHeader(currentAlert, currentUser);
        updateGasReadings(currentAlert.gasType || "default");
        protocolConfig = protocolsData[currentAlert.protocolFile];
        loadProtocolSteps(protocolConfig, currentUser);
        initializeAlert(currentAlert, currentUser);

        document.getElementById("alert-header").classList.add("active");
        document.getElementById("demo-panel").classList.remove("show");

        // Handle test scenarios
        handleTestScenario(currentAlert);
      } // FUNCTION SHOULD CLOSE HERE

      function convertJSONToAlertFormat(alertData) {
        return {
          id: alertData.id,
          displayName: alertData.alert_subtype,
          user: alertData.user.toLowerCase().replace(" ", "-"),
          protocolFile: getProtocolFileFromType(alertData.type),
          gasType: alertData.is_gas_alert
            ? alertData.gas_type.toLowerCase() + "-high"
            : "default",
          testType: alertData.testType || "legacy",
        };
      }

      function convertJSONToUserFormat(alertData) {
        return {
          id: alertData.employee_id,
          name: alertData.user,
          device: alertData.device_type + "-" + alertData.device_id,
          mobile: alertData.mobile,
          company: alertData.organization,
          work: alertData.work,
          home: alertData.home,
          emergencyContacts: alertData.emergency_contacts.map((contact) => ({
            name: contact.name,
            phone: contact.phone,
            role: contact.role,
          })),
        };
      }

      function getProtocolFileFromType(alertType) {
        const typeMap = {
          "Gas Alert": "gas-emergency-protocol",
          "Fall Detection": "fall-detection-protocol",
          "SOS Alert": "sos-protocol",
          "No Motion": "no-motion-protocol",
          "Check-In Alert": "check-in-protocol",
          "Message Alert": "no-motion-protocol",
        };
        return typeMap[alertType] || "gas-emergency-protocol";
      }

      function handleTestScenario(alertConfig) {
        const gasMessages = [
          "False alarm",
          "Issue resolved",
          "I'm OK",
          "No",
          "Yes",
          "Understood",
        ];
        const nonGasMessages = [
          "Issue resolved",
          "False alarm",
          "I'm OK",
          "No",
          "Yes",
          "Send help",
        ];
        const helpMessages = ["Send help", "I am stranded", "Hazard in area"];

        if (alertConfig.testType === "spontaneous") {
          setTimeout(() => {
            let messagePool =
              alertConfig.protocolFile === "gas-emergency-protocol"
                ? gasMessages
                : nonGasMessages;
            const randomMessage =
              messagePool[Math.floor(Math.random() * messagePool.length)];
            simulateDeviceResponse(randomMessage, false);
          }, 3000);
        } else if (alertConfig.testType === "immediate-help") {
          setTimeout(() => {
            const helpMessage =
              helpMessages[Math.floor(Math.random() * helpMessages.length)];
            simulateDeviceResponse(helpMessage, false);
          }, 0);
        } else if (alertConfig.testType === "legacy") {
          if (alertConfig.id === "gas-high-threshold") {
            setTimeout(() => {
              const randomMessage =
                gasMessages[Math.floor(Math.random() * gasMessages.length)];
              simulateDeviceResponse(randomMessage, false);
            }, 3000);
          }
        }
      }

      function clearAlert() {
  currentAlert = null;
  currentUser = null;
  dispatchMade = false;

  document.getElementById("alert-header").classList.remove("active");
  updateGasReadings("default");
  clearDeviceConnectivity(); 
  document.getElementById("triggeredBy").style.display = "none";
  document.getElementById("lastUpdated").style.display = "none";
  document.getElementById("protocolLog").innerHTML =
    '<div class="log-placeholder">No alert loaded. Use demo controls to load an alert type and begin protocol.</div>';
  document.getElementById("protocol-content").innerHTML =
    '<div class="protocol-placeholder"><div class="protocol-frame"><div class="placeholder-text">No protocol loaded</div><div class="placeholder-subtitle">Alert type will load the relevant emergency response protocol</div></div></div>';
  document.getElementById("demo-panel").classList.remove("show");
}

      // Enhanced addManualNote function with intelligent parsing
      function addManualNote() {
        const noteText = document.getElementById("manual-notes").value.trim();
        if (!noteText) {
          alert("Please enter a note first");
          return;
        }

        // Analyze the note content
        const analysis = analyzeNote(noteText);

        // Log the note with specialist identification
        const timestamp = formatTimestamp();
        let logEntry = `[${timestamp}] ${noteText}`;

        // For gas alerts, append gas snapshot to resolution notes
        if (
          currentAlert &&
          (currentAlert.is_gas_alert || isGasAlert(currentAlert))
        ) {
          console.log(
            "DEBUG: Gas alert detected, analysis.type:",
            analysis.type
          );

          // Check if this is a resolution note and append gas data
          if (analysis.type === "resolution") {
            console.log(
              "DEBUG: Resolution type detected, getting gas snapshot..."
            );

            try {
              // Use the exact same approach as autoPopulateFromDropdown function
              let gasBlockRaw =
                typeof getGasSnapshotFromPanel === "function"
                  ? getGasSnapshotFromPanel()
                  : "";

              console.log("DEBUG: gasBlockRaw:", gasBlockRaw);

              if (gasBlockRaw) {
                console.log("DEBUG: Gas block found, adding timestamp...");

                const now = new Date();
                const ts =
                  typeof FORMATTERS?.timestampMST === "function"
                    ? FORMATTERS.timestampMST(now)
                    : new Intl.DateTimeFormat("en-US", {
                        timeZone: "America/Denver",
                        year: "numeric",
                        month: "2-digit",
                        day: "2-digit",
                        hour: "2-digit",
                        minute: "2-digit",
                        second: "2-digit",
                        hour12: false,
                      }).format(now) + " MDT";

                const gasBlockWithTs = gasBlockRaw.replace(
                  /(Gas Reading:\s*[^\n]+)/i,
                  `$1 (${ts})`
                );

                logEntry += `\n\n${gasBlockWithTs}`;

                console.log("DEBUG: Final logEntry with gas data:", logEntry);
              } else {
                console.log(
                  "DEBUG: No gas block returned from getGasSnapshotFromPanel"
                );
              }
            } catch (e) {
              console.log("Gas snapshot error:", e);
            }
          }
          addGasLogEntry(logEntry);
        } else {
          console.log("DEBUG: Not a gas alert, using regular log");
          addLogEntry(logEntry, "specialist");
        }

        // Handle intelligent actions for ALL alert types (moved to run for both gas and non-gas)
        handleIntelligentActions(analysis, noteText);

        // Clear the textarea and reset button
        document.getElementById("manual-notes").value = "";
        const button = document.querySelector(
          'button[onclick="addManualNote()"]'
        );
        if (button) {
          button.disabled = true;
          button.classList.add("btn-secondary");
          button.classList.remove("btn-success", "btn-warning", "btn-danger");
          button.textContent = "Post Note";
        }

        // Show confirmation of actions taken
        showActionConfirmation(analysis);
      }

      /// Handle intelligent actions based on note analysis
function handleIntelligentActions(analysis, noteText) {
  switch (analysis.type) {
    case "resolution":
      // existing behavior (prep resolution UI, etc.)
      handleResolutionNote(noteText, analysis.confidence);

      // ── AUTO-ACK: confirm we’re proceeding to resolve (no timer, no prompt context) ──
      (function sendAutoResolutionAck() {
        const ack = 'Noted. Resolving alert.';
        // Log like other outbound messages
        addLogEntry(`Sent "${ack}" to device.`, "step");

        // Optional: append to outbound thread or simulate send
        if (typeof window.appendOutgoingMessage === "function") {
          try { window.appendOutgoingMessage(ack, { auto: true }); } catch (_) {}
        } else if (typeof window.sendMessageToDevice === "function") {
          try { window.sendMessageToDevice(ack, /*auto*/ true); } catch (_) {}
        }
        // Do NOT set lastPromptSent or start any timers here
      })();

      break;

    case "callback":
      handleCallbackNote(noteText, analysis.timeframe);
      break;

    case "dispatch":
      handleDispatchNote(noteText);
      break;

    case "sos":
      handleSOSNote(noteText);
      break;
  }
}


      // Enhanced format timestamp function
      function formatTimestamp() {
        const now = new Date();
        return (
          now.toLocaleTimeString("en-US", {
            hour12: false,
            timeZone: "America/Denver",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
          }) + " MST"
        );
      }

      // Handle resolution-ready notes
      function handleResolutionNote(noteText, confidence) {
        // Auto-populate resolution dropdown if not already set
        const resolutionSelect = document.getElementById("resolution-reason");
        if (resolutionSelect && !resolutionSelect.value) {
          const resolutionType =
            typeof determineResolutionType === "function"
              ? determineResolutionType(currentAlert)
              : "false-alert-without-dispatch";
          resolutionSelect.value = resolutionType;
        }

        // Highlight resolution section
        const resolutionSection = document.querySelector(".resolution-section");
        if (resolutionSection) {
          resolutionSection.style.border = "3px solid #28a745";
          resolutionSection.style.background = "rgba(40, 167, 69, 0.1)";

          // Add pulsing animation for high confidence
          if (confidence > 0.8) {
            resolutionSection.style.animation = "pulse 2s infinite";
            setTimeout(() => {
              resolutionSection.style.animation = "none";
            }, 10000);
          }
        }

        // Auto-scroll to resolution
        setTimeout(() => {
          resolutionSection?.scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        }, 500);

        // Add resolution indicator to log
        addLogEntry(
          "🔔 RESOLUTION READY: Note indicates alert can be resolved",
          "system"
        );
      }

      // Handle callback timer notes
      function handleCallbackNote(noteText, timeframeMinutes) {
        // Extract contact name from note
        const contactName = extractContactName(noteText);
        const timeframeSeconds = timeframeMinutes * 60;

        // Start callback timer
        if (typeof startGlobalTimer === "function") {
          startGlobalTimer(
            "ec-callback",
            "EC Callback Timer",
            contactName || "Emergency Contact",
            timeframeSeconds,
            "callback"
          );
        }

        // Add timer confirmation to log
        addLogEntry(
          `⏰ AUTO-TIMER: ${timeframeMinutes} minute callback timer started for ${
            contactName || "Emergency Contact"
          }`,
          "system"
        );
      }

      // Handle dispatch request notes
      function handleDispatchNote(noteText) {
        // Highlight dispatch section if it exists
        const dispatchSection = document.querySelector('[id*="dispatch"]');
        if (dispatchSection) {
          dispatchSection.style.border = "3px solid #dc3545";
          dispatchSection.style.background = "rgba(220, 53, 69, 0.1)";
        }

        // Add dispatch indicator to log
        addLogEntry(
          "🚨 DISPATCH REQUESTED: Specialist note indicates dispatch needed",
          "system"
        );

        // Auto-scroll to dispatch section
        setTimeout(() => {
          dispatchSection?.scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        }, 500);
      }

      // Handle SOS confirmation notes
      function handleSOSNote(noteText) {
        // Add SOS indicator to log
        addLogEntry(
          "🆘 SOS CONFIRMED: Real emergency situation detected",
          "system"
        );

        // Could trigger immediate dispatch or escalation here
        if (typeof triggerImmediateDispatch === "function") {
          triggerImmediateDispatch();
        }
      }

      // Show confirmation of actions taken
      function showActionConfirmation(analysis) {
        if (analysis.type === "general") return;

        let message = "";
        switch (analysis.type) {
          case "resolution":
            message =
              "✅ Note detected as RESOLUTION READY - Resolution section highlighted";
            break;
          case "callback":
            message = `⏰ Callback timer started for ${analysis.timeframe} minutes`;
            break;
          case "dispatch":
            message =
              "🚨 Dispatch request detected - Dispatch section highlighted";
            break;
          case "sos":
            message =
              "🆘 SOS situation detected - Emergency protocols activated";
            break;
        }

        // Show temporary notification
        showTemporaryNotification(message, analysis.priority);
      }

      // Show temporary notification (semi-transparent, no sound)
      function showTemporaryNotification(message, priority = "normal") {
        // Create notification element
        const notification = document.createElement("div");
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 15px 20px;
          border-radius: 8px;
          color: white;
          font-weight: bold;
          z-index: 1000;
          max-width: 400px;
          backdrop-filter: blur(2px);
          border: 1px solid rgba(255, 255, 255, 0.3);
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          transform: translateX(100%);
          transition: transform 0.3s ease-in-out;
        `;

        // Set semi-transparent color based on priority
        const colors = {
          urgent: "rgba(220, 53, 69, 0.9)", // Semi-transparent red
          high: "rgba(255, 193, 7, 0.9)", // Semi-transparent orange
          medium: "rgba(40, 167, 69, 0.9)", // Semi-transparent green
          normal: "rgba(23, 162, 184, 0.9)", // Semi-transparent blue
        };

        notification.style.background = colors[priority] || colors.normal;
        notification.textContent = message;

        document.body.appendChild(notification);

        // Slide in animation
        setTimeout(() => {
          notification.style.transform = "translateX(0)";
        }, 10);

        // Remove after 4 seconds with slide out animation
        setTimeout(() => {
          notification.style.transform = "translateX(100%)";
          setTimeout(() => {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
            }
          }, 300);
        }, 4000);
      }

      function sendManualMessage() {
  const messageInput = document.getElementById("manual-message-input");
  const charCounter = document.getElementById("charCounter");
  const sendBtn = document.getElementById("sendMessageBtn");
  const msg = messageInput.value.trim();

  // Enhanced validation using our new validation function
  const validationResult = validateMessage(msg);
  if (!validationResult.valid) {
    showMessageError(validationResult.error);
    return;
  }

  // Clear any existing errors
  clearMessageError();

  // Normalize message: remove newlines, extra spaces, and spaces before punctuation
  const normalizedMsg = msg.trim()
    .replace(/\s*\n\s*/g, " ")     // Convert newlines to spaces
    .replace(/\s+/g, " ")          // Normalize multiple spaces
    .replace(/\s+([?!.,])/g, "$1") // Remove spaces before punctuation
    .trim();

  // DEBUG: Check what's actually being tested
  console.log("🔍 Original:", JSON.stringify(msg));
  console.log("🔍 Normalized:", JSON.stringify(normalizedMsg));

  // Determine message type and timer duration using comprehensive detection
  let messageInfo = { canonical: null, timerDuration: 120, timerMinutes: 2, shouldTimer: false };
  
  const helpTest = /^do you need help\??$/i.test(normalizedMsg);
  const okTest = /^are you ok\??$/i.test(normalizedMsg);
  const okayTest = /^are you okay\??$/i.test(normalizedMsg);
  const leaveTest = /^leave the area,? understood\??$/i.test(normalizedMsg);
  
  console.log("🔍 Pattern tests:", { helpTest, okTest, okayTest, leaveTest });
  
  if (helpTest) {
    messageInfo = { canonical: "Do you need help?", timerDuration: 120, timerMinutes: 2, shouldTimer: true };
  } else if (okTest) {
    messageInfo = { canonical: "Are you OK?", timerDuration: 120, timerMinutes: 2, shouldTimer: true };
  } else if (okayTest) {
    messageInfo = { canonical: "Are you okay?", timerDuration: 120, timerMinutes: 2, shouldTimer: true };
  } else if (leaveTest) {
    messageInfo = { canonical: "Leave the area, understood?", timerDuration: 300, timerMinutes: 5, shouldTimer: true };
  }

  // Format message for proper display on device
  const formattedMsg = formatMessageForDevice(msg);

  // Format message for log display (proper sentence case)
  const logMsg = formatMessageForLog(msg);

  // Log the message with proper format and timer info
  if (messageInfo.shouldTimer) {
    addLogEntry(
      `Sent "${logMsg}" to device. Waiting ${messageInfo.timerMinutes} minutes for reply.`,
      "step"
    );
  } else {
    addLogEntry(`Sent "${logMsg}" to device`, "step");
  }

  // Set context for response classification if timer is triggered
  if (messageInfo.shouldTimer) {
    // Use canonical if available; otherwise fall back to the clean log message
    lastPromptSent = messageInfo.canonical || logMsg;
    promptTimestamp = Date.now();

    protocolState.deviceMessageReceived = false;
    awaitingResponse = true;

    // Start timer with correct duration based on message type
    startMessageTimer(messageInfo.timerDuration);
  }

  console.log("Manual message sent:", formattedMsg);

  // Show "Message sent" feedback for 1 second
  showMessageSentFeedback(formattedMsg);

  // Update textarea with formatted version so user sees the proper format
  messageInput.value = formattedMsg;

  // Clear input and reset UI after feedback
  setTimeout(() => {
    messageInput.value = "";
    updateCharacterCounter();
    sendBtn.disabled = true;
  }, 1000);
}


      function shouldTriggerTimer(message) {
        const msg = message.trim().toLowerCase().replace(/\s+/g, " "); // normalize spacing and case

        // Standard protocol questions that expect responses trigger timers
        const protocolQuestions = [
          "do you need help?",
          "are you ok?",
          "are you okay?",
          "leave the area, understood?",
        ];

        // Check if the normalized message matches any protocol question
        return protocolQuestions.some((question) => {
          const normalizedQuestion = question.replace(/\s+/g, " ");
          return msg === normalizedQuestion;
        });
      }

      function formatMessageForDevice(message) {
        // Clean up common spacing issues
        let formatted = message.replace(/\s+\?/g, "?"); // Remove spaces before ?
        formatted = formatted.replace(/\s+!/g, "!"); // Remove spaces before !
        formatted = formatted.replace(/\s+,/g, ","); // Remove spaces before ,
        formatted = formatted.replace(/\s+\./g, "."); // Remove spaces before .

        // Handle common 2-line splits for readability
        if (formatted === "Do you need help?") {
          return "Do you need\nhelp?";
        }
        if (formatted === "Are you OK?" || formatted === "Are you okay?") {
          return "Are you OK?"; // Fits in one line
        }
        if (formatted === "Leave the area, understood?") {
          return "Leave the area,\nunderstood?";
        }

        return formatted;
      }

      // REPLACE THE ENTIRE formatMessageForLog FUNCTION WITH THIS:
      function formatMessageForLog(message) {
        const msg = message.trim();

        // Convert common protocol questions to proper sentence case for logs
        const logFormats = {
          "do you need help?": "Do you need help?",
          "are you ok?": "Are you OK?",
          "are you okay?": "Are you okay?",
          "leave the area, understood?": "Leave the area, understood?",
        };

        const normalized = msg.toLowerCase().replace(/\s+/g, " ");
        let formatted = logFormats[normalized] || msg;

        // Remove any line breaks that might cause awkward log display
        formatted = formatted.replace(/\n/g, " ").replace(/\s+/g, " ").trim();

        return formatted;
      }

      function startMessageTimer(durationSeconds) {
        // Use existing global timer system
        startGlobalTimer(
          "manual-message",
          "Manual Message",
          "Waiting for device response",
          durationSeconds
        );
      }

      function showMessageSentFeedback(message) {
        const counter = document.getElementById("charCounter");
        if (!counter) return;

        const originalText = counter.textContent;
        const originalColor = counter.style.color;

        counter.textContent = `✅ Message sent: "${message}"`;
        counter.style.color = "#28a745";
        counter.style.fontWeight = "bold";
      }

      function validateMessage(message) {
        if (!message || message.length === 0) {
          return { valid: false, error: "Message cannot be empty" };
        }

        const lines = message.split("\n");

        // Check line count
        if (lines.length > 2) {
          return { valid: false, error: "Maximum 2 lines allowed" };
        }

        // Check character count per line
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].length > 16) {
            return {
              valid: false,
              error: `Line ${i + 1} exceeds 16 characters (${
                lines[i].length
              }/16)`,
            };
          }
        }

        return { valid: true };
      }

      function handleAutoLineBreak(e) {
        const input = e.target;
        const lines = input.value.split("\n");

        // If we're typing and first line hits 16 chars, auto-move to line 2
        if (
          lines.length === 1 &&
          lines[0].length === 16 &&
          e.inputType === "insertText"
        ) {
          input.value += "\n";
          // Set cursor to start of line 2
          const newPos = 17; // 16 chars + 1 newline
          input.setSelectionRange(newPos, newPos);
          return;
        }

        // Prevent typing if we're on line 1 and it exceeds 16 chars
        if (lines.length === 1 && lines[0].length > 16) {
          input.value =
            lines[0].substring(0, 16) + "\n" + lines[0].substring(16);
          // Set cursor to appropriate position on line 2
          const excess = lines[0].length - 16;
          const newPos = 17 + Math.min(excess, 16); // Don't exceed line 2 limit
          input.setSelectionRange(newPos, newPos);
          return;
        }

        // REMOVED: Line 2 auto-truncation - let validation handle it
        // if (lines.length === 2 && lines[1].length > 16) {
        //   input.value = lines[0] + "\n" + lines[1].substring(0, 16);
        //   const newPos = lines[0].length + 1 + 16;
        //   input.setSelectionRange(newPos, newPos);
        //   return;
        // }

        // Prevent more than 2 lines
        if (lines.length > 2) {
          input.value = lines.slice(0, 2).join("\n");
          // Set cursor at end of line 2
          const newPos = input.value.length;
          input.setSelectionRange(newPos, newPos);
          return;
        }
      }

      function updateCharacterCounter() {
        const input = document.getElementById("manual-message-input");
        const counter = document.getElementById("charCounter");
        const sendBtn = document.getElementById("sendMessageBtn");

        if (!input || !counter || !sendBtn) return;

        const message = input.value;
        const lines = message.split("\n");

        let counterText = "";
        let isValid = true;

        if (lines.length === 1) {
          const remaining = 16 - lines[0].length;
          if (remaining >= 0) {
            counterText = `${remaining}/16 characters remaining`;
          } else {
            counterText = `Line 1: ${Math.abs(
              remaining
            )} characters over limit`;
            isValid = false;
          }
        } else if (lines.length === 2) {
          const line1Remaining = 16 - lines[0].length;
          const line2Remaining = 16 - lines[1].length;
          counterText = `Line 1: ${Math.max(
            0,
            line1Remaining
          )}/16 | Line 2: ${Math.max(0, line2Remaining)}/16`;
          if (line1Remaining < 0 || line2Remaining < 0) {
            isValid = false;
          }
        } else if (lines.length > 2) {
          counterText = "Too many lines (maximum 2)";
          isValid = false;
        }

        counter.textContent = counterText;
        counter.style.color = isValid ? "#666" : "#d32f2f";

        sendBtn.disabled = !isValid || message.trim().length === 0;
      }

      function showMessageError(errorText) {
        const counter = document.getElementById("charCounter");
        if (!counter) return;

        counter.textContent = `❌ ${errorText}`;
        counter.style.color = "#d32f2f";
        counter.style.fontWeight = "bold";
      }

      function clearMessageError() {
        // This happens automatically when updateCharacterCounter() runs
        updateCharacterCounter();
      }

      function receiveMessageFromDevice(text) {
        const messageList = document.getElementById("receivedMessages");
        if (!messageList) return;

        const li = document.createElement("li");
        li.classList.add("unread");
        li.textContent = text;
        messageList.prepend(li);

        setTimeout(() => li.classList.remove("unread"), 5000);
      }

      function splitIntoTwoLines(text) {
        return text; // Simple implementation
      }

      function triggerImmediateDispatch() {
        dispatchMade = true;
      }

      // Enhanced simulateDeviceResponse function - DROP-IN REPLACEMENT
      window.simulateDeviceResponse = function (
        responseText,
        isResponse = false
      ) {
        if (protocolState.deviceMessageReceived) return;

        protocolState.deviceMessageReceived = true;
        receiveMessageFromDevice(responseText);

        // Context-aware message classification
        const classification = classifyIncomingMessage(
          responseText,
          isResponse,
          lastPromptSent
        );
        handleMessageClassification(classification, responseText, isResponse);
      };

      // Context-aware message classifier
      function classifyIncomingMessage(responseText, isResponse, promptContext) {
  // Handle "Send help" - always SOS regardless of context
  if (responseText === "Send help") {
    return { action: "SOS", reason: "Emergency request" };
  }

  // NEW: Garbled/invalid device replies trigger SOS immediately
  try {
    if (
      isResponse &&
      typeof window.isGarbledMessage === "function" &&
      window.isGarbledMessage(responseText)
    ) {
      return { action: "SOS", reason: "Garbled/invalid message" };
    }
  } catch (_) {
    // no-op: classification should not break on detector errors
  }

  if (isResponse && promptContext) {
    // Contextual responses based on what question was asked
    if (promptContext === "Do you need help?") {
      if (responseText === "Yes")
        return { action: "SOS", reason: "Confirmed help needed" };
      if (responseText === "No")
        return { action: "RESOLUTION", reason: "No help needed" };
    } else if (promptContext === "Are you OK?") {
      if (responseText === "Yes")
        return { action: "RESOLUTION", reason: "Confirmed okay" };
      if (responseText === "No")
        return { action: "SOS", reason: "Not okay" };
    } else if (promptContext === "Leave the area, understood?") {
      if (responseText === "Yes" || responseText === "Understood") {
        return { action: "CONTINUE", reason: "Acknowledged evacuation" };
      }
      if (responseText === "No")
        return { action: "SOS", reason: "Refused evacuation" };
    }
  }

  // Spontaneous messages or fallback classification
  const clearResolutionMessages = ["Issue resolved", "False alarm", "I'm OK"];
  if (clearResolutionMessages.includes(responseText)) {
    return { action: "RESOLUTION", reason: "Status indicates resolution" };
  }

  // Default: continue protocol
  return { action: "CONTINUE", reason: "Standard message" };
}


function handleMessageClassification(classification, responseText, isResponse) {
  console.log("DEBUG: Message classification =", classification);
  console.log("DEBUG: Action =", classification.action);
  
  const { action, reason } = classification;
  const messageType = isResponse ? "reply message" : "message";
  
  // Use established gas alert detection
  const isGasAlert = window.isGasAlert?.(currentAlert) || false;

  switch (action) {
    case "SOS":
      // Cancel message timer using established pattern
      if (messageTimer) {
        clearTimeout(messageTimer);
        messageTimer = null;
        awaitingResponse = false;
      }
      
      // Cancel global timer to prevent conflicts and beeping
      if (globalTimerInterval) {
        cancelGlobalTimer();
      }

      addLogEntry(
        `Received '${responseText}' from device. Switching to SOS Protocol.`,
        "step"
      );
      
      protocolState.currentSOSStep = 1;

      // Set Step 2 status to "Waiting" instead of "Completed"
      const currentStepElement = document.getElementById("step-2");
      if (currentStepElement) {
        const statusBadge = document.getElementById("step-2-status");
        if (statusBadge) {
          statusBadge.textContent = "Waiting";
          statusBadge.classList.remove("completed");
          statusBadge.classList.add("waiting");
          statusBadge.style.background = "#ffc107";
          statusBadge.style.color = "#000";
          currentStepElement.style.animation = "pulse 2s infinite";
        }
      }

      // Auto-send confirmation message
      addLogEntry(
        `SOS Protocol - Step ${protocolState.currentSOSStep}: Sent "Do you need help?" to device, waiting 2 minutes for reply.`,
        "step"
      );

      // Set context for confirmation response
      lastPromptSent = "Do you need help?";
      promptTimestamp = Date.now();
      protocolState.deviceMessageReceived = false;
      awaitingResponse = true;

      // Start 2-minute timer for confirmation response
      messageTimer = setTimeout(() => {
        if (awaitingResponse) {
          const nextStep = protocolState.currentSOSStep + 1;
          addLogEntry(
            `SOS Protocol - No response received. Proceeding to Step ${nextStep}: ${SOS_PROTOCOL_STEPS[nextStep]}.`,
            "timer"
          );
          protocolState.currentSOSStep = nextStep;
          awaitingResponse = false;
          lastPromptSent = null;
          if (typeof proceedWithSOSProtocol === "function") {
            proceedWithSOSProtocol();
          }
        }
      }, 120000);

      // Start the visual countdown timer
      startGlobalTimer(
        "sos-confirmation",
        "SOS Confirmation", 
        "Emergency confirmation",
        120
      );
      break;

      case "RESOLUTION":
      // CRITICAL: For gas alerts, check gas levels FIRST before canceling any timers
      const isGasAlert = window.isGasAlert?.(currentAlert) || false;
      
      if (isGasAlert) {
        // Use established gas danger detection
        const dangerousNow = typeof isAnyGasDangerousNow === "function"
          ? isAnyGasDangerousNow()
          : typeof isGasLevelHigh === "function"
          ? isGasLevelHigh()
          : !isGasCurrentlyNormalized();

        if (dangerousNow) {
          addLogEntry(
            `Received '${responseText}' from device. Gas levels still HIGH - Continue actioning protocol.`,
            "step"
          );
          // DO NOT cancel timers, DO NOT proceed with resolution
          return; // Exit early - timer keeps running
        }
      }

      // Only proceed with timer cancellation and resolution if gas is normal (or not a gas alert)
      
      // Cancel message timer using established pattern
      if (messageTimer) {
        clearTimeout(messageTimer);
        messageTimer = null;
        awaitingResponse = false;
      }

      // Cancel global timer to stop visual countdown and prevent beeping
      if (globalTimerInterval) {
        cancelGlobalTimer();
      }

      // Use established timestamp formatting
      const tz = (window.TIMEZONES && (TIMEZONES.MT || TIMEZONES.MOUNTAIN)) || "America/Edmonton";
      const timestamp = (window.FORMATTERS && typeof FORMATTERS.timeOnly === "function"
        ? FORMATTERS.timeOnly(new Date(), tz)
        : new Intl.DateTimeFormat("en-CA", {
            timeZone: tz,
            hour12: false,
            hour: "2-digit",
            minute: "2-digit", 
            second: "2-digit",
          }).format(new Date())) + " MST";

      console.log("DEBUG: lastPromptSent =", lastPromptSent);
      console.log("DEBUG: responseText =", responseText);
      console.log("DEBUG: isSOSConfirmation =", lastPromptSent === "Do you need help?" && responseText === "No");

      if (isGasAlert) {
        // Continue with existing gas alert logging logic (this will only run if gas is normal)
        const isSOSConfirmation = lastPromptSent === "Do you need help?" && responseText === "No";
        
        // Use established gas reading helper
        const reading = getCurrentGasReading(); // { type, status, value, unit }
        const timeOnly = (window.FORMATTERS && typeof FORMATTERS.timeOnly === "function"
          ? FORMATTERS.timeOnly(new Date(), tz)
          : new Intl.DateTimeFormat("en-CA", {
              timeZone: tz,
              hour12: false,
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            }).format(new Date())) + " MST";
            
        const gasBlock = `Gas Type: ${reading.type}\nGas Level: ${reading.status}\nGas Reading: ${reading.type}: ${reading.value}${reading.unit} (${timeOnly})`;

        if (isSOSConfirmation) {
          addLogEntry(
            `[${timestamp}] Received '${responseText}' from device, confirming no SOS. Gas readings back to normal. Resolving alert.\n\n${gasBlock}`,
            "step"
          );
        } else {
          addLogEntry(
            `[${timestamp}] Received '${responseText}' from device, confirming user is okay. Gas readings back to normal. Resolving alert.\n\n${gasBlock}`,
            "step"
          );
        }
      } else {
        // Non-gas alert - simple format
        addLogEntry(
          `[${timestamp}] Received '${responseText}' from device, confirming user is okay. Resolving alert.`,
          "step"
        );
      }

      // AUTO-ACKNOWLEDGMENT: Send "Noted. Resolving alert." back to device
      addLogEntry('Sent "Noted. Resolving alert." to device.', "step");
      
      // Show in message history UI
      try {
        document.getElementById("receivedMessages").insertAdjacentHTML('afterbegin', 
          '<li style="color: #28a745; font-style: italic; font-weight: 500;">↗️ Noted. Resolving alert.</li>'
        );
      } catch (_) {}

      // Optional device integration
      try {
        if (window.appendOutgoingMessage) window.appendOutgoingMessage('Noted. Resolving alert.', { auto: true });
      } catch (_) {}
      try {
        if (window.sendMessageToDevice) window.sendMessageToDevice('Noted. Resolving alert.', true);
      } catch (_) {}

      // Use existing determineResolutionType function
      const resolutionSelect = document.querySelector(".resolution-section select");
      if (resolutionSelect) {
        const reason = determineResolutionType(currentAlert);
        resolutionSelect.value = reason;
      }

      // Visual indication that resolution is ready
      const resolutionSection = document.querySelector(".resolution-section");
      if (resolutionSection) {
        resolutionSection.style.border = "3px solid #28a745";
        resolutionSection.style.animation = "pulse 2s infinite";
        
        // Stop animation after 10 seconds
        setTimeout(() => {
          if (resolutionSection.style.animation) {
            resolutionSection.style.animation = "none";
            resolutionSection.style.border = "2px solid #dc3545";
          }
        }, 10000);
      }

      // Auto-scroll to resolution section
      setTimeout(() => {
        const resolutionSection = document.querySelector(".resolution-section");
        if (resolutionSection) {
          resolutionSection.scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        }
      }, 500);
      break;

    case "CONTINUE":
      addLogEntry(`📱 Message logged. Proceeding with protocol escalation.`, "step");
      break;
  }
}

// Make it callable from other scripts (and your simulator)
window.handleMessageClassification = handleMessageClassification;

      // Helper functions for testing
      window.testResponse = function (message) {
        console.log(`Testing device response: "${message}"`);
        simulateDeviceResponse(message, true);
      };

      window.setGasNormal = () => {
        document.getElementById("h2s-value").textContent = "1.20 ppm";
        document.getElementById("h2s-status").textContent = "NORMAL";
        document.getElementById("h2s-status").className = "gas-status normal";
      };

      window.setGasHigh = () => {
        document.getElementById("h2s-value").textContent = "17.90 ppm";
        document.getElementById("h2s-status").textContent = "HIGH";
        document.getElementById("h2s-status").className = "gas-status high";
      };

      function proceedWithSOSProtocol() {
        // Cancel the expired timer to stop beeping
        if (globalTimerInterval) {
          clearInterval(globalTimerInterval);
          globalTimerInterval = null;
        }

        // Stop any alarm sounds
        if (tabFlashInterval) {
          clearInterval(tabFlashInterval);
          tabFlashInterval = null;
          document.title = originalTitle;
        }
      }

      // Function to send contextual messages (for future use)
      function sendContextualMessage(promptText) {
        lastPromptSent = promptText;
        promptTimestamp = Date.now();
        addLogEntry(`📤 Sent "${promptText}" to device`, "step");

        // Reset device message received flag to allow new responses
        protocolState.deviceMessageReceived = false;
      }

      window.setGasLevel = function (gas, value) {
        const gasData =
          gasReadingsData[
            currentAlert ? currentAlert.gasType || currentAlert.id : "default"
          ] || gasReadingsData.default;
        if (gasData[gas]) {
          gasData[gas].value = value;
          gasData[gas].status = value >= 10 ? "HIGH" : "NORMAL";
          updateGasReadings(
            currentAlert ? currentAlert.gasType || currentAlert.id : "default"
          );
          console.log("Set " + gas.toUpperCase() + " to " + value);
        }
      };

      // Demo functions for testing device connectivity
      window.setDeviceOffline = function (reason = "battery") {
        DeviceConnectivity.setDeviceOfflineScenario(reason);
        console.log(`Device set to OFFLINE (reason: ${reason})`);
        console.log("Current status:", DeviceConnectivity.currentStatus);
      };

      window.setDeviceOnline = function () {
        DeviceConnectivity.setDeviceOnlineScenario();
        console.log("Device set to ONLINE");
        console.log("Current status:", DeviceConnectivity.currentStatus);
      };

      window.testBatteryDead = function () {
        setDeviceOffline("battery");
      };
      window.testSignalLost = function () {
        setDeviceOffline("signal");
      };
      window.testCommunicationTimeout = function () {
        setDeviceOffline("communication");
      };

      window.checkDeviceStatus = function () {
        const status = DeviceConnectivity.currentStatus;
        const isOnline = DeviceConnectivity.isDeviceOnline();
        console.log("=== DEVICE STATUS CHECK ===");
        console.log("Last Communication:", status.lastCommunication);
        console.log("Battery:", status.battery + "%");
        console.log("Signal:", status.signal + "%");
        console.log(
          "Device Online Status:",
          isOnline ? "🟢 ONLINE" : "🔴 OFFLINE"
        );
        return isOnline;
      };

      // ═══════════════════════════════════════════════════════════════
      // 🚑 ENHANCED DISPATCH STEP MANAGEMENT
      // ═══════════════════════════════════════════════════════════════

      function generateDispatchProtocolLog(
        decision,
        reason,
        selectedService,
        stepId
      ) {
        const getStep = (sid) =>
          typeof getStepLabel === "function"
            ? getStepLabel(sid)
            : String(sid).replace(/^step-/, "Step ");
        const stepLabel = getStep(stepId);

        // DOM pulls
        const locationElement = document.getElementById("device-location");
        const coordinatesElement =
          document.getElementById("device-coordinates");
        const speedElement = document.getElementById("device-speed");
        const locationTimestamp = document.getElementById("location-timestamp");
        const lastCommElement = document.getElementById("last-comm-time");
        const batteryElement = document.getElementById("battery-level");
        const signalElement = document.getElementById("signal-strength");

        // Helpers
        const timeAgoSuffix = (dateTimeString) => {
          if (!dateTimeString) return "";
          // Accepts "Aug 02, 2025 at 15:28 MDT"
          const clean = String(dateTimeString)
            .replace(" at ", " ")
            .replace(/\s+\b[A-Z]{2,4}\b$/, "");
          const dt = new Date(clean);
          if (isNaN(dt)) return "";
          const diffMin = Math.floor((Date.now() - dt.getTime()) / 60000);
          if (diffMin < 1) return " (just now)";
          if (diffMin < 60)
            return ` (${diffMin} minute${diffMin === 1 ? "" : "s"} ago)`;
          const h = Math.floor(diffMin / 60);
          if (h < 24) return ` (${h} hour${h === 1 ? "" : "s"} ago)`;
          const d = Math.floor(h / 24);
          return ` (${d} day${d === 1 ? "" : "s"} ago)`;
        };

        // looser parser for "00:26 MDT" or "13:31 MDT"
        const timeAgoSuffixLoose = (text) => {
          if (!text) return "";
          const cleaned = String(text)
            .replace(
              /\s*\((?:just now|\d+\s+(?:minute|minutes|hour|hours|day|days)\s+ago)\)\s*$/i,
              ""
            )
            .replace(
              /\b(ACDT|ACST|ADT|AEDT|AEST|AKDT|AKST|AST|BST|CDT|CEST|CET|CLT|COT|CST|EDT|EEST|EET|EST|GMT|HKT|IST|JST|MDT|MST|MSK|NZDT|NZST|PDT|PET|PKT|PST|UTC|WET|WEST)\b/gi,
              ""
            )
            .trim();

          const looksLikeTimeOnly = /^\d{1,2}:\d{2}$/.test(cleaned);
          const compose = looksLikeTimeOnly
            ? `${new Date().toDateString()} ${cleaned}`
            : cleaned;

          const dt = new Date(compose);
          if (isNaN(dt)) return "";
          const diffMin = Math.floor((Date.now() - dt.getTime()) / 60000);
          if (diffMin < 1) return " (just now)";
          if (diffMin < 60)
            return ` (${diffMin} minute${diffMin === 1 ? "" : "s"} ago)`;
          const h = Math.floor(diffMin / 60);
          if (h < 24) return ` (${h} hour${h === 1 ? "" : "s"} ago)`;
          const d = Math.floor(h / 24);
          return ` (${d} day${d === 1 ? "" : "s"} ago)`;
        };

        // Header
        let logEntry = "";
        if (decision === "yes") {
          logEntry = `${stepLabel}: Called dispatch. Dispatched ${
            selectedService || "Emergency Services"
          } to the following location:`;
        } else {
          logEntry = `${stepLabel}: Unable to dispatch - ${reason}:`;
        }

        // Location block
        logEntry += `\n\nLast Known Location:`;
        if (locationElement)
          logEntry += `\nAddress: ${locationElement.textContent}`;
        if (coordinatesElement)
          logEntry += `\nGPS Coordinates: ${coordinatesElement.textContent}`;
        if (speedElement) logEntry += `\nSpeed: ${speedElement.textContent}`;
        if (locationTimestamp) {
          const ts = locationTimestamp.textContent;
          logEntry += `\nLast Location Date/Time: ${ts}${timeAgoSuffix(ts)}`;
        }

        // Device status block (always for YES; for NO include when likely relevant)
        const includeStatus =
          decision === "yes" ||
          /offline|location|moving/i.test(String(reason || ""));
        if (includeStatus) {
          logEntry += `\n\nDevice Status`;
          if (lastCommElement) {
            const lc = lastCommElement.textContent;
            logEntry += `\nLast Communication: ${lc}${timeAgoSuffixLoose(lc)}`;
          }
          if (batteryElement)
            logEntry += `\nBattery: ${batteryElement.textContent}`;
          if (signalElement)
            logEntry += `\nSignal: ${signalElement.textContent}`;
        }

        return logEntry;
      }

      function callDispatch() {
  console.log("DEBUG: callDispatch() called - setting dispatchMade = true");

  // Set both global and protocolState flags
  dispatchMade = true;
  if (window.protocolState) {
    protocolState.dispatchMade = true;
  }

  console.log("DEBUG: dispatchMade is now:", dispatchMade);
  console.log("DEBUG: protocolState.dispatchMade is now:", protocolState.dispatchMade);

  // Existing SOS dispatch flow...
  const serviceDropdown = document.getElementById("dispatch");
  const selectedService = serviceDropdown ? serviceDropdown.value : "";
  const serviceToDispatch = selectedService || "Emergency Services";

  const currentDispatchStep =
    document
      .querySelector('.step.active [onclick*="callDispatch"]')
      ?.closest(".step")?.id || "step-5";

  const logEntry = generateDispatchProtocolLog("yes", "", serviceToDispatch, currentDispatchStep);
  addLogEntry(logEntry, "step");

  startGlobalTimer(currentDispatchStep, "Dispatch Callback", serviceToDispatch, 1800);

  updateDispatchUI();

  const resolutionSelect = document.getElementById("resolution-reason");
  if (resolutionSelect && !resolutionSelect.value) {
    const resolutionType = determineResolutionType(currentAlert);
    resolutionSelect.value = resolutionType;
  }
}


      function handleDispatchDecision(stepId) {
        const decisionElement = document.getElementById("dispatch-decision");
        const serviceContainer = document.getElementById(
          "service-type-container"
        );
        const skipContainer = document.getElementById("skip-reason-container");
        const notesArea = document.getElementById(stepId + "-note"); // ← Now dynamic

        // Safety check - only proceed if elements exist
        if (!decisionElement || !serviceContainer || !skipContainer) {
          return;
        }

        const decision = decisionElement.value;

        if (decision === "yes") {
          serviceContainer.style.display = "block";
          skipContainer.style.display = "none";
          if (notesArea)
            notesArea.placeholder =
              "Document dispatch details and service response...";
        } else if (decision === "no") {
          serviceContainer.style.display = "none";
          skipContainer.style.display = "block";
          if (notesArea)
            notesArea.placeholder = "Document why dispatch was not required...";
        } else {
          serviceContainer.style.display = "none";
          skipContainer.style.display = "none";
          if (notesArea) notesArea.placeholder = "Document the result...";
        }
      }

      /**
       * Evaluate if dispatch should be recommended based on technical conditions
       */
      function evaluateDispatchConditions() {
        const conditions = {
          shouldDispatch: false,
          passingConditions: [],
          failingReasons: [],
          primarySkipReason: null,
        };

        // ── helpers (local only) ────────────────────────────────────────────────
        const toNum = (s) => {
          const m = String(s || "").match(/-?\d+(\.\d+)?/);
          return m ? Number(m[0]) : NaN;
        };

        const parseMins = (txt) => {
          const t = String(txt || "").toLowerCase();
          const m = t.match(/(\d+)\s*min/);
          if (m) return Number(m[1]);
          const h = t.match(/(\d+)\s*hour/);
          if (h) return Number(h[1]) * 60;
          const a = t.match(/(\d+).*ago/);
          return a ? Number(a[1]) : NaN;
        };

        // NEW: handles absolute timestamps like "Aug 02, 2025 at 15:28 MDT"
        const parseAbsMins = (txt) => {
          const raw = String(txt || "").trim();
          if (!raw) return NaN;
          const norm = raw
            .replace(" at ", " ")
            .replace(/\s([A-Z]{2,4})\.?$/, "");
          const d = new Date(norm);
          return isNaN(d.getTime())
            ? NaN
            : Math.floor((Date.now() - d.getTime()) / 60000);
        };

        // ── user confirmation check (triggers resolution flow) ──────────────────
        const userConfirmedOK =
          typeof checkIfUserConfirmedOK === "function" &&
          checkIfUserConfirmedOK();
        const ecConfirmedOK =
          typeof checkIfECConfirmedUserOK === "function" &&
          checkIfECConfirmedUserOK();

        // If user confirmed OK → trigger resolution flow (no dispatch needed)
        if (userConfirmedOK) {
          conditions.failingReasons.push("User confirmed they are okay");
          conditions.primarySkipReason = "user-confirmed-ok";
          conditions.shouldDispatch = false;
          return conditions; // Early exit → resolution flow
        }

        if (ecConfirmedOK) {
          conditions.failingReasons.push(
            "Emergency contact confirmed user is okay"
          );
          conditions.primarySkipReason = "ec-confirmed-ok";
          conditions.shouldDispatch = false;
          return conditions; // Early exit → resolution flow
        }

        // ── universal dispatch gates (technical readiness only) ─────────────────
        const CT = window.CONNECTIVITY_THRESHOLDS || {
          lastCommMins: 30,
          batteryPct: 10,
          signalPct: 10,
        };
        const LT =
          (window.TIMEOUTS &&
            Number(window.TIMEOUTS.LOCATION_MAX_AGE_MINUTES)) ||
          5; // minutes
        const MOV =
          (window.TIMEOUTS && Number(window.TIMEOUTS.MOVING_MAX_SPEED_KMH)) ||
          5; // km/h

        // Read Connectivity Panel
        const lastCommEl = document.getElementById("last-comm-time");
        const batteryEl = document.getElementById("battery-level");
        const signalEl = document.getElementById("signal-strength");
        const locTsEl = document.getElementById("location-timestamp");
        const speedEl = document.getElementById("device-speed");

        const minsLastComm = parseMins(lastCommEl?.textContent);
        const batt = toNum(batteryEl?.textContent);
        const signal = toNum(signalEl?.textContent);
        const minsLocAge = parseAbsMins(locTsEl?.textContent);
        const speedKph = toNum(speedEl?.textContent);

        // 1) device offline check
        let isOffline = false;
        const offlineBits = [];
        if (!Number.isNaN(minsLastComm) && minsLastComm > CT.lastCommMins) {
          isOffline = true;
          offlineBits.push(`last comm ${minsLastComm} min ago`);
        }
        if (!Number.isNaN(batt) && batt <= CT.batteryPct) {
          isOffline = true;
          offlineBits.push(`battery ${batt}%`);
        }
        if (!Number.isNaN(signal) && signal <= CT.signalPct) {
          isOffline = true;
          offlineBits.push(`signal ${signal}%`);
        }
        if (isOffline) {
          const pretty = offlineBits.length
            ? `device offline (${offlineBits.join(", ")})`
            : "device offline";
          conditions.failingReasons.push(pretty);
          conditions.primarySkipReason ||= "device-offline";
        }

        // 2) location not current check
        const isLocStale = !Number.isNaN(minsLocAge) && minsLocAge > LT;
        if (isLocStale) {
          let ageText;
          if (minsLocAge < 60) {
            ageText = `${minsLocAge} min old`;
          } else if (minsLocAge < 1440) {
            const hours = Math.floor(minsLocAge / 60);
            ageText = `${hours} hour${hours === 1 ? "" : "s"} old`;
          } else {
            const days = Math.floor(minsLocAge / 1440);
            ageText = `${days} day${days === 1 ? "" : "s"} old`;
          }

          conditions.failingReasons.push(`location not current (${ageText})`);
          conditions.primarySkipReason ||= "location-stale";
        }

        // 3) device not stationary check
        const isMoving = !Number.isNaN(speedKph) && speedKph > MOV;
        if (isMoving) {
          conditions.failingReasons.push(
            `device not stationary (speed ${speedKph} km/h)`
          );
          conditions.primarySkipReason ||= "device-moving";
        }

        // ── GAS POLICY (override when safe) ──────────────────────────────────────
        let anyGasDanger = false;
        let isGasNow = false;
        try {
          isGasNow =
            typeof isGasAlert === "function" ? isGasAlert(currentAlert) : false;
          if (isGasNow) {
            const U = (id) =>
              (document.getElementById(id)?.textContent || "").toUpperCase();
            const dangerO2 = /ENRICHED|ENRICHMENT|DEPLETED|DEPLETION/.test(
              U("o2-status")
            );
            const dangerOthers =
              /\bHIGH\b/.test(U("h2s-status")) ||
              /\bHIGH\b/.test(U("co-status")) ||
              /\bHIGH\b/.test(U("lel-status"));
            anyGasDanger = !!(dangerO2 || dangerOthers);
          }
        } catch (e) {
          console.warn("Gas rule check failed:", e);
        }

        // ── final technical readiness decision ──────────────────────────────────
        const connectivityOK = !isOffline;
        const locationOK = !isLocStale;
        const motionOK = !isMoving;

        // If this is a gas alert and gas is NOT dangerous anymore, force NO dispatch
        try {
          const isGas =
            typeof isGasAlert === "function" ? isGasAlert(currentAlert) : false;
          if (isGas && !anyGasDanger) {
            conditions.shouldDispatch = false;
            if (
              !conditions.failingReasons.includes(
                "Gas levels returned to normal"
              )
            ) {
              conditions.failingReasons.unshift(
                "Gas levels returned to normal"
              );
            }
            conditions.primarySkipReason ||= "gas-normalized";
            return conditions; // Early return
          }
        } catch {
          /* no-op */
        }

        // Suggest "Yes" if all technical conditions are met
        conditions.shouldDispatch = connectivityOK && locationOK && motionOK;

        // Add positive conditions for clarity
        if (connectivityOK) {
          conditions.passingConditions.push("Device connectivity OK");
        }
        if (locationOK) {
          conditions.passingConditions.push("Location data current");
        }
        if (motionOK) {
          conditions.passingConditions.push("Device stationary");
        }

        // For gas alerts, add gas status
        try {
          const isGas =
            typeof isGasAlert === "function" ? isGasAlert(currentAlert) : false;
          if (isGas && anyGasDanger) {
            if (
              !conditions.passingConditions.includes("Gas levels dangerous")
            ) {
              conditions.passingConditions.unshift("Gas levels dangerous");
            }
          }
        } catch {
          /* no-op */
        }

        return conditions;
      }

      function silentlyUpdateDispatchConditions() {
        const dispatchDropdown = document.getElementById("dispatch-decision");
        const unmetDropdown = document.getElementById("skip-reason");
        if (!dispatchDropdown) return;

        let conditions;
        try {
          conditions = evaluateDispatchConditions();
        } catch {
          conditions =
            typeof evaluateDispatchConditionsFromConnectivity === "function"
              ? evaluateDispatchConditionsFromConnectivity()
              : {
                  shouldDispatch: false,
                  failingReasons: [],
                  primarySkipReason: null,
                };
        }

        const newValue = conditions.shouldDispatch ? "yes" : "no";

        // Only do heavy UI updates when value actually changes
        if (dispatchDropdown.value !== newValue) {
          dispatchDropdown.value = newValue;

          const serviceContainer = document.getElementById(
            "service-type-container"
          );
          const skipContainer = document.getElementById(
            "skip-reason-container"
          );

          if (newValue === "yes") {
            window.dispatchMade = true;
if (window.protocolState) window.protocolState.dispatchMade = true;
            if (serviceContainer) serviceContainer.style.display = "block";
            if (skipContainer) skipContainer.style.display = "none";
          } else {
            if (serviceContainer) serviceContainer.style.display = "none";
            if (skipContainer) skipContainer.style.display = "block";

            // --- auto-populate skip reason ----------------------------
            if (unmetDropdown) {
              const key = (conditions.primarySkipReason || "").toLowerCase();
              const firstFail = (
                conditions.failingReasons?.[0] || ""
              ).toLowerCase();

              // Pick the best-fit reason (now includes gas)
              let auto =
                key ||
                (firstFail.includes("gas level") ||
                firstFail.includes("gas-normal")
                  ? "gas-normalized"
                  : firstFail.includes("offline")
                  ? "device-offline"
                  : firstFail.includes("location")
                  ? "location-stale"
                  : firstFail.includes("moving")
                  ? "device-moving"
                  : "");

              if (auto) unmetDropdown.value = auto;

              // --- auto-populate note box (dynamic step detection) ---
              const dispatchStep = dispatchDropdown.closest(".step");
              const noteBox =
                dispatchStep?.querySelector("textarea") ||
                document.getElementById(dispatchStep?.id + "-note") ||
                document.querySelector(
                  "#skip-reason-container textarea, #service-type-container textarea"
                );

              if (noteBox) {
                if (unmetDropdown.value === "gas-normalized") {
                  // Check if gas data already exists before adding more
                  if (
                    !/Gas Type:|Gas Reading:|⚠️ Gas levels still HIGH/i.test(
                      noteBox.value
                    )
                  ) {
                    // Build gas snapshot with timestamp
                    let block = "";
                    try {
                      block =
                        typeof getGasSnapshotFromPanel === "function"
                          ? getGasSnapshotFromPanel()
                          : "";
                      if (block) {
                        const now = new Date();
                        const ts =
                          typeof FORMATTERS?.timestampMST === "function"
                            ? FORMATTERS.timestampMST(now)
                            : new Intl.DateTimeFormat("en-US", {
                                timeZone: "America/Denver",
                                year: "numeric",
                                month: "2-digit",
                                day: "2-digit",
                                hour: "2-digit",
                                minute: "2-digit",
                                second: "2-digit",
                                hour12: false,
                              }).format(now) + " MDT";
                        block = block.replace(
                          /(Gas Reading:\s*[^\n]+)/i,
                          `$1 (${ts})`
                        );
                      }
                    } catch {}

                    noteBox.value =
                      "Gas levels back to normal." +
                      (block ? `\n\n${block}` : "");
                  }
                } else if (!noteBox.value.trim()) {
                  // Fallback: copy the selected reason label to notes
                  const label =
                    unmetDropdown.options[unmetDropdown.selectedIndex]?.text ||
                    "";
                  if (label) noteBox.value = label;
                }
              }
            }
          }

          // Notify any listeners and re-validate with dynamic step detection
          dispatchDropdown.dispatchEvent(
            new Event("change", { bubbles: true })
          );

          // Dynamic step detection for validation
          const dispatchStep = dispatchDropdown.closest(".step");
          const dispatchStepId = dispatchStep?.id;

          if (typeof validatePostButton === "function" && dispatchStepId) {
            validatePostButton(dispatchStepId);
          }
        } else {
          // Even if value didn't change, ensure dispatch button reflects current state
          const dispatchStep = dispatchDropdown.closest(".step");
          const dispatchStepId = dispatchStep?.id;

          if (
            newValue === "no" &&
            typeof validatePostButton === "function" &&
            dispatchStepId
          ) {
            validatePostButton(dispatchStepId);
          }
        }

        // --- color-coding (unchanged) --------------------------------
        if (dispatchDropdown.value === "yes") {
          dispatchDropdown.style.backgroundColor = "#d4edda";
          dispatchDropdown.style.borderColor = "#28a745";
          dispatchDropdown.style.color = "#155724";
          dispatchDropdown.style.borderWidth = "2px";
        } else if (dispatchDropdown.value === "no") {
          dispatchDropdown.style.backgroundColor = "#f8d7da";
          dispatchDropdown.style.borderColor = "#dc3545";
          dispatchDropdown.style.color = "#721c24";
          dispatchDropdown.style.borderWidth = "2px";
        } else {
          dispatchDropdown.style.backgroundColor = "#ffffff";
          dispatchDropdown.style.borderColor = "#ddd";
          dispatchDropdown.style.color = "#333";
          dispatchDropdown.style.borderWidth = "1px";
        }
      }

      function checkIfUserConfirmedOK() {
        // Check if any step had "confirmed OK" outcome
        return protocolState.completedSteps.some((stepId) => {
          const select = document.getElementById(stepId + "-select");
          return select && select.value === "confirmed-ok";
        });
      }

      function checkIfECConfirmedUserOK() {
        // Check Emergency Contacts step outcomes for EC confirmation
        const ecStepId = getEmergencyContactsStepId();
        if (!ecStepId) return false;

        const ecSelect = document.getElementById(ecStepId + "-select");
        return ecSelect && ecSelect.value === "confirmed-ok";
      }

      function generateDispatchNotes(conditions) {
        // Base header
        let notes = "Dispatch: Decision Analysis\n\n";

        // === Read live Connectivity Panel values (no external helpers) ===
        const lastCommEl = document.getElementById("last-comm-time");
        const batteryEl = document.getElementById("battery-level");
        const signalEl = document.getElementById("signal-strength");

        const num = (s) => {
          const m = String(s || "").match(/-?\d+(\.\d+)?/);
          return m ? Number(m[0]) : NaN;
        };
        const parseLastCommMins = (txt) => {
          const t = String(txt || "").toLowerCase();
          if (t.includes("min")) {
            const m = num(t);
            return Number.isNaN(m) ? NaN : m;
          }
          if (t.includes("hour")) {
            const h = num(t);
            return Number.isNaN(h) ? NaN : Math.round(h * 60);
          }
          if (t.includes("ago")) {
            const m = num(t);
            return Number.isNaN(m) ? NaN : m;
          }
          return NaN;
        };

        const lastCommTxt = lastCommEl?.textContent || "";
        const battTxt = batteryEl?.textContent || "";
        const sigTxt = signalEl?.textContent || "";

        const mins = parseLastCommMins(lastCommTxt); // "47 min ago" -> 47
        const batt = num(battTxt); // "7%" -> 7
        const signal = num(sigTxt); // "9%" -> 9

        // Build an inline, human-friendly offline detail from the panel
        const offlineParts = [];
        if (!Number.isNaN(mins)) offlineParts.push(`last comm ${mins} min ago`);
        if (!Number.isNaN(batt)) offlineParts.push(`battery ${batt}%`);
        if (!Number.isNaN(signal)) offlineParts.push(`signal ${signal}%`);
        const offlineDetail = offlineParts.length
          ? `device offline (${offlineParts.join(", ")})`
          : "device offline";

        // === Compose notes ===
        if (conditions.shouldDispatch) {
          notes += "DISPATCH REQUIRED:\n";
          (conditions.passingConditions || []).forEach((condition) => {
            notes += "✓ " + condition + "\n";
          });
          notes += "\nDispatching emergency services per protocol.";
        } else {
          notes += "DISPATCH NOT REQUIRED:\n";

          // Print failing reasons, but upgrade any "device offline" text with live panel detail
          (conditions.failingReasons || []).forEach((reason) => {
            const pretty = /device\s*offline/i.test(String(reason))
              ? offlineDetail
              : String(reason);
            notes += "✗ " + pretty + "\n";
          });

          notes += "\nNo emergency services dispatch needed.";
        }

        // Optional: include a short connectivity snapshot at the bottom (kept plain text)
        // You can delete this block if you don't want the snapshot in notes.
        const anyPanel = lastCommTxt || battTxt || sigTxt;
        if (anyPanel) {
          notes += "\n\nConnectivity Snapshot";
          if (lastCommTxt) notes += "\nLast Communication: " + lastCommTxt;
          if (batteryEl) notes += "\nBattery: " + battTxt;
          if (signalEl) notes += "\nSignal: " + sigTxt;
        }

        return notes;
      }

      function updateDispatchUI() {
        // Enhanced visual feedback for dispatch actions
        const serviceContainer = document.getElementById(
          "service-type-container"
        );
        const dispatchStatus = document.getElementById("dispatch-status");

        if (serviceContainer && dispatchMade) {
          serviceContainer.style.background = "#d4edda";
          serviceContainer.style.borderColor = "#28a745";

          // Disable the service dropdown after dispatch
          const serviceDropdown = document.getElementById("service-dropdown");
          if (serviceDropdown) {
            serviceDropdown.disabled = true;
            serviceDropdown.style.opacity = "0.7";
          }

          // Update dispatch button
          const dispatchBtn = serviceContainer.querySelector("button");
          if (dispatchBtn) {
            dispatchBtn.disabled = true;
            dispatchBtn.innerHTML = "✅ Dispatch Completed";
            dispatchBtn.classList.remove("btn-danger");
            dispatchBtn.classList.add("btn-success");
          }
        }

        if (dispatchStatus && dispatchMade) {
          dispatchStatus.style.display = "block";
        }
      }

      function enhanceStepVisual(stepId) {
        // Add special styling for dispatch step when active
        const step = document.getElementById(stepId);
        if (step) {
          step.style.background = "linear-gradient(135deg, #fff3cd, #ffeaa7)";
          step.style.border = "2px solid #ffc107";
        }
      }

      function validateDispatchDecision() {
        const decisionEl = document.getElementById("dispatch-decision");
        if (!decisionEl) return false;

        const currentDispatchStep = document
          .querySelector(".step.active #dispatch-decision")
          ?.closest(".step")?.id;

        const dispatchNote = currentDispatchStep
          ? document.getElementById(currentDispatchStep + "-note")
          : null;

        let isValid = false;

        if (decisionEl.value === "yes") {
          const dispatchType =
            document.getElementById("service-dropdown") ||
            document.getElementById("dispatch");
          isValid = !!(
            dispatchType &&
            dispatchType.value &&
            dispatchNote &&
            dispatchNote.value.trim()
          );
        } else if (decisionEl.value === "no") {
          const skipReason = document.getElementById("skip-reason");
          isValid = !!(
            skipReason &&
            skipReason.value &&
            dispatchNote &&
            dispatchNote.value.trim()
          );
        }

        return isValid;
      }

      function logDispatchDecision(stepId) {
        // ← Add stepId parameter
        // Comprehensive logging for dispatch decisions
        const decision = document.getElementById("dispatch-decision").value;
        const gasReading = getCurrentGasReading();

        if (decision === "yes") {
          const services = getSelectedServices();
          const servicesText =
            services.length > 0 ? services.join(", ") : "Emergency Services";

          let logMessage =
            getStepLabel(stepId) +
            ": Dispatch decision - YES. Services: " +
            servicesText;

          if (currentAlert && currentAlert.id === "gas-high-threshold") {
            logMessage +=
              ". Gas level: " +
              gasReading.status +
              " – Gas Reading: " +
              gasReading.type +
              ": " +
              gasReading.value +
              gasReading.unit;
          }

          addLogEntry(logMessage, "step");
        } else if (decision === "no") {
          const skipReason = document.getElementById("skip-reason");
          const reasonText = skipReason.options[skipReason.selectedIndex].text;

          let logMessage =
            getStepLabel(stepId) +
            ": Dispatch decision - NO. Reason: " +
            reasonText;

          if (currentAlert && currentAlert.id === "gas-high-threshold") {
            logMessage +=
              ". Gas level: " +
              gasReading.status +
              " – Gas Reading: " +
              gasReading.type +
              ": " +
              gasReading.value +
              gasReading.unit;
          }

          addLogEntry(logMessage, "step");
        }
      }

      // ═══════════════════════════════════════════════════════════════
      // 🚑 DISPATCH CONDITION CHECKER (UPDATED)
      // ═══════════════════════════════════════════════════════════════

      function checkDispatchConditions(stepId) {
        console.log("checkDispatchConditions called for:", stepId);

        // Visual tweaks (kept)
        try {
          enhanceStepVisual(stepId);
        } catch (e) {
          /* no-op */
        }

        // Show the outcome section for whatever step invoked this
        const outcomeSection = document.getElementById(stepId + "-outcome");
        if (outcomeSection) outcomeSection.style.display = "block";

        // 👇 Single source of truth: let the unified updater compute & set everything
        const runUnified = () => {
          if (typeof silentlyUpdateDispatchConditions === "function") {
            silentlyUpdateDispatchConditions(); // sets dropdown, skip reason, textarea (gas), fires change
          }
        };

        // Do it now and on the next paint to beat any race with DOM rendering
        runUnified();
        requestAnimationFrame(runUnified);
        setTimeout(runUnified, 0);

        // (Optional) keep resolution reason auto-fill if empty
        try {
          const resolutionSelect = document.getElementById("resolution-reason");
          if (resolutionSelect && !resolutionSelect.value) {
            const resolutionType =
              typeof determineResolutionType === "function"
                ? determineResolutionType(currentAlert)
                : "";
            if (resolutionType) resolutionSelect.value = resolutionType;
          }
        } catch (e) {
          console.warn(
            "checkDispatchConditions: resolution select fill failed:",
            e
          );
        }

        // NOTE:
        // - We no longer call evaluateDispatchConditionsFromConnectivity() here.
        // - We do not directly set #dispatch-decision or #skip-reason here.
        //   silentlyUpdateDispatchConditions() already sets them AND dispatches a 'change' event.
        // - We do not call handleDispatchDecision() here; any listeners bound to the
        //   dropdown's change event will run because the unified updater fires it.
      }

      function evaluateDispatchConditionsFromConnectivity() {
        const conditions = {
          deviceOnline: false,
          locationFresh: false,
          deviceStationary: false,
        };
        const failedReasons = [];
        const passedReasons = [];

        // Check if we have perfect conditions from currentAlert
        if (currentAlert && currentAlert.deviceConditions) {
          const dc = currentAlert.deviceConditions;

          // Condition 1: Device Online
          conditions.deviceOnline =
            dc.lastComm < 30 && dc.battery > 10 && dc.signal > 10;
          if (conditions.deviceOnline) {
            passedReasons.push("Device online");
          } else {
            failedReasons.push("Device offline");
          }

          // Condition 2: Location Fresh (< 5 min old)
          conditions.locationFresh = dc.locationAge < 5;
          if (conditions.locationFresh) {
            passedReasons.push("Location fresh");
          } else {
            failedReasons.push("Location not valid or current");
          }

          // Condition 3: Device Stationary (< 5 km/h)
          conditions.deviceStationary = dc.deviceSpeed < 5;
          if (conditions.deviceStationary) {
            passedReasons.push("Device stationary");
          } else {
            failedReasons.push("Device not stationary (≥ 5 km/h)");
          }
        } else {
          // Fallback to old DOM-based checking
          failedReasons.push("Location not valid or current");
        }

        const allConditionsMet =
          conditions.deviceOnline &&
          conditions.locationFresh &&
          conditions.deviceStationary;

        return {
          canDispatch: allConditionsMet,
          conditions: conditions,
          passedReasons: passedReasons,
          failedReasons: failedReasons,
        };
      }

      function generateDispatchAnalysisNotes(result) {
        // Get location and communication data from connectivity panel
        const locationElement = document.getElementById("device-location");
        const lastCommElement = document.getElementById("last-comm-time");
        const location = locationElement
          ? locationElement.textContent
          : "Location unknown";
        const lastComm = lastCommElement
          ? lastCommElement.textContent
          : "Communication time unknown";

        if (result.canDispatch) {
          // Get current dispatch step dynamically
          const currentDispatchStep = document
            .querySelector('.step.active [onclick*="checkDispatchConditions"]')
            ?.closest(".step")?.id;
          const stepNumber = currentDispatchStep
            ? currentDispatchStep.replace("step-", "")
            : "5";

          // Get all connectivity data
          const locationTimestamp =
            document
              .getElementById("location-timestamp")
              ?.textContent?.trim() || "";
          const address =
            document.getElementById("device-location")?.textContent?.trim() ||
            "";
          const coordinates =
            document
              .getElementById("device-coordinates")
              ?.textContent?.trim() || "";
          const speed =
            document.getElementById("device-speed")?.textContent?.trim() || "";
          const lastCommTimestamp =
            document
              .querySelector('[id*="last-communication"]')
              ?.textContent?.trim() || "";
          const battery =
            document.querySelector('[id*="battery"]')?.textContent?.trim() ||
            "";

          // Get signal data based on device type
          const deviceType = currentUser?.device?.includes("G7x")
            ? "G7x"
            : "G7c";
          let signalInfo = "";

          if (deviceType === "G7x") {
            const deviceSignal =
              document
                .querySelector('[id*="device-signal"]')
                ?.textContent?.trim() || "";
            const bridgeSignal =
              document
                .querySelector('[id*="bridge-signal"]')
                ?.textContent?.trim() || "";
            signalInfo =
              "**Device Signal Strength** - " +
              deviceSignal +
              "\n" +
              "**Bridge Signal Strength** - " +
              bridgeSignal +
              "\n\n";
          } else {
            const signal =
              document.querySelector('[id*="signal"]')?.textContent?.trim() ||
              "";
            signalInfo = "**Signal Strength** - " + signal + "\n\n";
          }

          return (
            `Step ${stepNumber}: Called dispatch, spoke to ___. Dispatched [SELECTED_SERVICES] to following location:\n\n` +
            "**Last Location**\n" +
            locationTimestamp +
            "\n\n" +
            "**Approximate Address**\n" +
            address +
            "\n\n" +
            "**Latitude / Longitude**\n" +
            coordinates +
            "\n\n" +
            "**Speed** - " +
            speed +
            "\n\n" +
            "**Last Communication**\n" +
            lastCommTimestamp +
            "\n\n" +
            "**Battery** - " +
            battery +
            "\n" +
            signalInfo
          );
        } else {
          // Get current dispatch step dynamically for proper step numbering
          const currentDispatchStep = document
            .querySelector('.step.active [onclick*="checkDispatchConditions"]')
            ?.closest(".step")?.id;
          const stepNumber = currentDispatchStep
            ? currentDispatchStep.replace("step-", "")
            : "5";

          // Get specific failed condition
          const failedCondition = result.failedReasons[0];

          // Just return the note text - no action triggering
          const stepMessage = `Step ${stepNumber}: Unable to dispatch - ${failedCondition.toLowerCase()}`;

          return stepMessage;
        }
      }

      // Function to restart protocol cycle
      function restartProtocolCycle() {
        console.log("🔄 Restarting protocol cycle - enabling steps 1-4");

        // ── Reset per-cycle runtime state ─────────────────────────────────────
        if (!window.protocolState) window.protocolState = {};
        if (
          protocolState.startedSteps &&
          typeof protocolState.startedSteps.clear === "function"
        ) {
          protocolState.startedSteps.clear();
        }
        if (Array.isArray(protocolState.completedSteps)) {
          protocolState.completedSteps = protocolState.completedSteps.filter(
            (id) => !/^step-[1-4](?:-.+)?$/.test(id)
          );
        }
        if (
          window.activeTimerData?.isRunning &&
          typeof cancelGlobalTimer === "function"
        ) {
          cancelGlobalTimer({ silent: true });
        }

        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const stepsToReset = ["step-1", "step-2", "step-3", "step-4"];

        stepsToReset.forEach((stepId, index) => {
          const step = document.getElementById(stepId);
          const statusBadge = document.getElementById(stepId + "-status");
          const button = step?.querySelector(
            'button:not([onclick*="postNote"])'
          );
          const isFirstStep = index === 0;

          const cfgStep = protocolConfig?.steps?.find((s) => s.id === stepId);
          const action = cfgStep?.action; // (kept in case you use it later)

          // Main step container reset
          if (step) {
            step.classList.remove("completed", "active");
            if (isFirstStep) step.classList.add("active");
            step.style.opacity = "1";
            step.style.pointerEvents = "auto";
            step.style.position = "";
            step.style.transform = "";

            const outcomeSection = document.getElementById(stepId + "-outcome");
            if (outcomeSection) outcomeSection.style.display = "none";
          }

          if (statusBadge) {
            statusBadge.textContent = isFirstStep ? "Active" : "Pending";
            statusBadge.className = isFirstStep
              ? "status-badge active"
              : "status-badge";
            statusBadge.style.background = "";
            statusBadge.style.color = "";
          }

          if (button) {
            button.disabled = !isFirstStep;
            button.classList.remove("btn-secondary", "btn-primary");
            button.classList.add(isFirstStep ? "btn-primary" : "btn-secondary");
            button.style.pointerEvents = "auto";

            if (!button.getAttribute("onclick")) {
              button.setAttribute("onclick", `startStep('${stepId}')`);
            }

            // keep labels human-friendly after restart
            formatButtonText?.();
          }

          // Sub-steps reset
          const subSteps = document.querySelectorAll(`[id^="${stepId}-"]`);
          subSteps.forEach((subStep) => {
            if (!subStep.classList.contains("sub-step")) return;

            const subStatusBadge = document.getElementById(
              subStep.id + "-status"
            );
            const subButton = subStep.querySelector(
              'button:not([onclick*="postNote"])'
            );

            subStep.classList.remove("completed", "active");

            const isFirstSubStep = isFirstStep && subStep.id.endsWith("-1");
            if (isFirstSubStep) subStep.classList.add("active");

            subStep.style.opacity = "1";
            subStep.style.pointerEvents = "auto";
            subStep.style.position = "";
            subStep.style.transform = "";

            const outcomeSection = document.getElementById(
              subStep.id + "-outcome"
            );
            if (outcomeSection) outcomeSection.style.display = "none";

            if (subStatusBadge) {
              subStatusBadge.textContent = isFirstSubStep
                ? "Active"
                : "Pending";
              subStatusBadge.className = isFirstSubStep
                ? "status-badge active"
                : "status-badge";
              subStatusBadge.style.background = "";
              subStatusBadge.style.color = "";
            }

            if (subButton) {
              subButton.disabled = !isFirstSubStep;
              subButton.classList.remove("btn-primary", "btn-secondary");
              subButton.classList.add(
                isFirstSubStep ? "btn-primary" : "btn-secondary"
              );
              subButton.style.pointerEvents = "auto";

              if (!subButton.getAttribute("onclick")) {
                subButton.setAttribute("onclick", `startStep('${subStep.id}')`);
              }
            }
          });
        });

        // ✅ Auto-scroll to Step 1 and focus its action button
        requestAnimationFrame(() => {
          const firstStep = document.getElementById("step-1");
          if (firstStep) {
            firstStep.scrollIntoView({ behavior: "smooth", block: "center" });
            const btn = firstStep.querySelector(
              'button:not([onclick*="postNote"])'
            );
            if (btn) btn.focus({ preventScroll: true });
          }
        });

        // Re-run connectivity check (device status may have changed during cycle)
        setTimeout(() => {
          checkDeviceConnectivityForSteps();
        }, 200);

        // Log cycle restart
        addLogEntry(
          "🔄 Protocol cycle restarted - checking device connectivity and attempting contact again",
          "system"
        );

        console.log("Protocol cycle restart completed");
      }

      // ═══════════════════════════════════════════════════════════════
      // 🚀 INITIALIZATION & STARTUP
      // ═══════════════════════════════════════════════════════════════

      document.addEventListener("DOMContentLoaded", function () {
        updateGasReadings("default");
        startGasMonitoring();

        // Initialize device connectivity
        DeviceConnectivity.updateConnectivityDisplay();

        // Update connectivity every 30 seconds
        setInterval(() => {
          DeviceConnectivity.updateConnectivityDisplay();
        }, 30000);

        window.addEventListener('beforeunload', stopDynamicAlertTime);

        // REPLACE THE OLD MESSAGE INPUT CODE WITH THIS:
        const messageInput = document.getElementById("manual-message-input");
        const charCounter = document.getElementById("charCounter");
        const sendBtn = document.getElementById("sendMessageBtn");

        if (messageInput && charCounter && sendBtn) {
          // Initialize character counter on page load
          updateCharacterCounter();

          // Add event listeners for real-time updates with our new functions
          messageInput.addEventListener("input", function (e) {
            handleAutoLineBreak(e);
            updateCharacterCounter();
          });

          messageInput.addEventListener("keydown", function (e) {
            // Prevent Enter if we already have 2 lines
            if (e.key === "Enter" && this.value.split("\n").length >= 2) {
              e.preventDefault();
            }
          });
        }
      });

      document.addEventListener("click", function (event) {
        const demoPanel = document.getElementById("demo-panel");
        const demoGear = document.getElementById("demo-gear");

        if (
          demoPanel &&
          demoGear &&
          !demoPanel.contains(event.target) &&
          !demoGear.contains(event.target)
        ) {
          demoPanel.classList.remove("show");
        }
      });

      function triggerGasNormalization(alertConfig) {
        try {
          const cfg = alertConfig?.gasNormalization;
          if (!cfg?.enabled) return;

          const gasKey = Object.keys(cfg.targetLevels)[0] || "co";
          const target = cfg.targetLevels[gasKey];
          const value =
            typeof target === "object" ? Number(target.value) : Number(target);
          const status =
            typeof target === "object" && target.status
              ? String(target.status)
              : "NORMAL";

          const gasLabel =
            gasKey === "h2s"
              ? "H₂S"
              : gasKey === "o2"
              ? "O₂"
              : gasKey.toUpperCase();
          const unit =
            gasKey === "o2" ? " %vol" : gasKey === "lel" ? " %LEL" : " ppm";
          const newValueStr = `${value.toFixed(2)}${unit}`;

          // Find the Gas Readings (Live) panel
          const panel = Array.from(document.querySelectorAll("*")).find((el) =>
            /Gas Readings\s*\(Live\)/i.test(el.textContent)
          );
          if (!panel) return;

          // Prefer the LIST ".gas-reading" that matches this gas (not the big header)
          const readings = Array.from(panel.querySelectorAll(".gas-reading"));
          const matches = readings.filter((el) => {
            const t = (el.textContent || "").trim().replace(/^[^\w]+/, ""); // strip emoji
            return new RegExp(`^${gasLabel}\\s*:\\s*`, "i").test(t);
          });
          let rowEl =
            matches.find((el) =>
              el.querySelector(".gas-status, .status-pill")
            ) ||
            matches[matches.length - 1] ||
            null;
          if (!rowEl) rowEl = document.getElementById(`${gasKey}-reading`);
          if (!rowEl) return;

          // Peak reading (before change) - Only log if it matches the current alert gas
          let peakReading = "";
          const currentValEl =
            rowEl.querySelector(`#${gasKey}-value`) ||
            document.getElementById(`${gasKey}-value`);
          if (currentValEl && currentValEl.textContent) {
            const m = (currentValEl.textContent.match(/[\d.]+/) || [])[0];
            if (m) peakReading = `${gasLabel} ${Number(m).toFixed(2)}${unit}`;
          } else {
            const m = (rowEl.textContent.match(/:\s*([0-9.]+)/) || [])[1];
            if (m) peakReading = `${gasLabel} ${Number(m).toFixed(2)}${unit}`;
          }

          // Only log if this matches the current alert's gas type
          const currentAlertGas = currentAlert?.gasType?.toLowerCase() || "";
          const isMatchingGas =
            (gasKey === "o2" && currentAlertGas.includes("o2")) ||
            (gasKey === "h2s" && currentAlertGas.includes("h2s")) ||
            (gasKey === "co" && currentAlertGas.includes("co")) ||
            (gasKey === "lel" && currentAlertGas.includes("lel"));

          if (!isMatchingGas) {
            console.log(
              `Skipping ${gasKey} log for alert type ${currentAlertGas}`
            );
            return;
          }

          rowEl.innerHTML = `${gasLabel}:<span id="${gasKey}-value" class="gas-value">${newValueStr}</span>`;
          rowEl.id = `${gasKey}-reading`;

          // Ensure/Update status pill (append at end of the same .gas-reading)
          let pill =
            rowEl.querySelector(`#${gasKey}-status`) ||
            rowEl.querySelector(".gas-status, .status-pill") ||
            null;
          if (!pill) {
            pill = document.createElement("span");
            rowEl.appendChild(pill);
          }
          pill.id = `${gasKey}-status`;
          pill.textContent = status;
          pill.className = `gas-status ${status.toLowerCase()}`;

          // De-dupe stray IDs so future lookups hit THIS row
          ["reading", "value", "status"].forEach((sfx) => {
            Array.from(document.querySelectorAll(`#${gasKey}-${sfx}`)).forEach(
              (el) => {
                if (
                  el !==
                  (sfx === "reading"
                    ? rowEl
                    : sfx === "value"
                    ? rowEl.querySelector(`#${gasKey}-value`)
                    : pill)
                ) {
                  el.removeAttribute("id");
                }
              }
            );
          });

          // Update "Last updated" time
          const tsNode =
            document.querySelector("[data-gas-last-updated]") ||
            document.getElementById("gas-timestamp");
          if (tsNode) {
            const now = new Date();
            tsNode.textContent =
              typeof FORMATTERS?.timeOnlyMST === "function"
                ? FORMATTERS.timeOnlyMST(now)
                : new Intl.DateTimeFormat("en-US", {
                    timeZone: "America/Denver",
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit",
                    hour12: false,
                  }).format(now) + " MDT";
          }

          // System log
          const peakPart = peakReading ? ` Peak: ${peakReading}.` : "";
          addLogEntry(
            `${gasLabel} is no longer exceeding the high threshold.${peakPart} Current: ${gasLabel} ${newValueStr}.`,
            "system"
          );
        } catch (e) {
          console.warn("triggerGasNormalization failed:", e);
        }

        if (typeof silentlyUpdateDispatchConditions === "function") {
          silentlyUpdateDispatchConditions();
        }
      }

      function triggerResolutionFlow(
        fromStepId,
        reason = "User confirmed okay"
      ) {
        // 1. Mark current step complete
        if (fromStepId) {
          markStepCompleted(fromStepId);
        }

        // 2. Block all remaining steps
        blockRemainingSteps(fromStepId, reason);

        // 3. Auto-populate resolution dropdown
        const resolutionSelect = document.getElementById("resolution-reason");
        if (resolutionSelect && !resolutionSelect.value) {
          const resolutionType = determineResolutionType(currentAlert);
          resolutionSelect.value = resolutionType;
        }

        // 4. Scroll to resolution panel
        setTimeout(() => {
          const resolutionSection = document.querySelector(
            ".resolution-section"
          );
          if (resolutionSection) {
            resolutionSection.scrollIntoView({
              behavior: "smooth",
              block: "center",
            });
          }
        }, 300);
      }

      function canStepTriggerResolution(stepId) {
        // Any step can potentially trigger resolution based on its outcome
        // Check if step has resolution-triggering actions
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const stepConfig = protocolConfig.steps.find(
          (step) => step.id === stepId
        );

        // Resolution can be triggered by: Call User, Send Message, Contact ECs, or Dispatch
        const resolutionActions = [
          "call-user",
          "message-device",
          "call-emergency-contacts",
          "dispatch",
        ];
        return stepConfig && resolutionActions.includes(stepConfig.action);
      }

      function enableNextStep(stepId) {
        // Get current protocol to determine next step
        const protocolConfig = ProtocolFactory.getProtocolConfig(
          currentAlert.id
        );
        const currentIndex = protocolConfig.steps.findIndex(
          (step) => step.id === stepId
        );

        // Check if there's a next step
        if (
          currentIndex >= 0 &&
          currentIndex < protocolConfig.steps.length - 1
        ) {
          const nextStep = protocolConfig.steps[currentIndex + 1];
          const nextStepId = nextStep.id;

          const nextStepElement = document.getElementById(nextStepId);
          const nextButton = nextStepElement?.querySelector(
            'button:not([onclick*="postNote"])'
          );

          if (nextStepElement) {
            nextStepElement.classList.add("active");
            nextStepElement.style.opacity = "1";
            nextStepElement.style.pointerEvents = "auto";

            // AUTO-SCROLL: Scroll the newly active step into view
            nextStepElement.scrollIntoView({
              behavior: "smooth",
              block: "center",
            });
          }

          if (nextButton) {
            nextButton.disabled = false;
            nextButton.classList.remove("btn-secondary");
            nextButton.classList.add("btn-primary");
          }

          // Update status badge
          const statusBadge = document.getElementById(nextStepId + "-status");
          if (statusBadge) {
            statusBadge.textContent = "Active";
            statusBadge.className = "status-badge active";
          }

          // Auto-evaluate dispatch conditions if next step is dispatch
          if (nextStep.action === "dispatch") {
            setTimeout(() => {
              checkDispatchConditions(nextStepId);
            }, 500);
          }
        }
      }

      // Silent background monitoring - NO LOGGING
      function initializeDispatchMonitoring() {
        // Initial silent evaluation
        silentlyUpdateDispatchConditions();

        // Background monitoring every 2 minutes
        setInterval(silentlyUpdateDispatchConditions, 120000);
      }

      function autoPopulateDispatchNote(stepId) {
        const serviceSelect = document.getElementById("dispatch");
        const textarea = document.getElementById(stepId + "-note");
        const selectedService = serviceSelect?.value;

        if (selectedService && textarea) {
          const stepNumber = stepId.replace("step-", "");

          // Get real connectivity data
          const location = document
            .getElementById("device-location")
            .textContent.trim();
          const coordinates = document
            .getElementById("device-coordinates")
            .textContent.trim();
          const speed = document
            .getElementById("device-speed")
            .textContent.trim();
          const lastComm = document
            .getElementById("last-comm-time")
            .textContent.trim();
          const battery = document
            .getElementById("battery-level")
            .textContent.trim();
          const signal = document
            .getElementById("signal-strength")
            .textContent.trim();

          // Generate today's timestamp for dispatch purposes
          const now = new Date();
          const todaysTimestamp =
            now.toLocaleDateString("en-US", {
              year: "numeric",
              month: "short",
              day: "2-digit",
            }) +
            " at " +
            now.toLocaleTimeString("en-US", {
              hour: "2-digit",
              minute: "2-digit",
              hour12: false,
            }) +
            " MDT";

          const dispatchNote = `Step ${stepNumber}: Called dispatch, spoke to ___. Dispatched ${selectedService} to the following location:

      Last Location Date/Time: ${todaysTimestamp} (just now)

      Approximate Address: ${location}

      Latitude / Longitude: ${coordinates}

      Speed: ${speed}

      Last Communication: ${lastComm}

      Battery: ${battery}

      Signal Strength: ${signal}

      Waiting 30 minutes.`;

          textarea.value = dispatchNote;
          validatePostButton(stepId);
        }
      }

      // Silent background monitoring - NO LOGGING
      function initializeDispatchMonitoring() {
        // Initial silent evaluation
        silentlyUpdateDispatchConditions();

        // Background monitoring every 2 minutes
        setInterval(silentlyUpdateDispatchConditions, 120000);
      }

      function determineResolutionType(alertData) {
  const alert = alertData || window.currentAlert || {};

  // EMERGENCY DEBUG - Find the source of dispatchMade = true
  console.log("=== DISPATCH RESOLUTION DEBUG ===");
  console.log("window.dispatchMade:", window.dispatchMade);
  console.log("window.protocolState?.dispatchMade:", window.protocolState?.dispatchMade);
  console.log("typeof dispatchMade:", typeof dispatchMade !== 'undefined' ? dispatchMade : 'undefined');
  console.log("CALL STACK TRACE:");
  console.trace();
  
  // Force all dispatch flags to false temporarily to test
  console.log("FORCING ALL DISPATCH FLAGS TO FALSE FOR TESTING");
  window.dispatchMade = false;
  if (window.protocolState) {
    window.protocolState.dispatchMade = false;
  }
  if (typeof dispatchMade !== 'undefined') {
    dispatchMade = false;
  }
  
  // Pre-alert always wins
  if (alert?.isPreAlert === true || window.currentAlert?.isPreAlert === true) {
    return "pre-alert";
  }

  // Gas vs non-gas
  const isGas = 
    (typeof isGasAlert === "function" && isGasAlert(alert)) ||
    /(^gas-|h2s|co|o2|lel)/i.test(alert?.id || "") ||
    /h2s|co|o2|lel/i.test(alert?.gasType || "");

  const category = isGas ? "incident" : "false-alert";

  // COMPREHENSIVE DISPATCH DETECTION - Check multiple sources
  let wasDispatched = false;

  // Method 1: Check global dispatch flags
  wasDispatched = window.dispatchMade === true || 
                 window.protocolState?.dispatchMade === true ||
                 (typeof dispatchMade !== 'undefined' && dispatchMade === true);

  // Method 2: Check dispatch step completion + decision
  if (!wasDispatched) {
    const dispatchStepCompleted = window.protocolState?.completedSteps?.some(stepId => 
      stepId === 'step-5' || stepId.includes('dispatch')
    );
    const dispatchDecisionMade = document.querySelector('#dispatch-decision')?.value === 'yes';
    wasDispatched = dispatchStepCompleted && dispatchDecisionMade;
  }

  // Method 3: Check logs for dispatch evidence (MOST RELIABLE)
  if (!wasDispatched) {
    const logContainer = document.getElementById("protocolLog");
    if (logContainer) {
      const logText = logContainer.textContent || "";
      // Look for specific dispatch log patterns
      wasDispatched = /step \d+:.*dispatch decision - yes|dispatched.*emergency services|called dispatch.*services|dispatch.*yes.*services/i.test(logText);
    }
  }

  // Method 4: Check for dispatch notes in completed steps
  if (!wasDispatched && window.protocolState?.completedSteps) {
    for (const stepId of window.protocolState.completedSteps) {
      const noteElement = document.getElementById(`${stepId}-note`);
      if (noteElement && noteElement.value) {
        const noteText = noteElement.value.toLowerCase();
        if (noteText.includes('dispatch') && (noteText.includes('yes') || noteText.includes('emergency services'))) {
          wasDispatched = true;
          break;
        }
      }
    }
  }

  // Method 5: Check log entries for dispatch activity
  if (!wasDispatched) {
    const logEntries = document.querySelectorAll('.log-entry');
    for (const entry of logEntries) {
      const entryText = (entry.textContent || "").toLowerCase();
      if (/dispatch.*confirmed|emergency services.*dispatched|ems.*dispatched|called dispatch.*services/i.test(entryText)) {
        wasDispatched = true;
        break;
      }
    }
  }

  const suffix = wasDispatched ? "with-dispatch" : "without-dispatch";
  const result = `${category}-${suffix}`;
  
  console.log("DEBUG RESOLUTION:");
  console.log("  - Alert ID:", alert?.id);
  console.log("  - Is Gas:", isGas);
  console.log("  - Category:", category);
  console.log("  - Dispatch Flags:", {
    dispatchMade: window.dispatchMade,
    protocolDispatchMade: window.protocolState?.dispatchMade,
    globalDispatchMade: typeof dispatchMade !== 'undefined' ? dispatchMade : 'undefined'
  });
  console.log("  - Completed Steps:", window.protocolState?.completedSteps);
  console.log("  - Dispatch Decision:", document.querySelector('#dispatch-decision')?.value);
  console.log("  - Was Dispatched:", wasDispatched);
  console.log("  - Final Result:", result);
  
  return result;
}

function handleMessageDeviceOutcome(selectedValue, currentUser, currentAlert) {
  const prompt = (window.lastPromptSent || '').toLowerCase();
  const isEvacContext = /leave the area/.test(prompt);
  const isGasAlert = currentAlert && currentAlert.id === 'gas-high-threshold';

  const dangerousNow = !!(isGasAlert && (
    (typeof isAnyGasDangerousNow === 'function' && isAnyGasDangerousNow()) ||
    (typeof isGasLevelHigh === 'function' && isGasLevelHigh()) ||
    (typeof isGasCurrentlyNormalized === 'function' ? !isGasCurrentlyNormalized() : true)
  ));

  let noteText = '';
  let shouldScrollToResolution = false;

  // NEW: what should the UI do next?
  // 'SOS' | 'RESOLUTION' | 'PREPARE' | 'CONTINUE'
  let action = 'CONTINUE';

  if (selectedValue === 'no-response') {
    noteText = `Sent message "Do you need help?" to device. No response received`;
  } else if (selectedValue === 'unable-to-send') {
    noteText = `Unable to send text message, device offline`;
  } else if (selectedValue === 'device-no') {
    noteText = `Received message "No" from device. User confirmed okay`;
    shouldScrollToResolution = true;
    action = isEvacContext ? 'SOS' : (dangerousNow ? 'PREPARE' : 'RESOLUTION'); // "No" to "Do you need help?" = OK; to evacuation would be SOS
  } else if (selectedValue === 'issue-resolved') {
    noteText = `Received message "Issue resolved" from device. User confirmed okay`;
    shouldScrollToResolution = true;
    action = dangerousNow ? 'PREPARE' : 'RESOLUTION';
  } else if (selectedValue === 'false-alarm') {
    noteText = `Received message "False alarm" from device. User confirmed okay`;
    shouldScrollToResolution = true;
    action = dangerousNow ? 'PREPARE' : 'RESOLUTION';
  } else if (selectedValue === 'understood') {
    noteText = `Received message "Understood" from device. User confirmed okay`;
    shouldScrollToResolution = true;
    // Evac ack → resolve if NORMAL, gate if HIGH
    action = dangerousNow ? 'PREPARE' : 'RESOLUTION';
  } else if (selectedValue === 'device-yes') {
    noteText = `Received message "Yes" from device. User confirmed okay`;
    shouldScrollToResolution = true;
    // "Yes" to "Are you OK?" = resolve; to evacuation = resolve if NORMAL, otherwise prepare
    action = isEvacContext ? (dangerousNow ? 'PREPARE' : 'RESOLUTION') : (dangerousNow ? 'PREPARE' : 'RESOLUTION');
  } else if (selectedValue === 'send-help') {
    noteText = `Received message "Send help" from device. Immediate assistance requested`;
    // This should trigger SOS, not resolution
    shouldScrollToResolution = false;
    action = 'SOS';
  }

  return { noteText, shouldScrollToResolution, action, dangerousNow };
}

// Get appropriate cancel options based on step/protocol
function getTimerCancelOptions(stepId, label) {
  // Get current protocol info
  const protocolConfig = ProtocolFactory.getProtocolConfig(currentAlert?.id);
  const protocolName = protocolConfig?.name || "";
  
  // HOMOGENEOUS: All message-device steps get the same options
  const isMessageDeviceStep = (
    (stepId === "step-2" && (protocolName.includes("Fall Detection") || protocolName.includes("Gas Emergency"))) ||
    (stepId === "step-1" && (protocolName.includes("No Motion") || protocolName.includes("Missed Check")))
  );
  
  if (isMessageDeviceStep) {
    return `
      <option value="user-callback">User called in and confirmed they are okay</option>
      <option value="ec-callback">Emergency contact called in and confirmed user is okay</option>
      <option value="ec-callback-30min">EC called in, they will check on user and call back</option>
      <option value="device-offline">Device went offline</option>
    `;
  }
  
  // For Emergency Contact steps (Step 3)
  if (stepId === "step-3" || label.includes("EC Callback")) {
    return `
      <option value="user-callback">User called in and confirmed they are okay</option>
      <option value="ec-callback">Emergency contact called in and confirmed user is okay</option>
      <option value="ec-callback-30min">EC called in, will check on user and call back (30 min timer)</option>
    `;
  }
  
  // For Dispatch Follow-up timers
  if (label && label.includes("Dispatch Follow-up")) {
    return `
      <option value="user-callback">User called in and confirmed they are okay</option>
      <option value="ec-callback">Emergency contact called in and confirmed user is okay</option>
      <option value="dispatch-no-emergency">Dispatch called back, no emergency found at location</option>
      <option value="dispatch-user-okay">Dispatch called back, user confirmed okay on scene</option>
      <option value="ec-callback-30min">Emergency contact called in - Will contact user and call back (30 min timer)</option>
    `;
  }
  
  // Default options for other timers
  return `
    <option value="user-callback">User called in and confirmed they are okay</option>
    <option value="ec-callback">Emergency contact called in and confirmed user is okay</option>
    <option value="dispatch-no-emergency">Dispatch called back, no emergency found at location</option>
    <option value="dispatch-user-okay">Dispatch called back, user confirmed okay on scene</option>
  `;
}

function handleGlobalTimerCancellation(reason) {

  console.log("=== DISPATCH STATE DEBUG BEFORE PRESERVATION ===");
  console.log("window.dispatchMade:", window.dispatchMade);
  console.log("window.protocolState?.dispatchMade:", window.protocolState?.dispatchMade);
  console.log("typeof dispatchMade:", typeof dispatchMade !== 'undefined' ? dispatchMade : 'undefined');
  console.log("protocolState.completedSteps:", window.protocolState?.completedSteps);

  if (!reason) return;

  console.log("Timer cancellation selected:", reason);

  // CRITICAL FIX: Preserve dispatch state BEFORE any resolution processing (CORRECTED)
const wasDispatched = 
  window.dispatchMade === true || 
  window.protocolState?.dispatchMade === true || 
  (typeof dispatchMade !== 'undefined' && dispatchMade === true);

// REMOVED the faulty log scanning and DOM element checking that was causing false positives

// Set dispatch state in multiple places to ensure persistence
if (wasDispatched) {
  window.dispatchMade = true;
  dispatchMade = true;
  if (window.protocolState) {
    window.protocolState.dispatchMade = true;
  }
  console.log("PRESERVED dispatch state before resolution:", wasDispatched);
}

  // Handle ec-callback-30min for dispatch timers FIRST - don't stop the timer!
  if (reason === "ec-callback-30min") {
    const isDispatchTimer = activeTimerData?.label?.includes("Dispatch Follow-up");
    
    if (isDispatchTimer) {
      // For dispatch timers: keep running unaffected, just log the entry
      addLogEntry(
        "Emergency contact called in, will check on user and call back within 30 minutes.",
        "step"
      );
      console.log("DEBUG: Keeping dispatch timer running - EC will call back");
      return; // Exit without stopping or affecting the timer
    }
  }

  // Store timer state BEFORE stopping it
  const wasTimerActive = !!globalTimerInterval;
  const wasDispatchTimer =
    activeTimerData?.label?.includes("Dispatch Follow-up");

  // Stop the timer (only reached for non-dispatch timers or other reasons)
  if (globalTimerInterval) {
    clearInterval(globalTimerInterval);
    globalTimerInterval = null;
    globalTimerEndTime = null;
  }

  // Get current step info BEFORE clearing activeTimerData
  let currentStepId = activeTimerData?.stepId;
  let originalStepId = activeTimerData?.originalStepId;

  // Handle EC callback special case
  if (currentStepId === "ec-callback") {
    currentStepId = originalStepId || "message-device";
    console.log("Adjusted currentStepId for EC callback:", currentStepId);
  }

  // Handle different cancellation reasons
  if (reason === "user-callback") {
    // FIXED: Clear message timer too
    if (messageTimer) {
      clearTimeout(messageTimer);
      messageTimer = null;
      awaitingResponse = false;
    }

    let logMessage =
      "User called in and confirmed they are okay. Resolving alert.";

    // Add gas info for gas alerts
    if (currentAlert && isGasAlert(currentAlert)) {
      const gasData = getGasSnapshotFromPanel();
      if (gasData && gasData.trim()) {
        logMessage += `<br><br>${gasData.replace(/\n/g, "<br>")}`;
      }
    }

    addLogEntry(logMessage, "step");

    // Mark the originating step as completed before triggering resolution
    if (currentStepId && canStepTriggerResolution(currentStepId)) {
      console.log("Marking step as completed:", currentStepId);
      markStepCompleted(currentStepId);

      // Also mark main step as completed if this is a sub-step
      if (
        currentStepId.includes("-") &&
        currentStepId.split("-").length === 3
      ) {
        const mainStepId = currentStepId.substring(
          0,
          currentStepId.lastIndexOf("-")
        );
        console.log(`Also marking main ${mainStepId} as completed`);
        markStepCompleted(mainStepId);
      }

      console.log("Step marked as completed, now triggering resolution");
    }

    // Use unified resolution flow
    console.log(
      "Calling triggerResolutionFlow with stepId:",
      currentStepId
    );
    if (currentStepId) {
      triggerResolutionFlow(currentStepId, "User confirmed okay");
    } else {
      console.error("NO STEP ID - Resolution flow failed!");
    }
  } else if (reason === "ec-callback") {
    // FIXED: Clear message timer too
    if (messageTimer) {
      clearTimeout(messageTimer);
      messageTimer = null;
      awaitingResponse = false;
    }

    // Save current resolution before triggering flow
    const resolutionSelect = document.getElementById("resolution-reason");
    const currentResolution = resolutionSelect
      ? resolutionSelect.value
      : "";

    let logMessage =
      "Emergency contact called in and confirmed user is okay. Resolving alert.";

    // Add gas info for gas alerts
    if (currentAlert && isGasAlert(currentAlert)) {
      const gasData = getGasSnapshotFromPanel();
      if (gasData && gasData.trim()) {
        logMessage += `<br><br>${gasData.replace(/\n/g, "<br>")}`;
      }
    }

    addLogEntry(logMessage, "step");

    // Use unified resolution flow
    console.log(
      "Calling triggerResolutionFlow with stepId:",
      currentStepId
    );
    if (currentStepId) {
      triggerResolutionFlow(currentStepId, "EC confirmed user okay");
    } else {
      console.error("NO STEP ID - Resolution flow failed!");
    }

    // Restore resolution if it was already set correctly
    if (
      currentResolution &&
      currentResolution.includes("with-dispatch") &&
      dispatchMade
    ) {
      setTimeout(() => {
        if (resolutionSelect) {
          resolutionSelect.value = currentResolution;
        }
      }, 100);
    }
  } else if (reason === "dispatch-no-emergency") {
    // FIXED: Clear message timer too
    if (messageTimer) {
      clearTimeout(messageTimer);
      messageTimer = null;
      awaitingResponse = false;
    }

    let logMessage =
      "Dispatch called back, no emergency found at location. Resolving alert.";

    // Add gas info for gas alerts
    if (currentAlert && isGasAlert(currentAlert)) {
      const gasData = getGasSnapshotFromPanel();
      if (gasData && gasData.trim()) {
        logMessage += `<br><br>${gasData.replace(/\n/g, "<br>")}`;
      }
    }

    addLogEntry(logMessage, "step");

    // Use unified resolution flow
    console.log(
      "Calling triggerResolutionFlow with stepId:",
      currentStepId
    );
    if (currentStepId) {
      triggerResolutionFlow(currentStepId, "Dispatch confirmed no emergency");
    } else {
      console.error("NO STEP ID - Resolution flow failed!");
    }
  } else if (reason === "dispatch-user-okay") {
    // FIXED: Clear message timer too
    if (messageTimer) {
      clearTimeout(messageTimer);
      messageTimer = null;
      awaitingResponse = false;
    }

    let logMessage =
      "Dispatch called back, user confirmed okay on scene. Resolving alert.";

    // Add gas info for gas alerts
    if (currentAlert && isGasAlert(currentAlert)) {
      const gasData = getGasSnapshotFromPanel();
      if (gasData && gasData.trim()) {
        logMessage += `<br><br>${gasData.replace(/\n/g, "<br>")}`;
      }
    }

    addLogEntry(logMessage, "step");

    // Use unified resolution flow
    console.log(
      "Calling triggerResolutionFlow with stepId:",
      currentStepId
    );
    if (currentStepId) {
      triggerResolutionFlow(currentStepId, "Dispatch confirmed user okay");
    } else {
      console.error("NO STEP ID - Resolution flow failed!");
    }
  } else if (reason === "ec-callback-30min") {
    // Handle non-dispatch timers (dispatch timers already handled above)
    console.log("DEBUG: dispatchMade =", dispatchMade);
    console.log("DEBUG: globalTimerInterval =", globalTimerInterval);
    console.log(
      "DEBUG: condition result =",
      !dispatchMade && !globalTimerInterval
    );
    addLogEntry(
      "Emergency contact called in, will check on user and call back within 30 minutes.",
      "step"
    );

    // Only start new timer if no dispatch is active
    if (!dispatchMade && !globalTimerInterval) {
        console.log("DEBUG: Starting new timer");
        if (currentStepId) {
            startGlobalTimer(
                "ec-callback",
                "EC Callback",
                "Emergency Contact",
                1800
            );
        }

        // Update timer info display
        const info = document.getElementById("timerInfo");
        if (info) {
            info.innerHTML = "<strong>Waiting for EC callback</strong>";
        }
    } else {
        console.log(
            "DEBUG: NOT starting new timer - keeping existing dispatch timer"
        );
    }

    // Don't show "Timer cancelled" - return early
    return;
  } else if (reason === "device-offline") {
    // Clear message timer too
    if (messageTimer) {
      clearTimeout(messageTimer);
      messageTimer = null;
      awaitingResponse = false;
    }
    
    addLogEntry("Device went offline", "step");
    if (currentStepId) {
      markStepCompleted(currentStepId);

      // Get the step's action to determine if it's an emergency contact step
      const protocolConfig = ProtocolFactory.getProtocolConfig(
        currentAlert.id
      );
      const mainStepId = currentStepId.substring(
        0,
        currentStepId.lastIndexOf("-")
      );
      const stepConfig = protocolConfig.steps.find(
        (step) => step.id === mainStepId
      );
      const stepAction = stepConfig?.action;

      // Also mark main step as completed if this is a sub-step (but NOT for EC steps)
      if (
        currentStepId.includes("-") &&
        currentStepId.split("-").length === 3 &&
        stepAction !== "call-emergency-contact" // Check action instead of step number
      ) {
        console.log(`Also marking main ${mainStepId} as completed`);
        markStepCompleted(mainStepId);
      }

      enableNextStep(currentStepId);
    }
  } else if (reason === "custom") {
    const customReason = prompt("Enter cancellation reason:");
    if (customReason) {
      // FIXED: Clear message timer too
      if (messageTimer) {
        clearTimeout(messageTimer);
        messageTimer = null;
        awaitingResponse = false;
      }
      
      addLogEntry("Timer cancelled: " + customReason, "step");
      if (currentStepId) {
        markStepCompleted(currentStepId);
        enableNextStep(currentStepId);
      }
    }
}

  // Reset timer display
  const display = document.getElementById("timerDisplay");
  const info = document.getElementById("timerInfo");
  const globalTimer = document.getElementById("globalTimer");

  if (display) display.textContent = "--:--";
  if (info) info.innerHTML = "<strong>Timer cancelled</strong>";
  if (globalTimer) {
    globalTimer.classList.remove("timer-active");
    globalTimer.classList.add("timer-inactive");
  }

  // Reset the dropdown
  const dropdown = document.querySelector(
    '[data-cy="global-cancel-dropdown"]'
  );
  if (dropdown) dropdown.value = "";

  // Clear activeTimerData ONLY if not starting a new timer
  if (reason !== "ec-callback-30min") {
    activeTimerData = null;
  }
}

function clearDeviceConnectivity() {
  // Clear device connectivity panel
  const setText = (id, text) => {
    const el = document.getElementById(id);
    if (el) el.textContent = text;
  };
  
  setText("device-online-status", "No device");  // FIXED: was "device-status"
  setText("last-comm-time", "--");
  setText("battery-level", "--%");
  setText("signal-strength", "--%");
  setText("device-location", "No location data");
  setText("device-coordinates", "--");           // ADD: missing element
  setText("device-speed", "-- km/h");
  setText("location-timestamp", "--");           // ADD: missing element
  
  // Clear gas timestamp
  const gasTimestamp = document.getElementById("gas-timestamp");
  if (gasTimestamp) gasTimestamp.textContent = "-- MDT";
}

function updateO2Status(value, status) {
    const statusElement = document.getElementById('o2-status');
    if (!statusElement) return;
    
    statusElement.textContent = status;
    statusElement.classList.remove('normal', 'high', 'depletion', 'enrichment');
    
    if (status === 'O2 Depletion' || status === 'DEPLETION') {
        statusElement.classList.add('depletion');
    } else if (status === 'O2 Enrichment' || status === 'ENRICHMENT') {
        statusElement.classList.add('enrichment');
    } else {
        statusElement.classList.add('normal');
    }
}
    </script>
  </body>
</html>
